<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API接口文档管理工具：Swagger</title>
    <url>/2021/11/15/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9ASwagger/</url>
    <content><![CDATA[<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</p>
<span id="more"></span>

<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>分组开发工具，可以设置不同的组（Docket.groupname），每个组负责开发不同的功能模块。</p>
<p>前端可视化后端API接口（实时更新），可以对controller进行测试。</p>
<ul>
<li>号称世界上最流行的API框架；</li>
<li>RestFul API文档在线自动生成工具=》API文档域API自动更新。</li>
<li>直接运行，可以在线测试API接口。</li>
<li>支持多种语言。</li>
</ul>
<h2 id="一、在项目中使用Swagger"><a href="#一、在项目中使用Swagger" class="headerlink" title="一、在项目中使用Swagger"></a>一、在项目中使用Swagger</h2><p>需要springbox；</p>
<ul>
<li>swagger2</li>
<li>ui</li>
</ul>
<h2 id="二、在SpringBoot中集成swagger"><a href="#二、在SpringBoot中集成swagger" class="headerlink" title="二、在SpringBoot中集成swagger"></a>二、在SpringBoot中集成swagger</h2><h3 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h3><h3 id="2-导入依赖"><a href="#2-导入依赖" class="headerlink" title="2.导入依赖"></a>2.导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure>



<h3 id="3-编写hello工程。"><a href="#3-编写hello工程。" class="headerlink" title="3.编写hello工程。"></a>3.编写hello工程。</h3><h3 id="4-集成swagger-》config"><a href="#4-集成swagger-》config" class="headerlink" title="4.集成swagger==》config"></a>4.集成swagger==》config</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span>         <span class="hljs-comment">//开启swagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="5-访问网址："><a href="#5-访问网址：" class="headerlink" title="5.访问网址："></a>5.访问网址：</h3><p><a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211018110821946.png" alt="image-20211018110821946"></p>
<h2 id="三、配置swagger"><a href="#三、配置swagger" class="headerlink" title="三、配置swagger"></a>三、配置swagger</h2><h3 id="swagger的bean实例Docket："><a href="#swagger的bean实例Docket：" class="headerlink" title="swagger的bean实例Docket："></a>swagger的bean实例Docket：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span>         <span class="hljs-comment">//开启swagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br>    <span class="hljs-comment">//配置swagger的Docket bean实例。</span><br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());<br>    &#125;<br>    <span class="hljs-comment">//配置swagger信息=apiInfo</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;<br>        Contact contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;李文凯&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;li17669498364@163.com&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(<span class="hljs-string">&quot;李文凯的swaggerAPI文档&quot;</span>,<br>                <span class="hljs-string">&quot;加油，冲刺&quot;</span>,<br>                <span class="hljs-string">&quot;1.0&quot;</span>,<br>                <span class="hljs-string">&quot;urn:tos&quot;</span>,<br>                contact,<br>                <span class="hljs-string">&quot;Apache 2.0&quot;</span>,<br>                <span class="hljs-string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,<br>                <span class="hljs-keyword">new</span> ArrayList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211018112506760.png" alt="image-20211018112506760"></p>
<h3 id="Swagger配置扫描接口"><a href="#Swagger配置扫描接口" class="headerlink" title="Swagger配置扫描接口"></a>Swagger配置扫描接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).<br>            apiInfo(apiInfo())<br>            .select()<br>            <span class="hljs-comment">//配置要扫描接口的方式</span><br>            <span class="hljs-comment">//basePackage：指定要扫描的包。</span><br>            <span class="hljs-comment">//any()：扫描全部</span><br>            <span class="hljs-comment">//none（）：不扫描</span><br>            <span class="hljs-comment">//withClassAnnotation：扫描雷伤的注解，参数是一个注解的反射对象。</span><br>            <span class="hljs-comment">//withMethodAnnotation：扫描方法上的注解</span><br>            .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.kai.controller&quot;</span>))<br>            <span class="hljs-comment">//paths（）。过滤什么路径</span><br>            .paths(PathSelectors.ant(<span class="hljs-string">&quot;/kai/**&quot;</span>))<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211018151937769.png" alt="image-20211018151937769"></p>
<h3 id="配置自动启动config"><a href="#配置自动启动config" class="headerlink" title="配置自动启动config"></a>配置自动启动config</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).<br>                apiInfo(apiInfo())<br>                <span class="hljs-comment">//swagger是否启动，如果为false，则swagger不能再浏览器中访问。</span><br>                .enable(<span class="hljs-keyword">false</span>)<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018152317499.png" alt="image-20211018152317499"></p>
<h3 id="需求：在生产环境有使用swagger自动启动，在运行环境中不使用。"><a href="#需求：在生产环境有使用swagger自动启动，在运行环境中不使用。" class="headerlink" title="需求：在生产环境有使用swagger自动启动，在运行环境中不使用。"></a>需求：在生产环境有使用swagger自动启动，在运行环境中不使用。</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span>         <span class="hljs-comment">//开启swagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br>    <span class="hljs-comment">//配置swagger的Docket bean实例。</span><br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">(Environment environment)</span></span>&#123;<br><br>        <span class="hljs-comment">//设置要显示的swagger环境。</span><br>        Profiles profiles = Profiles.of(<span class="hljs-string">&quot;dev&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-comment">//通过environment.acceptsProfiles判断是否处在自己设定的环境中。</span><br>        <span class="hljs-keyword">boolean</span> flag = environment.acceptsProfiles(profiles);<br>        System.out.println(flag);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).<br>                apiInfo(apiInfo())<br>                <span class="hljs-comment">//swagger是否启动，如果为false，则swagger不能再浏览器中访问。</span><br>                .enable(flag)<br>                .select()<br>                <span class="hljs-comment">//配置要扫描接口的方式</span><br>                <span class="hljs-comment">//basePackage：指定要扫描的包。</span><br>                <span class="hljs-comment">//any()：扫描全部</span><br>                <span class="hljs-comment">//none（）：不扫描</span><br>                <span class="hljs-comment">//withClassAnnotation：扫描雷伤的注解，参数是一个注解的反射对象。</span><br>                <span class="hljs-comment">//withMethodAnnotation：扫描方法上的注解</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.kai.controller&quot;</span>))<br>                <span class="hljs-comment">//paths（）。过滤什么路径</span><br><span class="hljs-comment">//                .paths(PathSelectors.ant(&quot;/kai/**&quot;))</span><br>                .build();<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="配置API文档分组"><a href="#配置API文档分组" class="headerlink" title="配置API文档分组"></a>配置API文档分组</h3><p>配置一个组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).<br>        apiInfo(apiInfo())<br>        .groupName(<span class="hljs-string">&quot;Liwenkai&quot;</span>)<br></code></pre></td></tr></table></figure>



<p>配置多个组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多个docket分组</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;A&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;B&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket3</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;C&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实体类配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiModel(&quot;用户实体类&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;姓名&quot;)</span><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;年龄&quot;)</span><br>    <span class="hljs-keyword">public</span> Integer age;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@ApiOperation(&quot;用户控制类&quot;)</span>     <span class="hljs-comment">//API 接口注释，放在方法上</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/hello&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//只要调用的controller中存在user对象，他就会被扫描扫swagger中。</span><br>    <span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211018161610774.png" alt="image-20211018161610774"></p>
<h2 id="四、swagger的作用"><a href="#四、swagger的作用" class="headerlink" title="四、swagger的作用"></a>四、swagger的作用</h2><p>模拟前端往后端传递数据的过程。可以从前端中测试后端中的API。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211018170441331.png" alt="image-20211018170441331"></p>
<p>当出现错误时，可以在这个swagger UI界面中显示出来。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211018170629978.png" alt="image-20211018170629978"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>通过swagger给一些比较难理解的属性和接口，增加注释信息。</li>
<li>接口文档可以实时更新。</li>
<li>可以在线测试。</li>
</ol>
<p>==<strong>注意点，在正式发布时，需要关闭swagger，处于安全考虑，并且节省内存。</strong>==</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Ambari</title>
    <url>/2021/12/04/Ambari/</url>
    <content><![CDATA[<p>Ambari是hadoop分布式集群配置管理工具；从Ambari 的作用来说，就是<strong>创建、管理、监视 Hadoop 的集群</strong>，但是这里的 Hadoop 是广义，指的是 Hadoop 整个生态圈(例如 Hive数据仓库，Hbase数据库，Sqoop，Zookeeper 等)，而并不仅是特指 Hadoop。用一句话来说，Ambari 就是为了让 Hadoop 以及相关的大数据软件更容易使用的一个工具。</p>
<span id="more"></span>



<h1 id="Ambari的作用"><a href="#Ambari的作用" class="headerlink" title="Ambari的作用"></a>Ambari的作用</h1><ul>
<li><p>提供Hadoop集群</p>
<ul>
<li>Ambari提供了跨任意数量的主机安装Hadoop服务的分步向导</li>
<li>Ambari处理群集的Hadoop服务配置</li>
</ul>
</li>
<li><p>管理Hadoop集群</p>
<ul>
<li>集中管理，用于在整个集群中启动、停止和重新配置Hadoop集群</li>
</ul>
</li>
<li><p>监控Hadoop集群</p>
<ul>
<li>收集Hadoop的运行指标</li>
<li>提供了一个仪表盘，监控Hadoop集群的运行情况</li>
<li>故障预警</li>
</ul>
</li>
</ul>
<p><strong>Ambari使应用程序开发人员和系统集成商能够</strong></p>
<ul>
<li>使用Ambari REST API轻松将Hadoop配置，管理和监控功能集成到自己的应用程序中。</li>
</ul>
<h1 id="Ambari的组件"><a href="#Ambari的组件" class="headerlink" title="Ambari的组件"></a>Ambari的组件</h1><p>Ambari的主要组成有三部分：</p>
<ul>
<li><strong>Ambari-Server</strong>：将集群的状态通过web UI 或RESTAPI的形式呈献给用户，并且通过这两种方式将用户指令下发到集群中，从而实现用户与Hadoop集群的交互。<strong>hadoop集群节点上一般没有server。</strong>（不知道为啥）</li>
<li><strong>Ambari-Agent</strong>：负责对集群内主机状态的采集以及执行Server发来的指令，并且将执行结果发送给<strong>Server</strong>。</li>
<li><strong>Ambari-Metrics</strong>：负责监控集群状态的功能组件。会搜集一下两种数据指标：<ul>
<li>个节点“系统级”的指标</li>
<li>Hadoop各组件的指标</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-fa754b5349e1948bba38d124854af6e0_b.jpg" alt="img"></p>
<p><strong>心跳机制：</strong></p>
<p>Ambari-Server与Ambari-Agent之间的交互是通过<strong>agent定期发送post请求</strong>，上报Ambari-agent所在主机的状态；Ambari-Server<strong>接收到Agent发送来的状态之后，给Ambari-Agent返回需要在此主机上执行的指令</strong>。这样一次完整的指令就像是一次心跳一样 ，通过心跳完成主从交互的机制就是心跳机制。</p>
<p><strong>用户和数据集群中间的交互：</strong></p>
<p>1）在server安装、配置完成并启动后；</p>
<p>2）用户通过浏览器访问server，在地址栏输入的url是由ambari-web（以后简称web）模块响应请求，web端又调用ambari-server 的REST api获取数据显示在浏览器页面上。</p>
<p>3）当用户想要通过浏览器操作集群（stop、start某些组件）时，由web端向ambari-server发送post或put请求，ambari-server 接收到请求后通过心跳机制，向ambari-agent(以后简称agent)发送指令，最后由agent执行shell或python脚本来完成。</p>
<p><strong>显示在浏览器上的数据来源：</strong></p>
<p>主要分为以下两种类型：</p>
<ul>
<li>集群内各服务的实时状态信息，这类数据是由AMS模块实时采集上报给Ambari-Metrics-Collector，再由Ambari-Server调用的Ambari-Metries-controller的REST API显示在页面上。这部分数据没有落地到ambari-server 的数据库中，在每次web端调用ambari-server的数据时，ambari-server都会调用ambari-metrics-collector获取数据，进行适当的加工处理后直接返回给web端 显示在浏览器页面上。</li>
<li>由ambari-server缓存在内存，持久化到数据库的数据，这类数据<strong>比如主机列表、服务列表、服务的配置信息等</strong>。这些数据是由agent采集通过心跳发送给ambari-server后，ambari-server更新自身的数据状态。当web端调用ambari-server的rest api获取这些数据时，ambari-server将web端请求的数据直接返回给web显示在浏览器页面。</li>
</ul>
<h1 id="Ambari用户权限"><a href="#Ambari用户权限" class="headerlink" title="Ambari用户权限"></a>Ambari用户权限</h1><p>1.服务级别权限</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211204111153463.png" alt="image-20211204111153463"></p>
<p>2.主机级权限</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211204111259671.png" alt="image-20211204111259671"></p>
<p>3.集群级权限</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211204111333306.png" alt="image-20211204111333306"></p>
<p>4.Ambari级权限</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211204111403313.png" alt="image-20211204111403313"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Ambari自定义服务</title>
    <url>/2021/12/30/Ambari%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>Ambari自定义服务。将我们需要的服务通过Ambari配置到镜像中，根据此镜像创建的实例中就会自动配置我们需要的服务。</p>
<span id="more"></span>

<h1 id="Ambari自定义服务"><a href="#Ambari自定义服务" class="headerlink" title="Ambari自定义服务"></a>Ambari自定义服务</h1><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#自定义服务的路径：</span><br><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/3.1/</span>services<br></code></pre></td></tr></table></figure>

<p>以REDIS为例：</p>
<p> <strong>metainfo.xml</strong>： 一个服务文件描述了服务，服务的组件和管理脚本，核心配置文件。服务的组件可以是 MASTER、 SLAVE 或 CLIENT 类别。<category> 告诉 Ambari 应该使用哪些默认命令来管理和监视组件</p>
<p><strong>configurate</strong>：里面放置一个或多个 xml 文件，用于将该服务的配置信息展示在前端页面，也可以在ambari 页面上对服务的一些配置做更改，如下图所示：</p>
<p><strong>package</strong>：package 目录：里面包含 scripts 文件夹，该目录下存放着 python 文件，用于对服务的安装、配置、启动、停止等操作。自定义服务 python 脚本依赖的模块是 resource_management 。该模块分布在不同的目录下，但内容是一致的。</p>
<p><strong>quicklinks.json</strong> ：用于生成快速链接，实现 url 的跳转。可支持多个 url 展示。</p>
<p><strong>role_command_order.json</strong> 文件：决定各个服务组件之间的启动顺序。</p>
<p><strong>alert.json</strong>：描述 ambari 对服务的 告警 设置。告警类型有 WEB、Port、Metric、Aggregate 和 Script 。</p>
<img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211224101849765.png" alt="image-20211224101849765" style="zoom:150%;" />



<h1 id="创建和添加服务"><a href="#创建和添加服务" class="headerlink" title="创建和添加服务"></a>创建和添加服务</h1><p>1.在 Ambari 服务器上，浏览到 <code>/var/lib/ambari-server/resources/stacks/HDP/3.1/services</code> 目录。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/3.1/</span>services<br></code></pre></td></tr></table></figure>

<p>2.创建一个名为的目录 ，该目录 将包含<strong>SAMPLESRV</strong>的服务定义 </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/2.0.6/</span>services/SAMPLESRV<br>cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/2.0.6/</span>services/SAMPLESRV<br></code></pre></td></tr></table></figure>

<p>3.浏览到新创建的 <code>SAMPLESRV</code> 目录，创建一个<code>metainfo.xml</code> 描述新服务的 文件。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">metainfo</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">schemaVersion</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">schemaVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">services</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>SAMPLESRV<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>New Sample Service<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>A New Sample Service<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">components</span>&gt;</span><br>                <br>                <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>SAMPLESRV_MASTER<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Sample Srv Master<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">category</span>&gt;</span>MASTER<span class="hljs-tag">&lt;/<span class="hljs-name">category</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">cardinality</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">cardinality</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">commandScript</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>scripts/master.py<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">scriptType</span>&gt;</span>PYTHON<span class="hljs-tag">&lt;/<span class="hljs-name">scriptType</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">timeout</span>&gt;</span>600<span class="hljs-tag">&lt;/<span class="hljs-name">timeout</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">commandScript</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>                <br>                <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>SAMPLESRV_SLAVE<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Sample Srv Slave<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">category</span>&gt;</span>SLAVE<span class="hljs-tag">&lt;/<span class="hljs-name">category</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">cardinality</span>&gt;</span>1+<span class="hljs-tag">&lt;/<span class="hljs-name">cardinality</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">commandScript</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>scripts/slave.py<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">scriptType</span>&gt;</span>PYTHON<span class="hljs-tag">&lt;/<span class="hljs-name">scriptType</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">timeout</span>&gt;</span>600<span class="hljs-tag">&lt;/<span class="hljs-name">timeout</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">commandScript</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>                <br>                <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>SAMPLESRV_CLIENT<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Sample Srv Client<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">category</span>&gt;</span>CLIENT<span class="hljs-tag">&lt;/<span class="hljs-name">category</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">cardinality</span>&gt;</span>1+<span class="hljs-tag">&lt;/<span class="hljs-name">cardinality</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">commandScript</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>scripts/sample_client.py<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">scriptType</span>&gt;</span>PYTHON<span class="hljs-tag">&lt;/<span class="hljs-name">scriptType</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">timeout</span>&gt;</span>600<span class="hljs-tag">&lt;/<span class="hljs-name">timeout</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">commandScript</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>                <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">components</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">osSpecifics</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">osSpecific</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">osFamily</span>&gt;</span>any<span class="hljs-tag">&lt;/<span class="hljs-name">osFamily</span>&gt;</span>  <span class="hljs-comment">&lt;!-- <span class="hljs-doctag">note:</span> use osType rather than osFamily for Ambari 1.5.0 and 1.5.1 --&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">osSpecific</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">osSpecifics</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">services</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">metainfo</span>&gt;</span><br></code></pre></td></tr></table></figure>



<ol start="4">
<li>SAMPLESRV</li>
</ol>
<p> 它包含：</p>
<ul>
<li>一个 <strong>MASTER</strong> 组件“ <strong>SAMPLESRV_MASTER</strong> ”</li>
<li>一个 <strong>SLAVE</strong> 组件“ <strong>SAMPLESRV_SLAVE</strong> ”</li>
<li>一个 <strong>CLIENT</strong> 组件“ <strong>SAMPLESRV_CLIENT</strong> ”</li>
</ul>
<p>5.接下来，让我们创建该命令脚本。为/var/lib/ambari-server/resources/stacks/HDP/2.0.6/services/SAMPLESRV/package/scripts我们在服务元信息中指定的命令脚本创建一个目录  </p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">mkdir -p <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/2.0.6/</span>services<span class="hljs-regexp">/SAMPLESRV/</span><span class="hljs-keyword">package</span>/scripts<br>cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/2.0.6/</span>services<span class="hljs-regexp">/SAMPLESRV/</span><span class="hljs-keyword">package</span>/scripts<br></code></pre></td></tr></table></figure>



<p>6.浏览到脚本目录并创建 <code>.py</code> 命令脚本文件。</p>
<p>例如 <code>master.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> resource_management <span class="hljs-keyword">import</span> *<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Master</span>(<span class="hljs-params">Script</span>):</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Install the Sample Srv Master&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Stop the Sample Srv Master&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Start the Sample Srv Master&#x27;</span>;<br>     <br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">status</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Status of the Sample Srv Master&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">configure</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Configure the Sample Srv Master&#x27;</span>;<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>  Master().execute()<br></code></pre></td></tr></table></figure>

<p>slave.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> resource_management <span class="hljs-keyword">import</span> *<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Slave</span>(<span class="hljs-params">Script</span>):</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Install the Sample Srv Slave&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Stop the Sample Srv Slave&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Start the Sample Srv Slave&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">status</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Status of the Sample Srv Slave&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">configure</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Configure the Sample Srv Slave&#x27;</span>;<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>  Slave().execute()<br></code></pre></td></tr></table></figure>

<p>client.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> resource_management <span class="hljs-keyword">import</span> *<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClient</span>(<span class="hljs-params">Script</span>):</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Install the Sample Srv Client&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">configure</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Configure the Sample Srv Client&#x27;</span>;<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>  SampleClient().execute()<br></code></pre></td></tr></table></figure>

<p>7.现在，重新启动 Ambari 服务器，以便将此新服务定义分发到集群中的所有代理。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">ambari-<span class="hljs-keyword">server</span> <span class="hljs-keyword">restart</span><br></code></pre></td></tr></table></figure>



<h1 id="自定义KAFKA服务"><a href="#自定义KAFKA服务" class="headerlink" title="自定义KAFKA服务"></a>自定义KAFKA服务</h1><h2 id="1-创建目录"><a href="#1-创建目录" class="headerlink" title="1.创建目录"></a>1.创建目录</h2><p>到目标目录下/var/lib/ambari-server/resources/stacks/HDP/3.1/services。创建KAFKA文件夹</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">mkdir /var/lib/ambari-server/resources/stacks/HDP/2.0.6/services/KAFKA<br>cd /var/lib/ambari-server/resources/stacks/HDP/2.0.6/services/KAFKA<br></code></pre></td></tr></table></figure>

<h2 id="2-Metainfo-xml"><a href="#2-Metainfo-xml" class="headerlink" title="2.Metainfo.xml"></a>2.Metainfo.xml</h2><p>创建Metainfo.xml文件，描述服务，服务的组件和管理脚本，核心配置文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="hljs-comment">   contributor license agreements.  See the NOTICE file distributed with</span><br><span class="hljs-comment">   this work for additional information regarding copyright ownership.</span><br><span class="hljs-comment">   The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="hljs-comment">   (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="hljs-comment">   the License.  You may obtain a copy of the License at</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">   See the License for the specific language governing permissions and</span><br><span class="hljs-comment">   limitations under the License.</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">metainfo</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">schemaVersion</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">schemaVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">services</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>			<span class="hljs-comment">&lt;!--kafka 的配置信息--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>KAFKA<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Kafka<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>A high-throughput distributed messaging system<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">components</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><br>			<span class="hljs-comment">&lt;!--kafka组件配置信息，Broker是kafka的实例，每台服务器上都有一台或者多态服务器--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>KAFKA_BROKER<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Kafka Broker<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span><br>					<span class="hljs-comment">&lt;!--种类是master--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">category</span>&gt;</span>MASTER<span class="hljs-tag">&lt;/<span class="hljs-name">category</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">cardinality</span>&gt;</span>1+<span class="hljs-tag">&lt;/<span class="hljs-name">cardinality</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">versionAdvertised</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">versionAdvertised</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">rollingRestartSupported</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">rollingRestartSupported</span>&gt;</span><br>					<span class="hljs-comment">&lt;!--ZOOKEEPER依赖--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ZOOKEEPER/ZOOKEEPER_SERVER<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>cluster<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">auto-deploy</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">auto-deploy</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>					<span class="hljs-comment">&lt;!--命令脚本，所在的位置是scripts/kafka_broker.py--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">commandScript</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>scripts/kafka_broker.py<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">scriptType</span>&gt;</span>PYTHON<span class="hljs-tag">&lt;/<span class="hljs-name">scriptType</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">timeout</span>&gt;</span>1200<span class="hljs-tag">&lt;/<span class="hljs-name">timeout</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">commandScript</span>&gt;</span><br>					<span class="hljs-comment">&lt;!--监控，日志？--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">logs</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">log</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">logId</span>&gt;</span>kafka_server<span class="hljs-tag">&lt;/<span class="hljs-name">logId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">primary</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">primary</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">log</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">logId</span>&gt;</span>kafka_controller<span class="hljs-tag">&lt;/<span class="hljs-name">logId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">log</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">logId</span>&gt;</span>kafka_request<span class="hljs-tag">&lt;/<span class="hljs-name">logId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">log</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">logId</span>&gt;</span>kafka_logcleaner<span class="hljs-tag">&lt;/<span class="hljs-name">logId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">log</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">logId</span>&gt;</span>kafka_statechange<span class="hljs-tag">&lt;/<span class="hljs-name">logId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">logs</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>KAFKA_MANAGER<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Kafka Manager<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">category</span>&gt;</span>MASTER<span class="hljs-tag">&lt;/<span class="hljs-name">category</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">cardinality</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">cardinality</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">versionAdvertised</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">versionAdvertised</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">rollingRestartSupported</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">rollingRestartSupported</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ZOOKEEPER/ZOOKEEPER_SERVER<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>cluster<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">auto-deploy</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">auto-deploy</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">commandScript</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>scripts/kafka_manager.py<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">scriptType</span>&gt;</span>PYTHON<span class="hljs-tag">&lt;/<span class="hljs-name">scriptType</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">timeout</span>&gt;</span>1200<span class="hljs-tag">&lt;/<span class="hljs-name">timeout</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">commandScript</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">components</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">commandScript</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>scripts/service_check.py<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scriptType</span>&gt;</span>PYTHON<span class="hljs-tag">&lt;/<span class="hljs-name">scriptType</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">timeout</span>&gt;</span>300<span class="hljs-tag">&lt;/<span class="hljs-name">timeout</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">commandScript</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">requiredServices</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span>ZOOKEEPER<span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">requiredServices</span>&gt;</span><br>			<span class="hljs-comment">&lt;!--设置依赖--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration-dependencies</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka-broker<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka-env<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka-log4j<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>ranger-kafka-plugin-properties<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>ranger-kafka-audit<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>ranger-kafka-policymgr-ssl<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>ranger-kafka-security<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>zookeeper-env<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>zoo.cfg<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka_jaas_conf<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka_client_jaas_conf<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration-dependencies</span>&gt;</span><br>			<span class="hljs-comment">&lt;!--操作系统的规格--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">osSpecifics</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">osSpecific</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">osFamily</span>&gt;</span>redhat7,amazonlinux2,redhat6,suse11,suse12<span class="hljs-tag">&lt;/<span class="hljs-name">osFamily</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">packages</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>kafka_$&#123;stack_version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">packages</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">osSpecific</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">osSpecific</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">osFamily</span>&gt;</span>debian7,debian9,ubuntu12,ubuntu14,ubuntu16,ubuntu18<span class="hljs-tag">&lt;/<span class="hljs-name">osFamily</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">packages</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>kafka-$&#123;stack_version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">packages</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">osSpecific</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">osSpecifics</span>&gt;</span><br>			<span class="hljs-comment">&lt;!--更改后需要重启--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">restartRequiredAfterChange</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">restartRequiredAfterChange</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">restartRequiredAfterRackChange</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">restartRequiredAfterRackChange</span>&gt;</span><br>			<span class="hljs-comment">&lt;!--主题设置--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">themes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">theme</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">fileName</span>&gt;</span>directories.json<span class="hljs-tag">&lt;/<span class="hljs-name">fileName</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">default</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">default</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">theme</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">themes</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--快速链接配置--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">quickLinksConfigurations</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">quickLinksConfiguration</span>&gt;</span>        <br>          <span class="hljs-tag">&lt;<span class="hljs-name">fileName</span>&gt;</span>quicklinks.json<span class="hljs-tag">&lt;/<span class="hljs-name">fileName</span>&gt;</span>     <br>          <span class="hljs-tag">&lt;<span class="hljs-name">default</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">default</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">quickLinksConfiguration</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">quickLinksConfigurations</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">services</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">metainfo</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h2 id="3-package包，服务的安装、配置、启动"><a href="#3-package包，服务的安装、配置、启动" class="headerlink" title="3.package包，服务的安装、配置、启动"></a>3.package包，服务的安装、配置、启动</h2><p>在KAFKA中包括了两个组件：KAFKA_BROKER和KAFKA_MANAGER。在目标目录/package/scripts下，对服务的安装、配置、启动、停止等操作。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/2.0.6/</span>services<span class="hljs-regexp">/KAFKA/</span><span class="hljs-keyword">package</span>/scripts<br></code></pre></td></tr></table></figure>



<p>KAFKA_BROKER配置信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaBroker</span>(<span class="hljs-params">Script</span>):</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install</span>(<span class="hljs-params">self, env</span>):</span><br>    self.install_packages(env)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">configure</span>(<span class="hljs-params">self, env, upgrade_type=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    env.set_params(params)<br>    kafka(upgrade_type=upgrade_type)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pre_upgrade_restart</span>(<span class="hljs-params">self, env, upgrade_type=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    env.set_params(params)<br><br>    <span class="hljs-keyword">if</span> params.version <span class="hljs-keyword">and</span> check_stack_feature(StackFeature.ROLLING_UPGRADE, params.version):<br>      stack_select.select_packages(params.version)<br><br>    <span class="hljs-comment"># This is extremely important since it should only be called if crossing the HDP 2.3.4.0 boundary.</span><br>    <span class="hljs-keyword">if</span> params.version <span class="hljs-keyword">and</span> params.upgrade_direction:<br>      src_version = dst_version = <span class="hljs-literal">None</span><br>      <span class="hljs-keyword">if</span> params.upgrade_direction == Direction.UPGRADE:<br>        src_version = upgrade_summary.get_source_version(<span class="hljs-string">&quot;KAFKA&quot;</span>, default_version =  params.version)<br>        dst_version = upgrade_summary.get_target_version(<span class="hljs-string">&quot;KAFKA&quot;</span>, default_version =  params.version)<br>      <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># These represent the original values during the UPGRADE direction</span><br>        src_version = upgrade_summary.get_target_version(<span class="hljs-string">&quot;KAFKA&quot;</span>, default_version =  params.version)<br>        dst_version = upgrade_summary.get_source_version(<span class="hljs-string">&quot;KAFKA&quot;</span>, default_version =  params.version)<br><br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_stack_feature(StackFeature.KAFKA_ACL_MIGRATION_SUPPORT, src_version) <span class="hljs-keyword">and</span> check_stack_feature(StackFeature.KAFKA_ACL_MIGRATION_SUPPORT, dst_version):<br>        <span class="hljs-comment"># Calling the acl migration script requires the configs to be present.</span><br>        self.configure(env, upgrade_type=upgrade_type)<br>        upgrade.run_migration(env, upgrade_type)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self, env, upgrade_type=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    env.set_params(params)<br>    self.configure(env, upgrade_type=upgrade_type)<br><br>    <span class="hljs-keyword">if</span> params.kerberos_security_enabled:<br>      <span class="hljs-keyword">if</span> params.version <span class="hljs-keyword">and</span> check_stack_feature(StackFeature.KAFKA_KERBEROS, params.version):<br>        kafka_kinit_cmd = <span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;&#123;kinit_path_local&#125; -kt &#123;kafka_keytab_path&#125; &#123;kafka_jaas_principal&#125;;&quot;</span>)<br>        Execute(kafka_kinit_cmd, user=params.kafka_user)<br><br>    <span class="hljs-keyword">if</span> params.is_supported_kafka_ranger:<br>      setup_ranger_kafka() <span class="hljs-comment">#Ranger Kafka Plugin related call </span><br>    daemon_cmd = <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;source &#123;params.conf_dir&#125;/kafka-env.sh ; &#123;params.kafka_bin&#125; start&#x27;</span>)<br>    no_op_test = <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;ls &#123;params.kafka_pid_file&#125; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; ps -p `cat &#123;params.kafka_pid_file&#125;` &gt;/dev/null 2&gt;&amp;1&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>      Execute(daemon_cmd,<br>              user=params.kafka_user,<br>              not_if=no_op_test<br>      )<br>    <span class="hljs-keyword">except</span>:<br>      show_logs(params.kafka_log_dir, params.kafka_user)<br>      <span class="hljs-keyword">raise</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self, env, upgrade_type=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    env.set_params(params)<br>    <span class="hljs-comment"># Kafka package scripts change permissions on folders, so we have to</span><br>    <span class="hljs-comment"># restore permissions after installing repo version bits</span><br>    <span class="hljs-comment"># before attempting to stop Kafka Broker</span><br>    ensure_base_directories()<br>    daemon_cmd = <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;source &#123;params.conf_dir&#125;/kafka-env.sh; &#123;params.kafka_bin&#125; stop&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>      Execute(daemon_cmd,<br>              user=params.kafka_user,<br>      )<br>    <span class="hljs-keyword">except</span>:<br>      show_logs(params.kafka_log_dir, params.kafka_user)<br>      <span class="hljs-keyword">raise</span><br>    File(params.kafka_pid_file,<br>          action = <span class="hljs-string">&quot;delete&quot;</span><br>    )<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">disable_security</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> params.zookeeper_connect:<br>      Logger.info(<span class="hljs-string">&quot;No zookeeper connection string. Skipping reverting ACL&quot;</span>)<br>      <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> params.secure_acls:<br>      Logger.info(<span class="hljs-string">&quot;The zookeeper.set.acl is false. Skipping reverting ACL&quot;</span>)<br>      <span class="hljs-keyword">return</span><br>    Execute(<br>      <span class="hljs-string">&quot;&#123;0&#125; --zookeeper.connect &#123;1&#125; --zookeeper.acl=unsecure&quot;</span>.<span class="hljs-built_in">format</span>(params.kafka_security_migrator, params.zookeeper_connect), \<br>      user=params.kafka_user, \<br>      environment=&#123; <span class="hljs-string">&#x27;JAVA_HOME&#x27;</span>: params.java64_home &#125;, \<br>      logoutput=<span class="hljs-literal">True</span>, \<br>      tries=<span class="hljs-number">3</span>)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">status</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-keyword">import</span> status_params<br>    env.set_params(status_params)<br>    check_process_status(status_params.kafka_pid_file)<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_log_folder</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    <span class="hljs-keyword">return</span> params.kafka_log_dir<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    <span class="hljs-keyword">return</span> params.kafka_user<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pid_files</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">import</span> status_params<br>    <span class="hljs-keyword">return</span> [status_params.kafka_pid_file]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>  KafkaBroker().execute()<br><br></code></pre></td></tr></table></figure>

<p>KAFKA_MANAGER配置信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaManager</span>(<span class="hljs-params">Script</span>):</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install</span>(<span class="hljs-params">self, env</span>):</span><br>    self.install_packages(env)<br><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">configure</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    env.set_params(params)<br>    conf_dir = <span class="hljs-string">&quot;&#123;0&#125;/conf&quot;</span>.<span class="hljs-built_in">format</span>(params.manager_dir)<br>    manager_config_file = <span class="hljs-string">&quot;&#123;0&#125;/application.conf&quot;</span>.<span class="hljs-built_in">format</span>(conf_dir)<br>    File(manager_config_file,<br>             mode=0744,<br>             owner = <span class="hljs-string">&quot;root&quot;</span>,<br>             group = <span class="hljs-string">&quot;root&quot;</span>,<br>             content = Template(<span class="hljs-string">&quot;application.conf.j2&quot;</span>)<br>             ) <br><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    <span class="hljs-keyword">import</span> status_params<br>    env.set_params(params)<br>    env.set_params(status_params)<br>    self.configure(env)<br>    <span class="hljs-keyword">if</span> os.path.exists(status_params.manager_pid_file):<br>          File(status_params.manager_pid_file,<br>                  action=<span class="hljs-string">&quot;delete&quot;</span>,<br>                  owner=<span class="hljs-string">&quot;root&quot;</span>)<br>    start_cmd = <span class="hljs-string">&quot;nohup &#123;0&#125;/bin/kafka-manager -Dhttp.port=&#123;1&#125; &amp;&quot;</span>.<span class="hljs-built_in">format</span>(params.manager_dir,params.manager_port)<br>    Execute(start_cmd)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-keyword">import</span> params<br>    <span class="hljs-keyword">import</span> status_params<br>    env.set_params(params)<br>    env.set_params(status_params)<br> <br>    stop_cmd = <span class="hljs-string">&quot;kill -9 `cat &#123;0&#125;`&quot;</span>.<span class="hljs-built_in">format</span>(status_params.manager_pid_file)<br>    Execute(stop_cmd)<br><br>    <span class="hljs-keyword">if</span> os.path.exists(status_params.manager_pid_file):<br>        File(status_params.manager_pid_file,<br>                      action=<span class="hljs-string">&quot;delete&quot;</span>,<br>                      owner=<span class="hljs-string">&quot;root&quot;</span>)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">status</span>(<span class="hljs-params">self, env</span>):</span><br>    <span class="hljs-keyword">import</span> status_params<br>    env.set_params(status_params)<br>    check_process_status(status_params.manager_pid_file)<br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>  KafkaManager().execute()<br><br></code></pre></td></tr></table></figure>

<h2 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4.配置文件"></a>4.配置文件</h2><p>configuration包下。</p>
<p>用于将该服务的配置信息展示在前端页面。</p>
<p>依赖的配置文件放在configuration文件下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置依赖--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration-dependencies</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka-broker<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka-env<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka-log4j<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>ranger-kafka-plugin-properties<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>ranger-kafka-audit<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>ranger-kafka-policymgr-ssl<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>ranger-kafka-security<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>zookeeper-env<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>zoo.cfg<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka_jaas_conf<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">config-type</span>&gt;</span>kafka_client_jaas_conf<span class="hljs-tag">&lt;/<span class="hljs-name">config-type</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration-dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211230102024600.png" alt="image-20211230102024600"></p>
<h2 id="5-quicklinks-json"><a href="#5-quicklinks-json" class="headerlink" title="5.quicklinks.json"></a>5.quicklinks.json</h2><p>quicklinks文件夹下。</p>
<p><strong>quicklinks.json</strong> ：用于生成快速链接，实现 url 的跳转。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>,<br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;default quick links configuration&quot;</span>,<br>  <span class="hljs-attr">&quot;configuration&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;protocol&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;http&quot;</span>,<br>      <span class="hljs-attr">&quot;checks&quot;</span>:[<br>      ]<br>    &#125;,<br>    <span class="hljs-attr">&quot;links&quot;</span>: [<br>      &#123;<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;manager_ui&quot;</span>,<br>        <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;MANAGER UI&quot;</span>,<br>        <span class="hljs-attr">&quot;component_name&quot;</span>: <span class="hljs-string">&quot;KAFKA_MANAGER&quot;</span>,<br>        <span class="hljs-attr">&quot;requires_user_name&quot;</span>: <span class="hljs-string">&quot;false&quot;</span>,<br>        <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;%@://%@:%@&quot;</span>,<br>        <span class="hljs-attr">&quot;port&quot;</span>:&#123;<br>          <span class="hljs-attr">&quot;http_property&quot;</span>: <span class="hljs-string">&quot;manager_port&quot;</span>,<br>          <span class="hljs-attr">&quot;http_default_port&quot;</span>: <span class="hljs-string">&quot;9000&quot;</span>,<br>          <span class="hljs-attr">&quot;https_property&quot;</span>: <span class="hljs-string">&quot;manager_port&quot;</span>,<br>          <span class="hljs-attr">&quot;https_default_port&quot;</span>: <span class="hljs-string">&quot;9000&quot;</span>,<br>          <span class="hljs-attr">&quot;regex&quot;</span>: <span class="hljs-string">&quot;^(\\d+)$&quot;</span>,<br>          <span class="hljs-attr">&quot;site&quot;</span>: <span class="hljs-string">&quot;manager_env&quot;</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-role-command-order-json"><a href="#6-role-command-order-json" class="headerlink" title="6.role_command_order.json"></a>6.role_command_order.json</h2><p><strong>role_command_order.json</strong> 文件：决定各个服务组件之间的启动顺序。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;general_deps&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;_comment&quot;</span> : <span class="hljs-string">&quot;dependencies for KAFKA&quot;</span>,<br>    <span class="hljs-attr">&quot;KAFKA_BROKER-START&quot;</span> : [<span class="hljs-string">&quot;ZOOKEEPER_SERVER-START&quot;</span>, <span class="hljs-string">&quot;RANGER_USERSYNC-START&quot;</span>, <span class="hljs-string">&quot;NAMENODE-START&quot;</span>],<br>    <span class="hljs-attr">&quot;KAFKA_SERVICE_CHECK-SERVICE_CHECK&quot;</span>: [<span class="hljs-string">&quot;KAFKA_BROKER-START&quot;</span>,<span class="hljs-string">&quot;KAFKA_MANAGER-START&quot;</span>]<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="7-alerts-json告警设置"><a href="#7-alerts-json告警设置" class="headerlink" title="7.alerts.json告警设置"></a>7.alerts.json告警设置</h2><p>描述 ambari 对服务的 告警 设置。告警类型有 WEB、Port、Metric、Aggregate 和 Script 。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;KAFKA&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;service&quot;</span>: [],<br>    <span class="hljs-attr">&quot;KAFKA_BROKER&quot;</span>: [<br>      &#123;<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;kafka_broker_process&quot;</span>,<br>        <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Kafka Broker Process&quot;</span>,<br>        <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;This host-level alert is triggered if the Kafka Broker cannot be determined to be up.&quot;</span>,<br>        <span class="hljs-attr">&quot;interval&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">&quot;scope&quot;</span>: <span class="hljs-string">&quot;HOST&quot;</span>,<br>        <span class="hljs-attr">&quot;source&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;PORT&quot;</span>,<br>          <span class="hljs-attr">&quot;uri&quot;</span>: <span class="hljs-string">&quot;&#123;&#123;kafka-broker/listeners&#125;&#125;&quot;</span>,<br>          <span class="hljs-attr">&quot;default_port&quot;</span>: <span class="hljs-number">6667</span>,<br>          <span class="hljs-attr">&quot;reporting&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;ok&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;TCP OK - &#123;0:.3f&#125;s response on port &#123;1&#125;&quot;</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;warning&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;TCP OK - &#123;0:.3f&#125;s response on port &#123;1&#125;&quot;</span>,<br>              <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-number">1.5</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;critical&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;Connection failed: &#123;0&#125; to &#123;1&#125;:&#123;2&#125;&quot;</span>,<br>              <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-number">5.0</span><br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>镜像制作</category>
      </categories>
      <tags>
        <tag>自定义服务</tag>
      </tags>
  </entry>
  <entry>
    <title>CloudBreak</title>
    <url>/2021/12/03/CloudBreak/</url>
    <content><![CDATA[<p>Cloudbreak 允许<strong>在云平台（私有云、公有云都可）上创建、管理和监控 HDP 和 HDF 集群</strong>。</p>
<span id="more"></span>

<h1 id="CloudBreak"><a href="#CloudBreak" class="headerlink" title="CloudBreak"></a>CloudBreak</h1><h1 id="1-核心概念简介"><a href="#1-核心概念简介" class="headerlink" title="1.核心概念简介"></a>1.核心概念简介</h1><p>Cloudbreak 允许<strong>在云平台上创建、管理和监控 HDP 和 HDF 集群</strong>：</p>
<ul>
<li>在公共云和私有云（AWS、Azure、谷歌云、OpenStack）上动态部署、配置和管理集群。</li>
<li>随着集群工作负载的变化，使用自动扩展无缝管理弹性需求。</li>
<li>通过启用 Kerberos 保护您的集群。</li>
</ul>
<p>Cloudbreak支持通过Cloudbreak web UI、Cloudbreak CLI和Cloudbreak REST API创建集群。集群可以在公共云基础设施平台Microsoft Azure、Amazon Web Services (AWS)和谷歌云平台(GCP)上发布，也可以在私有云基础设施平台上发布</p>
<h2 id="1-1Ambari"><a href="#1-1Ambari" class="headerlink" title="1.1Ambari"></a>1.1Ambari</h2><p>Apache Ambari是一种基于Web的工具，支持Apache Hadoop集群的供应、管理和监控。</p>
<p>Apache Ambari 支持HDFS、MapReduce、Hive、Pig、Hbase、Zookeepr、Sqoop和Hcatalog等的集中管理。</p>
<h2 id="1-2-Clusters-数据集群"><a href="#1-2-Clusters-数据集群" class="headerlink" title="1.2 Clusters (数据集群)"></a>1.2 Clusters (数据集群)</h2><p><em>数据库集群</em>，就是利用至少两台或者多台数据库服务器，构成一个虚拟单一数据库逻辑映像，像单数据库系统那样，向客户端提供透明的数据服务。</p>
<h2 id="1-3-blueprints（蓝图）"><a href="#1-3-blueprints（蓝图）" class="headerlink" title="1.3 blueprints（蓝图）"></a>1.3 blueprints（蓝图）</h2><ul>
<li>blueprints是集群的声明性定义。</li>
<li>允许定义堆栈、组件布局和配置的集群实例。</li>
<li>启动集群时将 JSON 中的主机组映射到一组实例，并在相应的节点上安装指定的服务和组件。</li>
</ul>
<p><strong>Ambari 蓝图是集群的声明性定义</strong>。蓝图<strong>允许您指定堆栈、组件布局和配置以通过 Ambari REST API 实现集群实例</strong>，而无需使用 Ambari 集群安装向导。</p>
<p>Ambari 蓝图以 <strong>JSON 格式</strong>指定。将蓝图提供给 Cloudbreak 后，<strong>启动集群时将 JSON 中的主机组映射到一组实例，并在相应的节点上安装指定的服务和组件</strong>。</p>
<p>Cloudbreak 包含一些默认蓝图，并允许您上传自己的蓝图。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/cb_arch-blue.png" alt="img"></p>
<h2 id="1-4-Credential（凭证）"><a href="#1-4-Credential（凭证）" class="headerlink" title="1.4 Credential（凭证）"></a>1.4 Credential（凭证）</h2><p>启动 Cloudbreak 后，必须为要在其上配置集群的每个云提供商创建一个 Cloudbreak 凭证。只有在完成该步骤后，您才能开始创建集群。</p>
<p>Cloudbreak 凭证<strong>允许 Cloudbreak 向云提供商进行身份验证并代表您创建资源</strong>。身份验证过程因云提供商而异，但通常通过向 Cloudbreak 分配特定 IAM 角色来完成，这允许 Cloudbreak 在您的云提供商帐户中执行某些操作。</p>
<h2 id="1-5Data-lake（数据湖）"><a href="#1-5Data-lake（数据湖）" class="headerlink" title="1.5Data lake（数据湖）"></a>1.5Data lake（数据湖）</h2><p>为当前和未来的临时工作负载提供一致的可用安全策略定义。所有与schema (Hive)、security policy (Ranger)、audit (Ranger)相关的信息都存储在外部位置(外部数据库、云存储)。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/cb_datalake-diag01.png" alt="img"></p>
<p>创建数据湖实例后，可以选择将其附加到一个或多个临时集群。这允许您跨多个工作负载集群应用身份验证、授权和审计。</p>
<ul>
<li>工作负载集群（Workload clusters）</li>
</ul>
<p>连接到数据湖以运行工作负载的集群。这是通过JDBC运行Hive等工作负载的地方。</p>
<p>数据湖的组成：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/cb_datalake-diag02.png" alt="img"></p>
<ul>
<li>Schema：实现技术<ul>
<li>Apache Hive。数据仓库，提供Hive模式(表、视图等)。</li>
<li>如果有两个或多个工作负载访问相同的Hive数据，则需要在这些工作负载之间共享模式。</li>
</ul>
</li>
<li>Policy：安全政策<ul>
<li>Apache Ranger</li>
<li>定义围绕Hive模式的安全策略。如果有两个或多个用户访问相同的数据，则需要始终可用并实施安全策略。</li>
</ul>
</li>
<li>Audit：<ul>
<li>Apache Range</li>
<li>审计用户访问并捕获工作负载的数据访问活动。</li>
</ul>
</li>
<li>Directory<ul>
<li>LDAP/AD</li>
<li>为用户提供身份验证源，并定义用于授权的组。</li>
</ul>
</li>
<li>GateWay：<ul>
<li>Apache Knox</li>
<li>支持单个工作负载端点，可以使用SSL保护该端点，并启用身份验证以访问资源。</li>
</ul>
</li>
</ul>
<h2 id="1-6Dynamic-blueprints（动态蓝湖）"><a href="#1-6Dynamic-blueprints（动态蓝湖）" class="headerlink" title="1.6Dynamic blueprints（动态蓝湖）"></a>1.6Dynamic blueprints（动态蓝湖）</h2><p>在蓝图之外管理外部资源，简化了蓝图。</p>
<p>生产集群配置通常包括某些配置参数，例如与外部数据库（用于 Hive、Ranger 等）和 LDAP/AD 相关的配置参数，迫使用户创建相同蓝图的 1+ 版本来处理这些外部系统的不同组件配置。</p>
<p>动态蓝图提供了在蓝图之外管理外部源（例如 RDBMS 和 LDAP/AD）的能力，因为它们仅使用蓝图作为模板，而 Cloudbreak 将实际配置注入到您的蓝图中。这简化了外部源（RDBMS 和 LDAP/AD）集群配置的重用，并简化了蓝图本身。</p>
<h2 id="1-7-外部资源"><a href="#1-7-外部资源" class="headerlink" title="1.7 外部资源"></a>1.7 外部资源</h2><p>Cloudbreak <strong>允许定义独立于集群创建的外部源</strong>——因此它们的生命周期不受任何集群的生命周期的限制——并且可以与多个集群重用：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/cb_external-source.png" alt="img"></p>
<p>可以在 Cloudbreak 中注册的外部源包括：</p>
<ul>
<li>身份验证配置（LDAP/AD）</li>
<li>数据库配置</li>
<li>图片目录</li>
<li>代理配置</li>
</ul>
<p>注册外部源后，您可以将其重用于多个集群。</p>
<h2 id="1-8-Recipes"><a href="#1-8-Recipes" class="headerlink" title="1.8 Recipes"></a>1.8 Recipes</h2><p>Cloudbreak 允许您上传自定义脚本，称为“Recipes”。Recipes是在特定时间在选定节点组的所有节点上运行的脚本。您可以将配方用于安装其他软件或执行高级集群配置等任务。</p>
<p>执行时间为：</p>
<ul>
<li>Ambari 服务器启动前</li>
<li>Ambari 服务器启动后</li>
<li>集群安装后</li>
<li>集群终止前</li>
</ul>
<p>可以通过 UI 或 CLI将recipes上传到cloudbreak中，创建集群时，可以创建多个recipes，他们将在特定时间，特定主机组上执行。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据库连接：JDBC</title>
    <url>/2021/10/15/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%EF%BC%9AJDBC/</url>
    <content><![CDATA[<p>Java数据库连接，（Java Database Connectivity，简称JDBC）是<a href="https://baike.baidu.com/item/Java%E8%AF%AD%E8%A8%80">Java语言</a>中用来规范客户端程序如何来访问数据库的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/10418844">应用程序接口</a>，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的。</p>
<span id="more"></span>

<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210602153446084.png" alt="image-20210602153446084"></p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210602153529380.png" alt="image-20210602153529380"></p>
<h1 id="1-JDBC入门"><a href="#1-JDBC入门" class="headerlink" title="1.JDBC入门"></a>1.JDBC入门</h1><p>什么是JDBC:</p>
<ul>
<li>java数据库连接，</li>
<li>让java通过程序连接关系型数据库，</li>
<li>JDBC基于驱动程序实现与数据库的连接和操作</li>
</ul>
<p>JDBC驱动程序</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210602155933307.png" alt="image-20210602155933307"></p>
<p>JDBC提出了一个标准，相应的数据库程序提供实现。</p>
<p>优点：</p>
<ul>
<li>统一的API，提供一致的开发过程。</li>
<li>易于上手，容易上手，代码结构稳定</li>
<li>功能强大，执行效率高，可以处理海量数据。</li>
</ul>
<h1 id="2-JDBC开发流程"><a href="#2-JDBC开发流程" class="headerlink" title="2.JDBC开发流程"></a>2.JDBC开发流程</h1><p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210602160414913.png" alt="image-20210602160414913"></p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210602173544564.png" alt="image-20210602173544564"></p>
<h1 id="3-JDBC代码实现"><a href="#3-JDBC代码实现" class="headerlink" title="3.JDBC代码实现"></a>3.JDBC代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        Statement stmt = <span class="hljs-keyword">null</span>;<br>        ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.加载注册驱动</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>            <span class="hljs-comment">// 2.创建数据库连接</span><br>            String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:3307/db_cy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimerzone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;</span>;<br>            conn = DriverManager.getConnection(url,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-comment">// 3.创建Statement对象</span><br>            stmt = conn.createStatement();<br>            <span class="hljs-comment">// 结果集</span><br>            rs = stmt.executeQuery(<span class="hljs-string">&quot;select * from counterdetail&quot;</span>);<br>            <span class="hljs-comment">// 4.遍历查询结果</span><br>            <span class="hljs-keyword">while</span> (rs.next())&#123;<br>                Integer id = rs.getInt(<span class="hljs-number">1</span>);         <span class="hljs-comment">// JDBC中字段的索引是从1开始的，不是0</span><br>                Integer ccounterid = rs.getInt(<span class="hljs-number">2</span>);<br>                String cfoodname = rs.getString(<span class="hljs-number">3</span>);<br>                String cnumber = rs.getString(<span class="hljs-number">4</span>);<br>                Integer cprive = rs.getInt(<span class="hljs-number">5</span>);<br>                System.out.println(id+<span class="hljs-string">&quot;-&quot;</span>+ccounterid+<span class="hljs-string">&quot;-&quot;</span>+cfoodname+<span class="hljs-string">&quot;-&quot;</span>+cnumber+<span class="hljs-string">&quot;-&quot;</span>+cprive);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 5.关闭连接，释放资源</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (rs!=<span class="hljs-keyword">null</span>)&#123;<br>                    rs.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (conn!=<span class="hljs-keyword">null</span>)&#123;<br>                    conn.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(stmt!=<span class="hljs-keyword">null</span>&amp;&amp;!conn.isClosed())&#123;<br>                    stmt.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br><br><br>        &#125;<br></code></pre></td></tr></table></figure>

<h1 id="4-JDBC的两种事务模型"><a href="#4-JDBC的两种事务模型" class="headerlink" title="4.JDBC的两种事务模型"></a>4.JDBC的两种事务模型</h1><ul>
<li><p>自动提交事务模式：默认模式，没执行一次写操作SQL，自动提交事务。</p>
<p>conn.setAutoCommit(true)。无法保证数据一致性。</p>
</li>
</ul>
<ul>
<li>手动提交事务模式：</li>
</ul>
<p>显示调用commit()he rollback()</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210607210239674.png" alt="image-20210607210239674"></p>
<h1 id="5-Date日期对象处理"><a href="#5-Date日期对象处理" class="headerlink" title="5.Date日期对象处理"></a>5.Date日期对象处理</h1><p>JDBC 中获取到的日期使用java.sql.Date，其继承自java.util.Date。所以二者可以兼容</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210608105317030.png" alt="image-20210608105317030"></p>
<h1 id="6-连接池和JDBC"><a href="#6-连接池和JDBC" class="headerlink" title="6.连接池和JDBC"></a>6.连接池和JDBC</h1><p>什么是连接池？</p>
<p>数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标.数据库连接池正式针对这个问题提出来的.数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/20190214093729228.png" alt="img"></p>
<p>连接池产品：</p>
<p>阿里巴巴Druid连接池</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210608111547280.png" alt="image-20210608111547280"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">driverClassName = com.mysql.cj.jdbc.Driver<br>url = jdbc:mysql:<span class="hljs-comment">//localhost:3307/db_cy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT&amp;allowPublicKeyRetrieval=true</span><br>username = root<br>password = <span class="hljs-number">123456</span><br>initialSize = <span class="hljs-number">20</span><br>maxActive = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>

<p>把initialSize和maxActive设置为相等，目的就是一开始就给系统分配好资源，避免出现重新分配资源的情况。</p>
<p>c3p0连接池：</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20210608151633616.png" alt="image-20210608151633616"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2021/10/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>记录工作学习中遇到的Linux命令。</p>
<span id="more"></span>

<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="字符串相关操作"><a href="#字符串相关操作" class="headerlink" title="字符串相关操作"></a>字符串相关操作</h2><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.<span class="hljs-keyword">grep</span>         字符串查找（过滤）              例如： glance image-<span class="hljs-keyword">list</span> | <span class="hljs-keyword">grep</span> redis<br><br><span class="hljs-number">2</span>.sed          字符串替换                          文件名 | sed <span class="hljs-string">&#x27;s/要被取代的字串/新的字串/g&#x27;</span><br><br><span class="hljs-number">3</span>.awk          字符串分割                          <br>每行按空格或TAB分割，输出文本中的<span class="hljs-number">1</span>、<span class="hljs-number">4</span>项    awk <span class="hljs-string">&#x27;&#123;print $1,$4&#125;&#x27;</span> test.txt<br><br><span class="hljs-number">4</span>.yum  提供查找、安装和删除软件<br>yum [<span class="hljs-keyword">options</span>] [<span class="hljs-keyword">command</span>] [package ...]         yum  操作  命令  安装的包名<br>http<span class="hljs-variable">s:</span>//www.runoob.<span class="hljs-keyword">com</span>/linux/linux-yum.html<br><br></code></pre></td></tr></table></figure>

<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.添加新的用户<br>useradd 选项 用户名<br><br><span class="hljs-number">2</span>.删除用户   -r把当前用户下的目录一起删除<br>userdel -r sam<br><br><span class="hljs-number">3</span>.修改用户<br>usermod 选项 用户名<br><br><span class="hljs-number">4</span>.修改密码<br>passwd 选项 用户名<br><br><span class="hljs-number">5</span>.查看test所在的用户组<br>groups test<br><br><span class="hljs-number">6</span>.创建用户组<br>groupadd group_name<br>删除<br>groupdel<br>修改<br>groupmod<br><br><span class="hljs-number">7</span>.查看用户登录日志<br>last<br><br><span class="hljs-number">8</span>.查看系统中的所有用户<br>cut -d: -f1 <span class="hljs-regexp">/etc/</span>passwd<br><br><span class="hljs-number">9</span>.查看系统所有的组<br>cut -d: -f1 <span class="hljs-regexp">/etc/g</span>roup<br></code></pre></td></tr></table></figure>



<h2 id="系统相关操作"><a href="#系统相关操作" class="headerlink" title="系统相关操作"></a>系统相关操作</h2><figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl"><span class="hljs-number">1.</span>查看Linux版本信息<br>cat /<span class="hljs-keyword">proc</span>/version<br><br>2.cpu信息<span class="hljs-title"></span><br><span class="hljs-title">cat</span> /<span class="hljs-keyword">proc</span>/cpuinfo<br><br>3.查看中断<span class="hljs-title"></span><br><span class="hljs-title">cat</span> /<span class="hljs-keyword">proc</span>/interrupts<br><br>4.查看负载<span class="hljs-title"></span><br><span class="hljs-title">cat</span> /<span class="hljs-keyword">proc</span>/loadavg<br><br>5.环境变量<span class="hljs-title"></span><br><span class="hljs-title">env</span><br><br>6.查看系统运⾏时间、⽤户数、负载<span class="hljs-title"></span><br><span class="hljs-title">uptime</span><br><br>7.查看内存容量、空闲内存量<span class="hljs-title"></span><br><span class="hljs-title">gerp</span> MenTotal /<span class="hljs-keyword">proc</span>/meninfo<span class="hljs-title"></span><br><span class="hljs-title">gerp</span> MenFree /<span class="hljs-keyword">proc</span>/meninfo<br><br>8.查看进程<span class="hljs-title"></span><br><span class="hljs-title">top</span><br></code></pre></td></tr></table></figure>

<h2 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h2><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">1.查看磁盘使用情况<br>df -<span class="hljs-keyword">h</span><br><br>2.查看某个目录的使用情况<br>du -<span class="hljs-keyword">sh</span> /<span class="hljs-keyword">dir</span><br><br>3.查看所有的磁盘分区<br>fdisk -<span class="hljs-keyword">l</span><br></code></pre></td></tr></table></figure>

<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span>查看所有进程<br>ps -ef<br><br><span class="hljs-number">2.</span>杀死进程<br>kill -s <span class="hljs-built_in">name</span>/<span class="hljs-built_in">id</span><br><br><span class="hljs-number">3.</span>实时查看进程状态<br>top<br></code></pre></td></tr></table></figure>

<h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>列出服务列表<br>chkconfig <span class="hljs-comment">--list</span><br><br><span class="hljs-number">2.</span>服务相关操作<br>service &lt;服务名&gt; &lt;操作&gt;<br>systemctl &lt;操作&gt; &lt;服务名&gt;<br><br>操作包括：<br>status ： 状态<br><span class="hljs-keyword">start</span>  ： 开启<br>stop   ： 关闭<br><span class="hljs-keyword">restart</span>： 重启<br><span class="hljs-keyword">enable</span> ： 开启自启动<br><span class="hljs-keyword">disable</span>： 关闭自启动<br></code></pre></td></tr></table></figure>

<h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.新建文件夹<br><span class="hljs-attribute">mkdir</span> fileName<br><br><span class="hljs-attribute">2</span>.删除文件名<br><span class="hljs-attribute">rm</span> -f fileName<br><br><span class="hljs-attribute">3</span>.目录操作<br><span class="hljs-attribute">mv</span>         重命名、移动文件夹<br><br><span class="hljs-attribute">cp</span>         复制文件<br><br><span class="hljs-attribute">find</span>       查找                     find / -name file<span class="hljs-number">1</span>    从根目录开始搜索文件<br><br><span class="hljs-attribute">cat</span>        文件查看<br><br><span class="hljs-attribute">vi</span>|vim     文件修改           i：插入模式      esc：退出到命令模式      ：wq   保存退出<br><br><span class="hljs-attribute">4</span>.查看文件前两行<br><span class="hljs-attribute">head</span> -<span class="hljs-number">2</span> filename       <br><br><span class="hljs-attribute">5</span>.查看文件后两行<br><span class="hljs-attribute">tail</span> -<span class="hljs-number">2</span> filename       <br><br><span class="hljs-attribute">6</span>.将hello.txt⽂件中的s<span class="hljs-number">1</span>替换成s<span class="hljs-number">2</span><br><span class="hljs-attribute">sed</span> &#x27;s/s<span class="hljs-number">1</span>/s<span class="hljs-number">2</span>/g&#x27; hello.txt<br><br><span class="hljs-attribute">7</span>.合并文件夹<br><span class="hljs-attribute">paste</span> file<span class="hljs-number">1</span> file<span class="hljs-number">2</span> <br><br><span class="hljs-attribute">8</span>.比较两个文件之间的内容<br><span class="hljs-attribute">comm</span> -<span class="hljs-number">1</span> file<span class="hljs-number">1</span> file<span class="hljs-number">2</span>      去除文件<span class="hljs-number">1</span>中的所有内容<br><span class="hljs-attribute">comm</span> -<span class="hljs-number">2</span> file<span class="hljs-number">1</span> file<span class="hljs-number">2</span>      去除文件<span class="hljs-number">2</span>中的所有内容<br><span class="hljs-attribute">comm</span> -<span class="hljs-number">3</span> file<span class="hljs-number">1</span> file<span class="hljs-number">2</span>      去除两个文件共有的部分<br></code></pre></td></tr></table></figure>



<h2 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h2><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">1.<span class="hljs-keyword">zip</span>打包，解压<br><span class="hljs-keyword">zip</span>  unzip<br><br>2.tar<br>tar -cvf xxx.tar <span class="hljs-keyword">file</span>     创建压缩文件<br>tar -xvf xxx.tar          解压<br></code></pre></td></tr></table></figure>



<h2 id="yum包管理"><a href="#yum包管理" class="headerlink" title="yum包管理"></a>yum包管理</h2><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211222110156561.png" style="zoom:150%;" />











]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack</title>
    <url>/2021/12/03/OpenStack/</url>
    <content><![CDATA[<p>OpenStack是一个IaaS的解决方案。使用Python开发的；OpenStack是一个云操作系统，通过数据中心可控制大型的计算、存储、网络等资源池；OpenStack主要使用池化虚拟资源来构建和管理私有云及公共云。</p>
<span id="more"></span>



<h1 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h1><p>云计算：</p>
<ul>
<li>服务提供商构造可配置的计算资源共享池，用户通过网络进行访问。</li>
</ul>
<p>IaaS：基础设施即服务。公有云，私有云和混合云</p>
<p>搭建私有云用到的的就是OpenStack</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-39b400aec8ef07159f8ee043637f8f29_b.jpg" alt="img"></p>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>OpenStack是一个IaaS的解决方案。使用Python开发的。</p>
<p>OpenStack是一个云操作系统，通过数据中心可控制大型的计算、存储、网络等资源池。</p>
<p>主要使用池化虚拟资源来构建和管理私有云及公共云</p>
<h1 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h1><h2 id="2-1-基础架构"><a href="#2-1-基础架构" class="headerlink" title="2.1 基础架构"></a>2.1 基础架构</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-8f583fec34a56f08168a51d34dc5cf3c_b.jpg" alt="img"></p>
<h2 id="2-2-组件"><a href="#2-2-组件" class="headerlink" title="2.2 组件"></a>2.2 组件</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-84526d98a2214fb9a09ff9e652cdb865_b.jpg" alt="img"></p>
<ul>
<li><strong>Nova</strong></li>
</ul>
<p><strong>Nova</strong>是整个Openstack里面最核心的组件。OpenStack云实例生命期所需的各种动作都将由Nova进行处理和支撑，它负责管理整个云的计算资源、网络、授权及测度。</p>
<ul>
<li><strong>Keystone</strong><ul>
<li>用户身份验证。</li>
<li>访问请求控制。</li>
<li>注册表服务：OpenStack需要注册到keystone中</li>
<li>身份验证引擎：决定用户拥有哪些权限。</li>
</ul>
</li>
</ul>
<p>Keystone为所有的OpenStack组件<strong>提供认证和访问策略服务</strong>，主要对（但不限于）Swift、Glance、Nova等进行认证与授权。</p>
<ul>
<li><strong>Horizon</strong></li>
</ul>
<p>Horizon是一个用以管理、控制OpenStack服务的<strong>Web控制面板</strong>。用户可以通过这个界面对OpenStack状态进行查看和管理。</p>
<ul>
<li><strong>Quantum</strong></li>
</ul>
<p>配置vlan，节点配置</p>
<ul>
<li><strong>Glance</strong></li>
</ul>
<p>管理虚拟机镜像，创建后端盘</p>
<ul>
<li><strong>Swift</strong></li>
</ul>
<p>对象存储相关。</p>
<ul>
<li><strong>Cinder</strong> 块存储服务模块</li>
</ul>
<p>管理所有的块存储设备，为VM服务。</p>
<ul>
<li><strong>Neutorn</strong></li>
</ul>
<p>网络服务模块</p>
<h2 id="2-3-组件之间的关系"><a href="#2-3-组件之间的关系" class="headerlink" title="2.3 组件之间的关系"></a>2.3 组件之间的关系</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/1058767-20170208183135541-7440272.png" alt="img"></p>
<h2 id="2-4-访问流程"><a href="#2-4-访问流程" class="headerlink" title="2.4 访问流程"></a>2.4 访问流程</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/1058767-20170208183642822-375913603.png" alt="img"></p>
<h1 id="3-OpenStack创建实例"><a href="#3-OpenStack创建实例" class="headerlink" title="3.OpenStack创建实例"></a>3.OpenStack创建实例</h1><h3 id="3-1流程细节"><a href="#3-1流程细节" class="headerlink" title="3.1流程细节"></a>3.1流程细节</h3><ol>
<li>通过登录界面dashboard或命令行CLI通过<code>RESTful API</code>向<code>keystone</code>获取认证信息。</li>
<li><code>keystone</code><strong>通过用户请求认证信息，并生成<code>auth-token</code>返回给对应的认证请求</strong>。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824160000868.png" alt="在这里插入图片描述"></p>
<ol start="3">
<li>然后携带<code>auth-token</code>通过<code>RESTful API</code>向<code>nova-api</code>发送一个<code>boot instance</code>的请求。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824150425310.png" alt="在这里插入图片描述"></p>
<ol start="4">
<li><p><code>nova-api</code>接受请求后向<code>keystone</code>发送认证请求，查看token是否为有效用户和token。</p>
</li>
<li><p>keystone验证token是否有效，将结果返回给<code>nova-api</code>。</p>
</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824150749828.png" alt="在这里插入图片描述"></p>
<ol start="6">
<li><p>通过认证后nova-api和数据库通讯，初始化新建虚拟机的数据库记录。<br><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/2019082415150929.png" alt="在这里插入图片描述"></p>
</li>
<li><p><code>nova-api</code>调用<code>rabbitmq</code>，向<code>nova-scheduler</code>请求是否有创建虚拟机的资源(node主机)。</p>
</li>
<li><p><code>nova-scheduler</code>进程侦听消息队列，获取nova-api的请求。</p>
</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824152312712.png" alt="在这里插入图片描述"></p>
<ol start="9">
<li><code>nova-scheduler</code>通过查询nova数据库中计算资源的情况，并通过调度算法计算符合虚拟机创建需要的主机。</li>
<li>对于有符合虚拟机创建的主机，<code>nova-scheduler</code>更新数据库中虚拟机对应的物理主机信息。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824202009508.png" alt="在这里插入图片描述"></p>
<ol start="11">
<li><code>nova-scheduler</code>通过rpc调用向<code>nova-compute</code>发送对应的创建虚拟机请求的消息。<br><code>nova-compute</code>会从对应的消息队列中获取创建虚拟机请求的消息。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/2019082415300566.png" alt="在这里插入图片描述"></p>
<ol start="12">
<li><code>nova-compute</code>通过rpc调用向<code>nova-conductor</code>请求获取虚拟机消息。（Flavor）<br><code>nova-conductor</code>从消息队队列中拿到<code>nova-compute</code>请求消息。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824153509883.png"></p>
<ol start="13">
<li><code>nova-conductor</code>根据消息查询虚拟机对应的信息。<br><code>nova-conductor</code>从数据库中获得虚拟机对应信息。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824153924205.png" alt="在这里插入图片描述"></p>
<ol start="14">
<li><code>nova-conductor</code>把虚拟机信息通过消息的方式发送到消息队列中。<br><code>nova-compute</code>从对应的消息队列中获取虚拟机信息消息。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824155934803.png"></p>
<ol start="15">
<li><code>nova-compute</code>请求<code>glance-api</code>获取创建虚拟机所需要镜像。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824161529433.png" alt="在这里插入图片描述"></p>
<ol start="16">
<li><p><code>glance-api</code>向<code>keystone</code>认证token是否有效，并返回验证结果。<br><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824161516324.png" alt="在这里插入图片描述"></p>
</li>
<li><p>token验证通过，<code>nova-compute</code>获得虚拟机镜像信息(URL)。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824161927287.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<ol start="18">
<li><code>nova-compute</code>请求<code>neutron-server</code>获取创建虚拟机所需要的网络信息。</li>
<li><code>neutron-server</code>向keystone认证token是否有效，并返回验证结果。</li>
<li>token验证通过，<code>nova-compute</code>获得虚拟机网络信息。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824162349681.png" alt="在这里插入图片描述"></p>
<ol start="21">
<li><code>nova-compute</code>请求<code>cinder-api</code>获取创建虚拟机所需要的持久化存储信息。</li>
<li><code>cinder-api</code>向keystone认证token是否有效，并返回验证结果。</li>
<li>token验证通过，<code>nova-compute</code>获得虚拟机持久化存储信息。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824164929553.png" alt="在这里插入图片描述"></p>
<ol start="24">
<li><code>nova-compute</code>根据instance的信息调用配置的虚拟化驱动来创建虚拟机。</li>
</ol>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824164637115.png" alt="在这里插入图片描述"></p>
<h3 id="3-2总流程图"><a href="#3-2总流程图" class="headerlink" title="3.2总流程图"></a>3.2总流程图</h3><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20190824205144386.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>docker:基础篇</title>
    <url>/2021/12/07/docker-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>Docker是一个开元的应用<strong>容器</strong>引擎。Doker可以让开发者打包他们的应用以及依赖包导一个轻量级、可移植的容器中，然后发布到任何的Linux机器中，也可以实现虚拟化。</p>
<span id="more"></span>



<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p>Docker是一个开元的应用<strong>容器</strong>引擎。</p>
<p>Doker可以让开发者打包他们的应用以及依赖包导一个轻量级、可移植的容器中，然后发布到任何的Linux机器中，也可以实现虚拟化。</p>
<h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ol>
<li>Web应用的<strong>自动化打包和发布。</strong></li>
<li>自动化测试和持续继承、发布。</li>
<li>在<strong>微服务环境中调试和部署数据库及其他后台应用</strong>。</li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。（没看懂）</li>
</ol>
<h2 id="Docker的优点"><a href="#Docker的优点" class="headerlink" title="Docker的优点"></a>Docker的优点</h2><p>Docker是一个用于开发，交付和运行应用程序的开放平台。</p>
<p>Docker可以将应用程序与基础架构分开。从而可以快速交付软件。</p>
<p>借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。</p>
<p>通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
<ul>
<li>快速，一致的交付您的应用程序。</li>
<li>响应式部署和扩展。</li>
<li>在同一硬件上运行更多工作负载。</li>
</ul>
<h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><h2 id="镜像、容器和仓库"><a href="#镜像、容器和仓库" class="headerlink" title="镜像、容器和仓库"></a>镜像、容器和仓库</h2><p>Docker包括三个基础概念：</p>
<ul>
<li>镜像：Docker镜像，相当于一个root文件系统。</li>
<li>容器：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库：仓库一看做是一个镜像管理中心，用来保存镜像。</li>
</ul>
<p>注意：</p>
<p>Docker使用客户端-服务端（c/s）架构模式，使用远程API来管理和创建爱你Docker容器。</p>
<p>Docker容器通过Docker镜像来创建。</p>
<p>Docker中镜像与容器的关系类比到面向对象中：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207095216035.png" alt="image-20211207095216035"></p>
<h2 id="Docker架构图"><a href="#Docker架构图" class="headerlink" title="Docker架构图"></a>Docker架构图</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207100006642.png" alt="image-20211207100006642"></p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker 镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板。</td>
</tr>
<tr>
<td align="left">Docker 容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="left">Docker 客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK与 Docker 的守护进程（daemon）通信。</td>
</tr>
<tr>
<td align="left">Docker 主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">Docker Registry</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。                                                                           我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h1 id="CentOS系统安装Docker"><a href="#CentOS系统安装Docker" class="headerlink" title="CentOS系统安装Docker"></a>CentOS系统安装Docker</h1><p>一键安装：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">curl -fsSL http<span class="hljs-variable">s:</span>//<span class="hljs-built_in">get</span>.docker.<span class="hljs-keyword">com</span> | bash -s docker --mirror Aliyun<br><br>国内网站安装<br>curl -sSL http<span class="hljs-variable">s:</span>//<span class="hljs-built_in">get</span>.daocloud.io/docker | <span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure>

<p>安装成功之后查看Docker版本号：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile">docker -v<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207101754640.png" alt="image-20211207101754640"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">service docker start      <span class="hljs-regexp">//</span>启动docker service<br></code></pre></td></tr></table></figure>





<h1 id="Docker的使用"><a href="#Docker的使用" class="headerlink" title="Docker的使用"></a>Docker的使用</h1><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run ubuntu:<span class="hljs-number">15</span>.<span class="hljs-number">10</span> /bin/echo <span class="hljs-string">&quot;Hello world&quot;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207111735390.png" alt="image-20211207111735390"></p>
<p>参数解析：</p>
<ul>
<li><strong>docker:</strong> Docker 的二进制执行文件。</li>
<li><strong>run:</strong> 与前面的 docker 组合来运行一个容器。</li>
<li><strong>ubuntu:15.10</strong> 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li><strong>/bin/echo “Hello world”:</strong> 在启动的容器里执行的命令</li>
</ul>
<p>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</p>
<p><strong>错误一：</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">报错：docker：cannot connect <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> docker daemon<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207110138856.png" alt="image-20211207110138856"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">解决方法：<br>sudo su                       <span class="hljs-regexp">//</span>切换到root<br><br>service docker start      <span class="hljs-regexp">//</span>启动docker service<br><br>docker images              <span class="hljs-regexp">//</span>显示所有images<br><br>docker ps <span class="hljs-regexp">//</span>重新运行docker命令<br></code></pre></td></tr></table></figure>

<img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207110241902.png" alt="image-20211207110241902" style="zoom:150%;" />



<p><strong>错误二：</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> ubantu:15.10 /bin/echo <span class="hljs-string">&quot;Hello world&quot;</span><br>报错：<br>docker：<span class="hljs-builtin-name">Error</span> response <span class="hljs-keyword">from</span> daemon:pull access denied <span class="hljs-keyword">for</span> ubantu<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207110354983.png" alt="image-20211207110354983"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">Ubuntu拼写错误：<br>docker run ubuntu:<span class="hljs-number">15.10</span> <span class="hljs-regexp">/bin/</span>echo <span class="hljs-string">&quot;Hello world&quot;</span><br>成功下载，输出结果。<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207111441289.png" alt="image-20211207111441289"></p>
<h2 id="运行交互式的容器（进入docker的容器内部）"><a href="#运行交互式的容器（进入docker的容器内部）" class="headerlink" title="运行交互式的容器（进入docker的容器内部）"></a>运行交互式的容器（进入docker的容器内部）</h2><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -i -t ubuntu:<span class="hljs-number">15</span>.<span class="hljs-number">10</span> /bin/bash<br></code></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</li>
<li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207112430398.png" alt="image-20211207112430398"></p>
<p>此时已经进入到Ubuntu15.10的容器中。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">查看容器的信息：<br>ls                    <span class="hljs-comment">#目录</span><br>cat <span class="hljs-regexp">/proc/</span>version     <span class="hljs-comment">#版本信息</span><br></code></pre></td></tr></table></figure>

<p>退出当前容器：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>



<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d ubuntu:<span class="hljs-number">15</span>.<span class="hljs-number">10</span> /bin/sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207113747944.png" alt="image-20211207113747944"></p>
<p>在这里我们没有得到“hello world 2”，而是得到了一个长的字符串。这个长字符串就是容器的ID号。对容器来说，ID号是唯一的。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">查看正在运行的容器：<br>docker <span class="hljs-built_in">ps</span><br></code></pre></td></tr></table></figure>

<p>输出详情介绍：</p>
<p><strong>CONTAINER ID:</strong> 容器 ID。</p>
<p><strong>IMAGE:</strong> 使用的镜像。</p>
<p><strong>COMMAND:</strong> 启动容器时运行的命令。</p>
<p><strong>CREATED:</strong> 容器的创建时间。</p>
<p><strong>STATUS:</strong> 容器状态。</p>
<p>状态有7种：</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
<p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p>
<p><strong>NAMES:</strong> 自动分配的容器名称。</p>
<p>查看容器的输出：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker logs 容器ID<br><br>runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker logs 容器名<br></code></pre></td></tr></table></figure>

<p>停止容器：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">docker stop 容器名/ID<br></code></pre></td></tr></table></figure>



<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#容器使用命令</span><br>docker pull ubuntu                 <span class="hljs-comment">#获取镜像</span><br>docker run -it ubuntu <span class="hljs-regexp">/bin/</span>bash    <span class="hljs-comment">#启动容器  i：交互式操作    t：终端</span><br><span class="hljs-keyword">exit</span>                               <span class="hljs-comment">#退出</span><br>docker ps -a                       <span class="hljs-comment">#查看所有的容器</span><br>docker start 容器名/ID              <span class="hljs-comment">#启动容器一个已经停止的容器</span><br>docker run -itd --name 容器名 ubuntu <span class="hljs-regexp">/bin/</span>bash     <span class="hljs-comment"># 后台运行容器，d：指定运行的模式</span><br>docker stop 容器/ID                 <span class="hljs-comment">#停止容器</span><br>docker restart 容器名/ID<br><br><span class="hljs-comment">#进入容器命令</span><br>docker attach ID                <span class="hljs-comment">#退出容器时，容器运行停止</span><br>docker exec -it ID <span class="hljs-regexp">/bin/</span>bash    <span class="hljs-comment">#退出容器时，容器不会停止</span><br><br><span class="hljs-comment">#导入导出容器：</span><br>docker export <span class="hljs-number">1</span>e560fca3906 &gt; ubuntu.tar         <span class="hljs-comment">#导出到本地 ubuntu.tar是自定义的文件名</span><br>cat docker<span class="hljs-regexp">/ubuntu.tar | docker import - test/u</span>buntu:v1        <span class="hljs-comment">#导入</span><br>docker import http:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/exampleimage.tgz example/im</span>agerepo      <span class="hljs-comment">#通过url导入</span><br><br><span class="hljs-comment">#删除容器</span><br>docker rm -f ID             <span class="hljs-comment">#根据ID删除一个容器</span><br>docker container prune      <span class="hljs-comment">#清理掉所有处于终止状态的容器</span><br></code></pre></td></tr></table></figure>

<h3 id="web-app相关应用"><a href="#web-app相关应用" class="headerlink" title="web app相关应用"></a>web app相关应用</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">docker pull training/webapp  <span class="hljs-comment"># 载入镜像</span><br>docker run -d -P training/webapp python app.py    <span class="hljs-comment">#加载镜像， -d：后台运行，-p：将容器内部使用的网络端口映射到本主机上。</span><br>docker ps                    <span class="hljs-comment"># 查看Web应用容器</span><br>docker run -d -p 5000<span class="hljs-function">:5000</span> training/webapp python app.py        <span class="hljs-comment"># -p可以设置端口</span><br>docker post 容器名/端口名              <span class="hljs-comment">#查看容器的端口映射地址</span><br>docker logs -f 端口ID                <span class="hljs-comment">#查看日志</span><br>docker top 容器名<span class="hljs-string">/ID</span>                    <span class="hljs-comment">#查看容器中的进程</span><br>docker inspect 容器名<span class="hljs-string">/ID</span>                <span class="hljs-comment">#查看docker的底层信息</span><br>docker stop 容器名<span class="hljs-string">/ID</span>                   <span class="hljs-comment">#停止web应用</span><br>docker start 容器名<span class="hljs-string">/ID</span>                  <span class="hljs-comment">#开启web应用</span><br>docker ps -l                           <span class="hljs-comment">#查询最后一次创建的容器</span><br>docker rm 容器名<span class="hljs-string">/ID</span>                     <span class="hljs-comment">#移除容器。</span><br></code></pre></td></tr></table></figure>

<h3 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">docker images                            <span class="hljs-comment">#查看本地镜像</span><br>docker run -t -i ubuntu:<span class="hljs-number">15.10</span> /bin/bash  <span class="hljs-comment">#使用Ubuntu15.10版本的镜像来运行容器，如果不指定版本的话，则默认使用最新版。</span><br>docker pull 镜像名：版本                   <span class="hljs-comment">#下载镜像</span><br>docker search 镜像名                      <span class="hljs-comment">#查找镜像</span><br>docker run 镜像名                         <span class="hljs-comment">#使用镜像</span><br>docker rmi 镜像名                         <span class="hljs-comment">#删除镜像</span><br>docker <span class="hljs-keyword">tag</span> <span class="hljs-title">ID</span> repository名:<span class="hljs-keyword">tag</span>名          <span class="hljs-comment">#给镜像添加标签</span><br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207150407705.png" alt="image-20211207150407705"></p>
<h3 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#创建一个Python应用的容器</span><br>注意： -P：随机端口号                -p:指定端口号<br>docker <span class="hljs-builtin-name">run</span> -d -P training/webapp python app.py <br>docker <span class="hljs-builtin-name">run</span> -d -p 127.0.0.1:5001:5000 training/webapp python app.py   # 默认绑定tcp端口<br>docker <span class="hljs-builtin-name">run</span> -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py  #udp<br><br>docker<span class="hljs-built_in"> port </span>容器名 端口号                    #查看端口的绑定情况。<br>docker <span class="hljs-builtin-name">run</span> -d -P --name 容器名 training/webapp python app.py<br>docker<span class="hljs-built_in"> network </span>create -d<span class="hljs-built_in"> bridge </span>网络名       #创建一个新的docker网络。-d：参数指定 Docker 网络类型，有 bridge、overlay。<br><br><span class="hljs-comment">#连接容器</span><br><span class="hljs-comment">#运行一个容器并连接到 test-net 网络:</span><br>docker <span class="hljs-builtin-name">run</span> -itd --name test1 --network test-net ubuntu /bin/bash  <br><br><br></code></pre></td></tr></table></figure>



<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#在容器中安装ping指令</span><br><span class="hljs-number">1</span>。先进入容器内：<br>docker exec -<span class="hljs-keyword">it</span> <span class="hljs-built_in">id</span> bin/bash<br><span class="hljs-number">2.</span><br>apt-<span class="hljs-keyword">get</span> update<br><span class="hljs-number">3.</span><br>apt install iputils-ping<br><br><span class="hljs-number">4.</span>在test1网络中ping test2<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207161822903.png" alt="image-20211207161822903"></p>
<p>test1 容器和 test2 容器建立了互联关系。</p>
<p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose</p>
<h3 id="Docker仓库管理"><a href="#Docker仓库管理" class="headerlink" title="Docker仓库管理"></a>Docker仓库管理</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">docker login           <span class="hljs-comment">#登录</span><br>docker logout          <span class="hljs-comment">#退出</span><br>docker search ubuntu   <span class="hljs-comment">#查找远程仓库中的镜像</span><br>docker pull 镜像名      <span class="hljs-comment">#从远程操控中拉取，下载到本地</span><br><br>docker <span class="hljs-keyword">tag</span> <span class="hljs-title">ubuntu</span>:<span class="hljs-number">18.04</span> 用户名/ubuntu:<span class="hljs-number">18.04</span>      <span class="hljs-comment">#推送数据</span><br>docker image ls        <span class="hljs-comment">#查看镜像</span><br><br></code></pre></td></tr></table></figure>

<h3 id="Docker-Dockerfile"><a href="#Docker-Dockerfile" class="headerlink" title="Docker Dockerfile"></a>Docker Dockerfile</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">加载中。。。。。<br></code></pre></td></tr></table></figure>

<h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<p>安装Compose</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#安装compose</span><br>$ sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot;</span> -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose<br>加载中。。。。。<br><br></code></pre></td></tr></table></figure>

<h3 id="Docker-machine"><a href="#Docker-machine" class="headerlink" title="Docker machine"></a>Docker machine</h3><p>Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</p>
<p>Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#下载</span><br>base=https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/m</span>achine<span class="hljs-regexp">/releases/</span>download/v0.<span class="hljs-number">16.0</span> &amp;&amp;<br>  curl -L <span class="hljs-variable">$base</span><span class="hljs-regexp">/docker-machine-$(uname -s)-$(uname -m) &gt;/</span>tmp/docker-machine &amp;&amp;<br>  sudo mv <span class="hljs-regexp">/tmp/</span>docker-machine <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-machine &amp;&amp;<br>  chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-machine<br></code></pre></td></tr></table></figure>



<h3 id="Docker-Swarm集群管理工具"><a href="#Docker-Swarm集群管理工具" class="headerlink" title="Docker Swarm集群管理工具"></a>Docker Swarm集群管理工具</h3><p>Docker Swarm 是 Docker 的<strong>集群管理工具</strong>。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。</p>
<p>支持的工具包括但不限于以下各项：</p>
<ul>
<li>Dokku</li>
<li>Docker Compose</li>
<li>Docker Machine</li>
<li>Jenkins</li>
</ul>
<p><strong>原理：</strong></p>
<p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p>
<ul>
<li><strong>swarm mananger</strong>：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</li>
<li><strong>work node</strong>：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</li>
</ul>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/services-diagram.png" alt="img"></p>
<p>==swarm因为功能少，现在已经被k8s替代了，使用的较少==</p>
<p>k8s架构图如下：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211207175444273.png" alt="image-20211207175444273"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>k8s--基础篇</title>
    <url>/2021/12/06/k8s-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>K8S是用于<strong>管理云平台中多个主机上的容器化</strong>的应用。让部署容器化的应用简单并且高效（powerful）,K8S提供了应用部署，规划，更新，维护的一种机制。</p>
<span id="more"></span>



<h1 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h1><h1 id="K8s介绍"><a href="#K8s介绍" class="headerlink" title="K8s介绍"></a>K8s介绍</h1><p>K8S是用于<strong>管理云平台中多个主机上的容器化</strong>的应用。</p>
<ul>
<li>K8S的目标是让部署容器化的应用简单并且高效（powerful）,K8S提供了应用部署，规划，更新，维护的一种机制。</li>
<li>K8S能够自主的管理容器来控制云平台中的容器按照用户的期望状态运行着。K8S会自动监控，然后控制容器重启，新建。</li>
<li>K8S着重于不间断的服务状态和原云平台应用（NoSQL）。</li>
</ul>
<h2 id="Pod简介"><a href="#Pod简介" class="headerlink" title="Pod简介"></a>Pod简介</h2><p>在K8S中，Pod是最小的，管理，创建，计划的最小单元.</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20161027205746.jpg"></p>
<p>在K8S中，所有的容器都是在Pod中运行的，一个Pod可以承载一个或者多个相关的容器，同一个Pod中的容器部署在同一个物理主机上并且共享内存。</p>
<p>用户可以自己创建并管理pod。K8S将这些操作简化成两个：</p>
<ol>
<li>基于相同的Pod配置文件部署多个Pod复制品。</li>
<li>当一个Pod挂了或者及其挂了的时候，创建可替代的Pod。</li>
</ol>
<figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">k8s常用操作：<br>我们经常需要选中一组Pod，例如，我们要限制一组Pod的某些操作，或者查询某组Pod的状态，作为Kubernetes的基本机制，用户可以给Kubernetes Api中的任何对象贴上一组 key:value的标签，然后，我们就可以通过标签来选择一组相关的Kubernetes Api 对象，然后去执行一些特定的操作，每个资源额外拥有一组（很多） <span class="hljs-keyword">keys</span> 和 <span class="hljs-keyword">values</span>,然后外部的工具可以使用这些<span class="hljs-keyword">keys</span>和vlues值进行对象的检索，这些Map叫做annotations（注释）。<br></code></pre></td></tr></table></figure>





<h2 id="K8S网络设置"><a href="#K8S网络设置" class="headerlink" title="K8S网络设置"></a>K8S网络设置</h2><p>K8S可以为每个Pod分配IP地址。K8S支持一种特殊的网络模型，创建了一个地址空间，并且不动态的分配端口，允许用户选择任何想要使用的端口。</p>
<p>当你新建一个集群，为了保证Pod获得IP地址，你需要给Kubernetes分配一个IP地址池。最简单的做法是每当节点与节点之间的通信可以以一下两种方式实现：</p>
<p><strong>（1）配置网络完成Pod的IP地址路由</strong></p>
<p><strong>（2）建立一个拓扑网络</strong></p>
<h2 id="K8S资源"><a href="#K8S资源" class="headerlink" title="K8S资源"></a>K8S资源</h2><p>K8S中的资源都是通过URI进行区分的。每个URI都有一个UID，URI的主要组成部分是：类型（比如POD）、对象的名字、对象的命名空间。</p>
<ul>
<li>对于特殊的对象类型，在同一个命名空间内，所有的名字都是不同的。</li>
<li>在对象只提供名称，不提供命名空间的基础上，假定是默认的命名空间。</li>
<li>UID是空间和时间上的唯一。</li>
</ul>
<h1 id="K8S架构"><a href="#K8S架构" class="headerlink" title="K8S架构"></a>K8S架构</h1><p>K8S集群包含有节点代理kubelet和Master组件(APIs, scheduler, etc)，一切都基于分布式的存储系统。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20161028141542.jpg"></p>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>configMap：存储配置信息</p>
<p>secret：存储加密信息，秘钥等</p>
<p>volume：提供共享存储卷</p>
<p>PersistentVolume：持久卷。</p>
<h2 id="卷（Volume-）"><a href="#卷（Volume-）" class="headerlink" title="卷（Volume ）"></a>卷（Volume ）</h2><p>容器和 Pod 是短暂的。其含义是它们的生命周期可能很短，会被频繁地销毁和创建。容器销毁时，保存在容器内部文件系统中的数据都会被清除。</p>
<p><strong>为了持久化保存容器的数据，可以使用 Kubernetes Volume。</strong>Volume 的生命周期独立于容器，Pod 中的容器可能被销毁和重建，但 Volume 会被保留。</p>
<p>本质上，Kubernetes Volume <strong>是一个目录</strong>，这一点与 Docker Volume 类似。当 Volume 被 mount 到 Pod，<strong>Pod 中的所有容器都可以访问这个 Volume</strong>。</p>
<p>K8S Volume 也支持多种 backend 类型，包括 <strong>emptyDir、hostPath、GCE Persistent Disk、AWS Elastic Block Store、NFS、Ceph</strong> 等。</p>
<p>Volume 提供了对各种 backend 的抽象，容器在使用 Volume 读写数据的时候不需要关心数据到底是存放在本地节点的文件系统中呢还是云硬盘上。对它来说，所有类型的 Volume 都只是一个目录。</p>
<p><strong>卷的核心是一个目录，其中可能存有数据，Pod 中的容器可以访问该目录中的数据。</strong></p>
<h3 id="持久卷"><a href="#持久卷" class="headerlink" title="持久卷"></a>持久卷</h3><p>持久卷（PersistentVolume，PV）是集群中的一块存储，可以由管理员事先供应，或者 使用存储类（Storage Class）来动态供应。 持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通的 Volume 一样，也是使用 卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。 此 API 对象中记述了存储的实现细节，无论其背后是 NFS、iSCSI 还是特定于云平台的存储系统。</p>
<h1 id="k8s生命周期"><a href="#k8s生命周期" class="headerlink" title="k8s生命周期"></a>k8s生命周期</h1><p>创建集群，部署应用，发布应用，扩展应用，更新应用。</p>
<p>1.创建集群。</p>
<ul>
<li>统一对外提供接口</li>
<li>提供更好的可靠性，服务器宕机那么频繁，物理磁盘那么容易损坏，无须担心，集群统一进行调配</li>
<li>提供更好的性能，组合集群中各个机器的计算存储网络资源，提供更好的TPS和PS</li>
<li>提供横向扩容的能力，在进行横向扩容的时候，性能基本上能呈线性增长</li>
</ul>
<p>使用k8s创建集群的两种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Linux">//初始化集群，会创建一个master节点。<br>kubectl init<br><br><br>//创建一个node节点，加入集群<br>kubectl join xxx<br></code></pre></td></tr></table></figure>

<p>k8s在物理上进行划分的时候，划分了两种类型的主机，一个master节点，主要用来调度，控制集群的资源；node节点，主要用来运行容器的节点，也就是运行服务的节点。</p>
<ul>
<li>master用来控制，存储各种元数据。</li>
<li>node是一个工作节点，用来干活的。</li>
<li>node节点定时与master进行通信，通过kubele进程来汇报信息</li>
</ul>
<p>查看集群信息：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/bbed100cb6b80f08150065ecdca9628a.png" alt="img"></p>
<p>==未完==</p>
<h1 id="K8S常用命令"><a href="#K8S常用命令" class="headerlink" title="K8S常用命令"></a>K8S常用命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs ssh">#查看所有namespace的pods运行情况<br>kubectl get pods --all-namespaces <br>#查看具体pods，记得后边跟namespace名字哦<br>kubectl get pods  kubernetes-dashboard-76479d66bb-nj8wr --namespace=kube-system<br># 查看pods具体信息<br>kubectl get pods -o wide kubernetes-dashboard-76479d66bb-nj8wr --namespace=kube-system<br># 查看集群健康状态<br>kubectl get cs<br># 获取所有deployment<br>kubectl get deployment --all-namespaces<br># 查看kube-system namespace下面的pod/svc/deployment 等等（-o wide 选项可以查看存在哪个对应的节点）<br>kubectl get pod /svc/deployment -n kube-system<br># 列出该 namespace 中的所有 pod 包括未初始化的<br>kubectl get pods --include-uninitialized<br># 查看deployment()<br>kubectl get deployment nginx-app<br># 查看rc和servers<br>kubectl get rc,services<br># 查看pods结构信息（重点，通过这个看日志分析错误）<br># 对控制器和服务，node同样有效<br>kubectl describe pods xxxxpodsname --namespace=xxxnamespace<br># 其他控制器类似吧，就是kubectl get 控制器 控制器具体名称<br># 查看pod日志<br>kubectl logs $POD_NAME<br># 查看pod变量<br>kubectl exec my-nginx-5j8ok -- printenv | grep SERVICE<br># 集群<br>kubectl get cs           # 集群健康情况<br>kubectl cluster-info     # 集群核心组件运行情况<br>kubectl get namespaces    # 表空间名<br>kubectl version           # 版本<br>kubectl api-versions      # API<br>kubectl get events       # 查看事件<br>kubectl get nodes      //获取全部节点<br>kubectl delete node k8s2  //删除节点<br>kubectl rollout status deploy nginx-test<br>kubectl get deployment --all-namespaces<br>kubectl get svc --all-namespaces<br><br># 创建<br>kubectl create -f ./nginx.yaml           # 创建资源<br>kubectl apply -f xxx.yaml （创建+更新，可以重复使用）<br>kubectl create -f .                            # 创建当前目录下的所有yaml资源<br>kubectl create -f ./nginx1.yaml -f ./mysql2.yaml     # 使用多个文件创建资源<br>kubectl create -f ./dir                        # 使用目录下的所有清单文件来创建资源<br>kubectl create -f https://git.io/vPieo         # 使用 url 来创建资源<br>kubectl run -i --tty busybox --image=busybox    ----创建带有终端的pod<br>kubectl run nginx --image=nginx                # 启动一个 nginx 实例<br>kubectl run mybusybox --image=busybox --replicas=5    ----启动多个pod<br>kubectl explain pods,svc                       # 获取 pod 和 svc 的文档<br><br># 更新<br>kubectl rolling-update python-v1 -f python-v2.json      # 滚动更新 pod frontend-v1<br>kubectl rolling-update python-v1 python-v2 --image=image:v2  # 更新资源名称并更新镜像<br>kubectl rolling-update python --image=image:v2        # 更新 frontend pod 中的镜像<br>kubectl rolling-update python-v1 python-v2 --rollback       # 退出已存在的进行中的滚动更新<br>cat pod.json | kubectl replace -f -           # 基于 stdin 输入的 JSON 替换 pod<br><br># 为 nginx RC 创建服务，启用本地 80 端口连接到容器上的 8000 端口<br>kubectl expose rc nginx --port=80 --target-port=8000<br><br># 更新单容器 pod 的镜像版本（tag）到 v4<br>kubectl get pod nginx-pod -o yaml | sed &#x27;s/\(image: myimage\):.*$/\1:v4/&#x27; | kubectl replace -f -<br>kubectl label pods nginx-pod new-label=awesome                      # 添加标签<br>kubectl annotate pods nginx-pod icon-url=http://goo.gl/XXBTWq       # 添加注解<br>kubectl autoscale deployment foo --min=2 --max=10         # 自动扩展 deployment “foo”<br><br># 编辑资源<br>kubectl edit svc/docker-registry                      # 编辑名为 docker-registry 的 service<br>KUBE_EDITOR=&quot;nano&quot; kubectl edit svc/docker-registry   # 使用其它编辑器<br>vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf #修改启动参数<br><br># 动态伸缩pod<br>kubectl scale --replicas=3 rs/foo                       # 将foo副本集变成3个<br>kubectl scale --replicas=3 -f foo.yaml                  # 缩放“foo”中指定的资源。<br>kubectl scale --current-replicas=2 --replicas=3 deployment/mysql  # 将deployment/mysql从2个变成3个<br>kubectl scale --replicas=5 rc/foo rc/bar rc/baz                   # 变更多个控制器的数量<br>kubectl rollout status deploy deployment/mysql                    # 查看变更进度<br><br>#label 操作<br>kubectl label：添加label值 kubectl label nodes node1 zone=north #增加节点lable值 spec.nodeSelector: zone: north #指定pod在哪个节点<br>kubectl label pod redis-master-1033017107-q47hh role=master #增加lable值 [key]=[value]<br>kubectl label pod redis-master-1033017107-q47hh role- #删除lable值<br>kubectl label pod redis-master-1033017107-q47hh role=backend --overwrite #修改lable值<br><br># 滚动升级<br>kubectl rolling-update：滚动升级 kubectl rolling-update redis-master -f redis-master-controller-v2.yaml #配置文件滚动升级<br>kubectl rolling-update redis-master --image=redis-master:2.0 #命令升级<br>kubectl rolling-update redis-master --image=redis-master:1.0 --rollback #pod版本回滚<br><br># etcdctl 常用操作<br>etcdctl cluster-health #检查网络集群健康状态<br>etcdctl --endpoints=https://192.168.71.221:2379 cluster-health #带有安全认证检查网络集群健康状态<br>etcdctl member list<br>etcdctl set /k8s/network/config ‘&#123; “Network”: “10.1.0.0/16” &#125;’<br>etcdctl get /k8s/network/config<br><br># 删除<br>kubectl delete pod -l app=flannel -n kube-system   # 根据label删除：<br>kubectl delete -f ./pod.json        # 删除 pod.json 文件中定义的类型和名称的 pod<br>kubectl delete pod,service baz foo     # 删除名为“baz”的 pod 和名为“foo”的 service<br>kubectl delete pods,services -l name=myLabel # 删除具有 name=myLabel 标签的 pod 和 serivce<br>kubectl delete pods,services -l name=myLabel --include-uninitialized   # 删除具有 name=myLabel 标签的 pod 和 service，包括尚未初始化的<br>kubectl -n my-ns delete po,svc --all     # 删除 my-ns namespace下的所有 pod 和 serivce，包括尚未初始化的<br>kubectl delete pods prometheus-7fcfcb9f89-qkkf7 --grace-period=0 --force 强制删除<br>kubectl delete deployment kubernetes-dashboard --namespace=kube-system<br>kubectl delete svc kubernetes-dashboard --namespace=kube-system<br>kubectl delete -f kubernetes-dashboard.yaml<br>kubectl replace --force -f ./pod.json # 强制替换，删除后重新创建资源。会导致服务中断。<br><br># 交互<br>kubectl logs nginx-pod                                 # dump 输出 pod 的日志（stdout）<br>kubectl logs nginx-pod -c my-container                 # dump 输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用）<br>kubectl logs -f nginx-pod                              # 流式输出 pod 的日志（stdout）<br>kubectl logs -f nginx-pod -c my-container              # 流式输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用）<br>kubectl run -i --tty busybox --image=busybox -- sh  # 交互式 shell 的方式运行 pod<br>kubectl attach nginx-pod -i                            # 连接到运行中的容器<br>kubectl port-forward nginx-pod 5000:6000               # 转发 pod 中的 6000 端口到本地的 5000 端口<br>kubectl exec nginx-pod -- ls /                         # 在已存在的容器中执行命令（只有一个容器的情况下）<br>kubectl exec nginx-pod -c my-container -- ls /         # 在已存在的容器中执行命令（pod 中有多个容器的情况下）<br>kubectl top pod POD_NAME --containers               # 显示指定 pod和容器的指标度量<br>kubectl exec -ti podName /bin/bash     # 进入pod<br><br># 调度配置<br>kubectl cordon k8s-node              # 标记 my-node 不可调度<br>kubectl drain k8s-node               # 清空 my-node 以待维护<br>kubectl uncordon k8s-node            # 标记 my-node 可调度<br>kubectl top node k8s-node            # 显示 my-node 的指标度量<br>kubectl cluster-info dump            # 将当前集群状态输出到 stdout                                    <br>kubectl cluster-info dump --output-directory=/path/to/cluster-state   # 将当前集群状态输出到 /path/to/cluster-state<br>#如果该键和影响的污点（taint）已存在，则使用指定的值替换<br>kubectl taint nodes foo dedicated=special-user:NoSchedule<br>#查看kubelet进程启动参数<br>ps -ef | grep kubelet<br># 查看日志:<br>journalctl -u kubelet -f<br><br>导出配置文件：<br>　　导出proxy<br>　　kubectl get ds -n kube-system -l k8s-app=kube-proxy -o yaml&gt;kube-proxy-ds.yaml<br>　　导出kube-dns<br>　　kubectl get deployment -n kube-system -l k8s-app=kube-dns -o yaml &gt;kube-dns-dp.yaml<br>　　kubectl get services -n kube-system -l k8s-app=kube-dns -o yaml &gt;kube-dns-services.yaml<br>　　导出所有 configmap<br>　　kubectl get configmap -n kube-system -o wide -o yaml &gt; configmap.yaml<br><br>复杂操作命令：<br>　删除kube-system 下Evicted状态的所有pod：<br>kubectl get pods -n kube-system |grep Evicted| awk ‘&#123;print $1&#125;’|xargs kubectl delete pod -n kube-system<br>以下为维护环境相关命令：<br>重启kubelet服务<br>systemctl daemon-reload<br>systemctl restart kubelet<br><br></code></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>redis哨兵模式，sentinel获取master的信息</title>
    <url>/2021/12/16/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%8Csentinel%E8%8E%B7%E5%8F%96master%E7%9A%84%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预，这就很蛋疼啊。</p>
<p>在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。</p>
<span id="more"></span>



<h1 id="哨兵模式基本概念"><a href="#哨兵模式基本概念" class="headerlink" title="哨兵模式基本概念"></a>哨兵模式基本概念</h1><p>哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预，这就很蛋疼啊。</p>
<p>在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-0c8f6c4253843790b774fd216dea58c5_720w.jpg" alt="img"></p>
<ol>
<li><strong>「监控」</strong>：监控master和slave是否正常运行，以及哨兵之间也会相互监控</li>
<li><strong>「自动故障恢复」</strong>：当master出现故障的时候，会自动选举一个slave作为master顶上去。</li>
</ol>
<h1 id="根据sentinel获取master的信息"><a href="#根据sentinel获取master的信息" class="headerlink" title="根据sentinel获取master的信息"></a>根据sentinel获取master的信息</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> redis.clients.jedis.HostAndPort;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.exceptions.JedisException;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindMasterService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过传入的哨兵集群找到主节点的信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sentinels：哨兵集群</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> masterName：主节点的名字</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HostAndPort <span class="hljs-title">findMaster</span><span class="hljs-params">(Set&lt;String&gt; sentinels,String masterName)</span></span>&#123;<br>        HostAndPort master = <span class="hljs-keyword">null</span>;<br>        String password = <span class="hljs-string">&quot;xdata@123&quot;</span>;<br><br>        <span class="hljs-comment">//遍历哨兵，根据哨兵获取主节点的信息</span><br>        <span class="hljs-keyword">for</span> (String sentinel:sentinels)&#123;<br>            <span class="hljs-comment">//当前的集群节点是String，封装成HostAndPost类</span><br>            HostAndPort hap = HostAndPort.parseString(sentinel);<br><br>            Jedis jedis = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//使用Jedis连接哨兵,当前哨兵挂了，会抛出异常</span><br>                jedis = <span class="hljs-keyword">new</span> Jedis(hap.getHost(),hap.getPort());<br>                <span class="hljs-comment">//密码验证,jedis不需要密码验证，直接可以连接。</span><br>                <span class="hljs-comment">//jedis.auth(password);</span><br><br>                <span class="hljs-comment">// 向哨兵发送指令：sentinel get-master-addr-by-name masterName 可以获取主节点的host的端口</span><br>                List&lt;String&gt; masterAddress = jedis.sentinelGetMasterAddrByName(masterName);<br>                <span class="hljs-comment">//当前哨兵宕机时，masterAddress为空。</span><br>                <span class="hljs-keyword">if</span> (masterAddress.size() == <span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-comment">//获取到master的信息</span><br>                    master = <span class="hljs-keyword">new</span> HostAndPort(masterAddress.get(<span class="hljs-number">0</span>),Integer.parseInt(masterAddress.get(<span class="hljs-number">1</span>)));<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (JedisException e)&#123;<br>                <span class="hljs-comment">//出现异常可能是因为当前sentinel挂了，继续遍历下一个sentinel</span><br>                e.getMessage();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>)&#123;<br>                    jedis.close();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> master;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.HostAndPort;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindMasterServiceTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindMaster</span><span class="hljs-params">()</span></span>&#123;<br>        FindMasterService findMasterService = <span class="hljs-keyword">new</span> FindMasterService();<br>        Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        sentinels.add(<span class="hljs-string">&quot;host:post&quot;</span>);              <span class="hljs-comment">//host:post修改端口号</span><br>        sentinels.add(<span class="hljs-string">&quot;host:post&quot;</span>);<br>        sentinels.add(<span class="hljs-string">&quot;host:post&quot;</span>);<br><br>        String masterName = <span class="hljs-string">&quot;mymaster&quot;</span>;<br>        HostAndPort master = findMasterService.findMaster(sentinels, masterName);<br>        System.out.println(master.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="修改（代码优化）"><a href="#修改（代码优化）" class="headerlink" title="修改（代码优化）"></a>修改（代码优化）</h1><p>之前的代码之后获得master的信息，使用这个方法可以得到master、slave与sentinel的信息（ip、port、role、status）。</p>
<p>之前写的代码，层次结构不够清晰，代码不够规范，根据师兄的建议修改了一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SentinelService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主从模式下，查找host</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sentinelsList：哨兵列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> hosts列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;HostServiceDTO&gt; <span class="hljs-title">sentinelFindHosts</span><span class="hljs-params">(List&lt;ServiceCheckDTO&gt; sentinelsList)</span></span>&#123;<br><br>        String password = sentinelsList.get(<span class="hljs-number">0</span>).getPassword();<br>        List&lt;HostServiceDTO&gt; hosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">boolean</span> writeInList = <span class="hljs-keyword">true</span>;       <span class="hljs-comment">//用来标记是否已经将master与slave的信息写入到list中</span><br><br>        <span class="hljs-keyword">for</span> (ServiceCheckDTO sentinel : sentinelsList)&#123;<br><br>            String sentinelStatus = ServiceStatusEnum.RUNNING.getName();<br><br>            <span class="hljs-keyword">try</span>(Jedis jedis = <span class="hljs-keyword">new</span> Jedis(sentinel.getIp(),Integer.parseInt(sentinel.getPort())))&#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 根据sentinel获得master,主从模式master只有一个</span><br><span class="hljs-comment">                 */</span><br>                List&lt;Map&lt;String, String&gt;&gt; mastersMeg = jedis.sentinelMasters();<br><br>                <span class="hljs-keyword">if</span> (writeInList &amp;&amp; !mastersMeg.isEmpty())&#123;<br>                    Map&lt;String, String&gt; masterMeg = mastersMeg.get(<span class="hljs-number">0</span>);<br>                    String masterStatus = getStatus(masterMeg, password);<br>                    HostServiceDTO master = HostServiceDTO.builder()<br>                            .ip(masterMeg.get(<span class="hljs-string">&quot;ip&quot;</span>))<br>                            .port(masterMeg.get(<span class="hljs-string">&quot;port&quot;</span>))<br>                            .role(ServiceRoleEnum.MASTER.getName())<br>                            .status(masterStatus)<br>                            .build();<br>                    hosts.add(master);<br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 根据master得到slaves</span><br><span class="hljs-comment">                     */</span><br>                    List&lt;Map&lt;String, String&gt;&gt; slavesMeg = jedis.sentinelSlaves(masterMeg.get(<span class="hljs-string">&quot;name&quot;</span>));<br>                    <span class="hljs-keyword">for</span> (Map&lt;String, String&gt; slaveMeg : slavesMeg)&#123;<br>                        String slaveStatus = getStatus(slaveMeg, password);<br>                        HostServiceDTO slave = HostServiceDTO.builder()<br>                                .ip(slaveMeg.get(<span class="hljs-string">&quot;ip&quot;</span>))<br>                                .port(slaveMeg.get(<span class="hljs-string">&quot;port&quot;</span>))<br>                                .role(ServiceRoleEnum.SLAVE.getName())<br>                                .status(slaveStatus)<br>                                .build();<br>                        hosts.add(slave);<br>                    &#125;<br>                    writeInList = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (JedisException e)&#123;<br>                sentinelStatus = ServiceStatusEnum.STOPPED.getName();<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 写入sentinel</span><br><span class="hljs-comment">             */</span><br>            HostServiceDTO sentinelHost = HostServiceDTO.builder()<br>                    .ip(sentinel.getIp())<br>                    .port(sentinel.getPort())<br>                    .role(ServiceRoleEnum.SENTINEL.getName())<br>                    .status(sentinelStatus)<br>                    .build();<br>            hosts.add(sentinelHost);<br>        &#125;<br>        <span class="hljs-keyword">return</span> hosts;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">(Map&lt;String, String&gt; host, String password)</span></span>&#123;<br>        String hostIp = host.get(<span class="hljs-string">&quot;ip&quot;</span>);<br>        String hostPort = host.get(<span class="hljs-string">&quot;port&quot;</span>);<br>        String status = ServiceStatusEnum.RUNNING.getName();<br>        <span class="hljs-keyword">try</span>(Jedis masterLive = <span class="hljs-keyword">new</span> Jedis(hostIp, Integer.parseInt(hostPort)))&#123;<br>            masterLive.auth(password);<br>        &#125;<span class="hljs-keyword">catch</span> (JedisException e)&#123;<br>            status = ServiceStatusEnum.STOPPED.getName();<br>        &#125;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>代码优化总结：</p>
<ol>
<li>公共模块提取成一个方法。</li>
<li>超过三次使用的值，需要设置为一个常量（private final …），如果在多个文件中使用到了的话，就放到常量接口中。</li>
<li>注意代码性能，减少for，判断条件优化</li>
<li>注意代码层次结构</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>代码托管工具：Git</title>
    <url>/2021/10/20/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B7%A5%E5%85%B7%EF%BC%9AGit/</url>
    <content><![CDATA[<p><em>Git</em>（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。在团队协作开发中起到了十分重要的作用。</p>
<span id="more"></span>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111133705830.png" alt="image-20211111133705830"></p>
<h2 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1. 版本控制"></a>1. 版本控制</h2><h3 id="1-1-版本控制工具应该具备的功能"><a href="#1-1-版本控制工具应该具备的功能" class="headerlink" title="1.1 版本控制工具应该具备的功能"></a>1.1 版本控制工具应该具备的功能</h3><ul>
<li>协同修改：多个人并行的修改服务器的同一个文件。</li>
<li>数据备份：不仅保存目录和文件的当前状态，还能够保存每一个提交的历史状态。</li>
<li>版本控制：每次只保存修改的数据，不保存重复数据。Git采用文件系统快照的方式进行保存。</li>
<li>权限控制：对团队中的不同人员拥有不同的权限；对团队之外的开发者提供的代码进行审核。</li>
<li>历史记录。</li>
<li>分支管理：允许开发团队在工作工程中多分支同时进行工作。</li>
</ul>
<h3 id="1-2-版本控制介绍"><a href="#1-2-版本控制介绍" class="headerlink" title="1.2 版本控制介绍"></a>1.2 版本控制介绍</h3><p>版本控制工具：</p>
<ul>
<li>集中式版本控制工具：SVN。存在单点故障的问题。</li>
<li>分布式版本控制工具：Git。<strong>可以避免单点故障。</strong></li>
</ul>
<h2 id="2-Git简介"><a href="#2-Git简介" class="headerlink" title="2 .Git简介"></a>2 .Git简介</h2><h3 id="2-1-Git的优势"><a href="#2-1-Git的优势" class="headerlink" title="2.1 Git的优势"></a>2.1 Git的优势</h3><ul>
<li>大部分操作都在本地运行，不需要联网。</li>
<li>保证完整性（通过Hash值）。</li>
<li>尽可能的添加数据，而不是删除或修改数据。</li>
<li>分支操作非常快捷流畅（内部通过快照操作）。</li>
<li>与Linux命令全面兼容。</li>
</ul>
<h3 id="2-2-Git的结构"><a href="#2-2-Git的结构" class="headerlink" title="2.2 Git的结构"></a>2.2 Git的结构</h3><p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111140409757.png" alt="image-20211111140409757"></p>
<h3 id="2-3-Git和代码托管中心"><a href="#2-3-Git和代码托管中心" class="headerlink" title="2.3 Git和代码托管中心"></a>2.3 Git和代码托管中心</h3><p>远程托管代码，将代码保存到远程库中。</p>
<p>局域网：GitLab</p>
<p>外网环境：GitHub，码云</p>
<h3 id="2-4-本地库和远程库"><a href="#2-4-本地库和远程库" class="headerlink" title="2.4 本地库和远程库"></a>2.4 本地库和远程库</h3><p>团队内协作：</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111141146749.png" alt="image-20211111141146749"></p>
<p>团队外协作：</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111141435649.png" alt="image-20211111141435649"></p>
<h3 id="2-5-Git的基本操作"><a href="#2-5-Git的基本操作" class="headerlink" title="2.5 Git的基本操作"></a>2.5 Git的基本操作</h3><h4 id="2-5-1-本地库初始化："><a href="#2-5-1-本地库初始化：" class="headerlink" title="2.5.1.本地库初始化："></a>2.5.1.本地库初始化：</h4><ul>
<li>命令：git init</li>
<li>效果：</li>
</ul>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111142745692.png" alt="image-20211111142745692"></p>
<ul>
<li>注意：.git/文件中存放的是本地库相关的子目录和文件，不要删除和修改。</li>
</ul>
<h4 id="2-5-2-设置签名"><a href="#2-5-2-设置签名" class="headerlink" title="2.5.2.设置签名"></a>2.5.2.设置签名</h4><ul>
<li><p>形式：</p>
<p>用户名：liwenkai</p>
<p>email地址：<a href="mailto:&#108;&#105;&#x31;&#55;&#x36;&#54;&#57;&#x34;&#x39;&#x38;&#x33;&#54;&#x34;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#111;&#x6d;">&#108;&#105;&#x31;&#55;&#x36;&#54;&#57;&#x34;&#x39;&#x38;&#x33;&#54;&#x34;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#111;&#x6d;</a></p>
</li>
<li><p>作用：区分不同的开发人员的身份。</p>
</li>
</ul>
<p>辨析：这里设置的签名和代码托管中心的账号密码没有任何关系。 </p>
<ul>
<li><p>命令（优先级：就近原则，二者都有，采用项目级别）：</p>
<ul>
<li>项目级别：仅在当前本地库范围内有效。<ul>
<li> git config user.name liwenkai       </li>
<li> git config user.email   <a href="mailto:&#x6c;&#x69;&#49;&#55;&#54;&#54;&#x39;&#52;&#57;&#56;&#x33;&#x36;&#x34;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;">&#x6c;&#x69;&#49;&#55;&#54;&#54;&#x39;&#52;&#57;&#56;&#x33;&#x36;&#x34;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;</a></li>
<li> 项目保存的位置：./.git/config</li>
<li> <img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111150801163.png" alt="image-20211111150801163"></li>
</ul>
</li>
<li>系统用户级别：登录等钱操作系统的用户范围。git config –global<ul>
<li> git config <strong>–global</strong> user.name liwenkai       </li>
<li> git config <strong>–global</strong> user.email   <a href="mailto:&#108;&#105;&#x31;&#x37;&#54;&#x36;&#57;&#x34;&#x39;&#x38;&#x33;&#x36;&#52;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;">&#108;&#105;&#x31;&#x37;&#54;&#x36;&#57;&#x34;&#x39;&#x38;&#x33;&#x36;&#52;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></li>
<li> 信息保存的位置：~/.gitconfig文件下</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111151240376.png" alt="image-20211111151240376"></p>
</li>
</ul>
<h4 id="2-5-3-查看状态"><a href="#2-5-3-查看状态" class="headerlink" title="2.5.3.查看状态"></a>2.5.3.查看状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git status<br></code></pre></td></tr></table></figure>

<p>此时暂存区与本地库中都没有文件：</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111164356213.png" alt="image-20211111164356213"></p>
<h4 id="2-5-4-提交文件到暂存区"><a href="#2-5-4-提交文件到暂存区" class="headerlink" title="2.5.4.提交文件到暂存区"></a>2.5.4.提交文件到暂存区</h4><p>创造了一个文件（vim good.txt）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">vim good.txt<br><br>:wq<br></code></pre></td></tr></table></figure>



<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111164720978.png" alt="image-20211111164720978"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git add good.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111165023182.png" alt="image-20211111165023182"></p>
<p>提交完成后再查看状态：</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111165150226.png" alt="image-20211111165150226"></p>
<p>从<strong>缓存区</strong>移除文件,工作区的文件不变：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git rm --cached good.txt<br></code></pre></td></tr></table></figure>



<h4 id="2-5-5-提交文件到本地库"><a href="#2-5-5-提交文件到本地库" class="headerlink" title="2.5.5.提交文件到本地库"></a>2.5.5.提交文件到本地库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git commit good.txt<br></code></pre></td></tr></table></figure>

<p>给本次提交添加注释（vim操作）：</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111165723660.png" alt=":"></p>
<p>如果不行进入vim页面，可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git commit -m &quot;my second commit,nodify good.txt&quot;<br></code></pre></td></tr></table></figure>



<p>添加成功之后：</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111170126999.png" alt="image-20211111170126999"></p>
<p>使用cat查看文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">cat good.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111170315749.png" alt="image-20211111170315749"></p>
<p>查看状态：</p>
<p>暂存区为空，工作树也是干净的。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111170359958.png" alt="image-20211111170359958"></p>
<p>如果修改了good.txt文件，需要重新执行add和commit操作。</p>
<h4 id="2-5-6实现版本前进与后退"><a href="#2-5-6实现版本前进与后退" class="headerlink" title="2.5.6实现版本前进与后退"></a>2.5.6实现版本前进与后退</h4><p><strong>1.查看版本信息</strong></p>
<p>查看提交记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git log<br>多屏显示时的控制方法：<br>空格向上翻页，<br>b向下翻页<br>q退出<br></code></pre></td></tr></table></figure>

<p>HEAD表示指针，指向当前版本。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111171754150.png" alt="image-20211111171754150"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">以一行的形式显示：git log --pretty=oneline或者git log --oneline<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111172348711.png" alt="image-20211111172348711"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">HEAD@&#123;移动到当前版本需要多少步&#125;：git reflog<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111172548154.png" alt="image-20211111172548154"></p>
<p><strong>2.基于索引值前进后退【推荐使用】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git reset --hard=索引值需要提前知道前进版本的索引值，配合git reflog命令使用<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111202713257.png" alt="image-20211111202713257"></p>
<p><strong>3.使用^符号【只能后退】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git reset --hard HEAD^一个^符号退一步，想要后退几步就在后面加几个^<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111203035570.png" alt="image-20211111203035570"></p>
<p>==显示文件的后n行==</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">显示文件后两行$ tail -n 2 good.txt全部显示文件$ cat good.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111203311151.png" alt="image-20211111203311151"></p>
<p><strong>4.使用~符号【只能后退】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">后退n步git reset --hard HEAD~n<br></code></pre></td></tr></table></figure>



<h4 id="2-5-7-reset命令的三分参数比较"><a href="#2-5-7-reset命令的三分参数比较" class="headerlink" title="2.5.7 reset命令的三分参数比较"></a>2.5.7 reset命令的三分参数比较</h4><ul>
<li>–soft参数<ul>
<li>仅在本地库移动HEAD指针</li>
<li><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111204703204.png" alt="image-20211111204703204"></li>
</ul>
</li>
<li>–mixed参数<ul>
<li>在本地库移动HEAD指针</li>
<li>重置暂存区</li>
<li><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111204724633.png" alt="image-20211111204724633"></li>
</ul>
</li>
<li>–hard参数<ul>
<li>在本地库移动HEAD指针</li>
<li>重置暂存区</li>
<li>重置工作区</li>
<li><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111204741594.png" alt="image-20211111204741594"></li>
</ul>
</li>
</ul>
<h4 id="2-5-8-删除文件后找回"><a href="#2-5-8-删除文件后找回" class="headerlink" title="2.5.8 删除文件后找回"></a>2.5.8 删除文件后找回</h4><p>前提：删除前，文件存在时的状态提交到本地</p>
<p><strong>1.方式一：回退到之前的版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git reset --hard 索引值<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111210120060.png" alt="image-20211111210120060"></p>
<p><strong>2.方式二：将添加到暂存区的文件找回</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git reset --head HEAD<br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>删除操作已经提交到本地库：指针位置指向索引值</li>
<li>未提交到本地库：指针位置使用HEAD</li>
</ul>
<h4 id="2-5-9-比较文件"><a href="#2-5-9-比较文件" class="headerlink" title="2.5.9 比较文件"></a>2.5.9 比较文件</h4><p>比较文件是否发生了修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git diff apple.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111211416299.png" alt="image-20211111211416299"></p>
<p>比较已经提交到暂存区的文件发生了那些修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git diff HEAD apple.txt<br></code></pre></td></tr></table></figure>



<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111211601887.png" alt="image-20211111211601887"></p>
<p>不指定文件名时，会比较工作区中的所有的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git diff HEAD<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111211859857.png" alt="image-20211111211859857"></p>
<h3 id="2-6-分支管理"><a href="#2-6-分支管理" class="headerlink" title="2.6 分支管理"></a>2.6 分支管理</h3><h4 id="2-6-1-什么是分支"><a href="#2-6-1-什么是分支" class="headerlink" title="2.6.1 什么是分支"></a>2.6.1 什么是分支</h4><p>在版本控制的过程中，使用多条线同时推进。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111212639622.png" alt="image-20211111212639622"></p>
<h4 id="2-6-2-分支的好处"><a href="#2-6-2-分支的好处" class="headerlink" title="2.6.2 分支的好处"></a>2.6.2 分支的好处</h4><ul>
<li>同时并行推进多个功能开发，提高工作效率。</li>
<li>各个分支在开发过程中，如果某一个分支开发失败了，不会对其他分支有任何的影响。失败的分支删除重新开始既可。</li>
</ul>
<h4 id="2-6-3-分支操作"><a href="#2-6-3-分支操作" class="headerlink" title="2.6.3 分支操作"></a>2.6.3 分支操作</h4><h5 id="1-查看拥有的所有分支"><a href="#1-查看拥有的所有分支" class="headerlink" title="1.查看拥有的所有分支"></a>1.查看拥有的所有分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git branch -v<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111213147745.png" alt="image-20211111213147745"></p>
<h5 id="2-创建分支"><a href="#2-创建分支" class="headerlink" title="2.创建分支"></a>2.创建分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">创建一个名字叫hot_fix的分支$ git branch [分支名]<br></code></pre></td></tr></table></figure>



<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111213428937.png" alt="image-20211111213428937"></p>
<h5 id="3-切换分支"><a href="#3-切换分支" class="headerlink" title="3.切换分支"></a>3.切换分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git checkout [分支名]<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111213552432.png" alt="image-20211111213552432"></p>
<h5 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4.合并分支"></a>4.合并分支</h5><ul>
<li><p>第一步：切换到接收修改的分支上</p>
<ul>
<li><p>~~~git<br>$ git checkout [被合并分支名]</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><code class="hljs cos"><br>- 第二步：使用<span class="hljs-keyword">merge</span>命令进行合并<br><br>  - ~~~git<br>    $ git <span class="hljs-keyword">merge</span> [有新内容的分支]<br></code></pre></td></tr></table></figure></li>
<li><p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111214630265.png" alt="image-20211111214630265"></p>
</li>
</ul>
</li>
</ul>
<h5 id="5-解决冲突"><a href="#5-解决冲突" class="headerlink" title="5 解决冲突"></a>5 解决冲突</h5><ul>
<li><p>冲突的表现：两个分支同时修改了同一个文件同一行中的数据。git不知道以哪一个为准。</p>
<ul>
<li><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111220459875.png" alt="image-20211111220459875"></li>
<li><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111220530944.png" alt="image-20211111220530944"></li>
</ul>
</li>
<li><p>冲突解决：</p>
<ul>
<li>第一步：编辑文件，删除特殊符号。</li>
<li>第二步：把文件修改到满意的程度，保存退出。</li>
<li><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211111220707665.png" alt="image-20211111220707665"></li>
<li>第三步：add，commit（此时commit一定不能带具体的文件名）</li>
</ul>
</li>
</ul>
<h2 id="3-Git原理"><a href="#3-Git原理" class="headerlink" title="3. Git原理"></a>3. Git原理</h2><h3 id="3-1-Hash"><a href="#3-1-Hash" class="headerlink" title="3.1 Hash"></a>3.1 Hash</h3><p>是一种加密算法。</p>
<p>Hash算法的特性：</p>
<ul>
<li>加密结果长度是一定的，都是16位。</li>
<li>Hash算法一致，输入一致，输出一定一样。</li>
<li>Hash算法一致，输入不一致，输出会发生很大的变化。</li>
<li>Hash算法是不可逆的。</li>
</ul>
<p>Git底层使用的是：SHA-1算法。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112100441920.png" alt="image-20211112100441920"></p>
<h3 id="3-2-Git保存版本的机制"><a href="#3-2-Git保存版本的机制" class="headerlink" title="3.2 Git保存版本的机制"></a>3.2 Git保存版本的机制</h3><p>SVN的保存机制：增量式版本控制</p>
<p>优点：节省空间</p>
<p>Git：快照流。没有修改的文件通过指针指向上个版本中的文件。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112112246132.png" alt="image-20211112112246132"></p>
<h3 id="3-3-Git分支管理机制"><a href="#3-3-Git分支管理机制" class="headerlink" title="3.3 Git分支管理机制"></a>3.3 Git分支管理机制</h3><p><strong>1.创建分支</strong></p>
<p>创建一个分支指向已有的版本。而不是把原来的复制一遍</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112112938429.png" alt="image-20211112112938429"></p>
<p><strong>2.分支切换</strong></p>
<p>HEAD指针指向testing指针。</p>
<p>通过简单地移动指针就可以切换分支。十分方便。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112113102856.png" alt="image-20211112113102856"></p>
<p><strong>3.修改数据</strong></p>
<p>当分支对文佳进行修改时，就会创造一个新的分支。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112113310025.png" alt="image-20211112113310025"></p>
<h2 id="4-GitHub相关"><a href="#4-GitHub相关" class="headerlink" title="4.GitHub相关"></a>4.GitHub相关</h2><p>账号注册：</p>
<ul>
<li>email：<a href="mailto:&#x33;&#50;&#57;&#x31;&#50;&#x39;&#x38;&#54;&#54;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#109;">&#x33;&#50;&#57;&#x31;&#50;&#x39;&#x38;&#54;&#54;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#109;</a></li>
<li>用户名：WenkAndZz</li>
</ul>
<h3 id="4-1创建本地库与远程库"><a href="#4-1创建本地库与远程库" class="headerlink" title="4.1创建本地库与远程库"></a>4.1创建本地库与远程库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">创建本地库文件夹<br>mkdir [文件名]<br><br>进入本地库<br>cd [文件名]<br><br>初始化<br>git init<br><br>创建一个txt文件<br>vim [txt文件名].txt<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112120434326.png" alt="image-20211112120434326"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">创建远程库在GitHub上，选择repository<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112161451631.png" alt="image-20211112161451631"></p>
<p>创建完成之后，有一个HTTPS的地址</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112161645184.png" alt="image-20211112161645184"></p>
<h3 id="4-2在本地创建远程仓库别名"><a href="#4-2在本地创建远程仓库别名" class="headerlink" title="4.2在本地创建远程仓库别名"></a>4.2在本地创建远程仓库别名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">创建别名，origin别名，后面是地址<br>$ git remote add origin https://github.com/WenkAndZz/huashan.git<br><br>查看历史数据<br>$ git remote -v<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112162053144.png" alt="image-20211112162053144"></p>
<h3 id="4-3-推送数据"><a href="#4-3-推送数据" class="headerlink" title="4.3 推送数据"></a>4.3 推送数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">推送数据<br>$ git push [远程仓库别名] [分支名]<br>$ git push origin master<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112170659548.png" alt="image-20211112170659548"></p>
<p>注：GitHub是一个国外网站，访问很慢。可以使用<strong>码云</strong>。</p>
<h3 id="4-4-克隆操作"><a href="#4-4-克隆操作" class="headerlink" title="4.4 克隆操作"></a>4.4 克隆操作</h3><p>更换目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ cd ..<br>$ mkdir huashan_linghuchong<br>$ cd huashan_linghuchong<br></code></pre></td></tr></table></figure>

<p><strong>执行克隆操作：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git clone https://gitee.com/wenkailllll/huashan.git<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112171321540.png" alt="image-20211112171321540"></p>
<p>克隆有三个效果：</p>
<ul>
<li>完整的把远程库下载到本地。</li>
<li>创建origin远程地址别名。</li>
<li>初始化本地库。</li>
</ul>
<h3 id="4-5-从远程库拉取"><a href="#4-5-从远程库拉取" class="headerlink" title="4.5 从远程库拉取"></a>4.5 从远程库拉取</h3><p><strong>方法一：fetch(拉取)+merge(合并)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">从远程库中拉取数据$ git fetch origin master此时本地库中的数据没有发生改变，远程库中的数据保存在origin/master中<br></code></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">将本地的master跟远程库下载下来的进行合并$ git merge origin/master合并之后master中的数据就与远程库一致了<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112173104034.png" alt="image-20211112173104034"></p>
<p><strong>方法二：pull=fetch(拉取)+merge(合并)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git pull origin master<br></code></pre></td></tr></table></figure>



<h3 id="4-6协同合作时冲突的解决"><a href="#4-6协同合作时冲突的解决" class="headerlink" title="4.6协同合作时冲突的解决"></a>4.6协同合作时冲突的解决</h3><ul>
<li>要点：<ul>
<li>如果不是基于GitHub远程库的最新版所做的修改，必须先拉取（pull）。</li>
<li>拉取下来之后按照”分支冲突解决“操作解决既可。</li>
</ul>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">1.先拉取，使当前变为最新版。<br>git pull [远程库] [分支名]<br>此时冲突文件会被合并。<br><br>2.vim到冲突文件中，对冲突文件进行修改。<br>vim [冲突文件]<br><br>3.修改后再添加到暂存区<br>git add [冲突文件]<br><br>4.提交到本地库中。<br>git commit [冲突文件]<br><br>5.推送到远程仓库中<br>git push [远程库] [分支名]<br></code></pre></td></tr></table></figure>

<h3 id="4-7跨团队协作"><a href="#4-7跨团队协作" class="headerlink" title="4.7跨团队协作"></a>4.7跨团队协作</h3><ol>
<li>Fork项目</li>
<li>克隆到本地 git clone</li>
<li>修改后提交 git push</li>
<li>在GitHub网页上有个push requests</li>
<li>本团队对这个request进行审核。审核成功就可以合并（merge）</li>
</ol>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112214534482.png" alt="image-20211112214534482"></p>
<h3 id="4-8-SSH免密登录"><a href="#4-8-SSH免密登录" class="headerlink" title="4.8 SSH免密登录"></a>4.8 SSH免密登录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">1.切换到根目录下：cd ~<br><br>2.删除.ssh文件rm -r .shh/<br><br>3.给当前邮箱号设置一个ssh加密<br>$ ssh-keygen -t rsa -C 329129866@qq.com<br><br>4.去.ssh/文件下，赋值id_rsa.pub中的内容$ cd .ssh/<br><br>5.打开GitHub，在设置中找到ssh秘钥，把复制的内容添加到这里。<br></code></pre></td></tr></table></figure>



<p>使用的时候，要使用ssh地址，才能免密登录。</p>
<p><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/image-20211112220837890.png" alt="image-20211112220837890"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">1.给远程仓库的ssh地址设置一个别名<br>git remote add origin_ssh git@gitee.com:wenkailllll/huashan.git<br><br>2.使用ssh去push文件<br>git push origin_ssh master<br></code></pre></td></tr></table></figure>



<h2 id="5-hexo-推送博客"><a href="#5-hexo-推送博客" class="headerlink" title="5.hexo 推送博客"></a>5.hexo 推送博客</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">//创建博客,创建完成的博客在E:\Blog\source\_posts目录下<br>hexo new &quot;博客名&quot;<br><br>//清除网页中的缓存<br>hexo clean<br><br>//生成静态网页<br>hexo g<br><br>//开始部署<br>hexo d<br></code></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>仿牛客网论坛网站项目</title>
    <url>/2021/10/01/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%BA%E5%9D%9B%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>仿照牛客网做一个论坛网站系统。</p>
<p>技术栈：SpringBoot+Mybatis+MySQL+Redis+swagger+kafka</p>
<span id="more"></span>

<h1 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h1><h2 id="编写主页后台控制代码。"><a href="#编写主页后台控制代码。" class="headerlink" title="编写主页后台控制代码。"></a>编写主页后台控制代码。</h2><p>要求在主页中显示10条数据</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211201202816212.png" alt="image-20211201202816212"></p>
<h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><h3 id="封装分页功能到分页类中。"><a href="#封装分页功能到分页类中。" class="headerlink" title="封装分页功能到分页类中。"></a>封装分页功能到分页类中。</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.community.entity;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装分页相关的信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> </span>&#123;<br>    <span class="hljs-comment">//当前页码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> current = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//显示上限；</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//数据总数（用于计算总的页数）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rows;<br>    <span class="hljs-comment">//查询路径（复用分页的链接）</span><br>    <span class="hljs-keyword">private</span> String path;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCurrent</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> current;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCurrent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> current)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (current&gt;=<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">this</span>.current = current;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLimit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> limit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (limit&gt;=<span class="hljs-number">1</span> &amp;&amp; limit&lt;=<span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">this</span>.limit = limit;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRows</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> rows;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (rows&gt;=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.rows = rows;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPath</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.path = path;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前页的起始行。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOffset</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (current - <span class="hljs-number">1</span>) * limit;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取总页数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTotal</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// rows/limit</span><br>        <span class="hljs-keyword">if</span> (rows % limit == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> rows / limit;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> rows / limit + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 獲取起始頁碼</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFrom</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> from = current - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> from &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : from;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取终止页码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTo</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> to = current + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> total = getTotal();<br>        <span class="hljs-keyword">return</span> to &gt; total ? total : to;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="在控制器中调用分页类。"><a href="#在控制器中调用分页类。" class="headerlink" title="在控制器中调用分页类。"></a>在控制器中调用分页类。</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/index&quot;,method = RequestMethod.GET)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">(Model model, Page page)</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;************************************&quot;</span>);<br>       <span class="hljs-comment">//设置分页对象。</span><br>       <span class="hljs-comment">//方法调用之前，springMVC会自动实例化model和page，并将page注入到model中，</span><br>       <span class="hljs-comment">// 所以thymeleaf可以直接访问page对象中的数据</span><br>       page.setRows(discussPostService.selectDiscussPostRows(<span class="hljs-number">0</span>));<br>       page.setPath(<span class="hljs-string">&quot;/index&quot;</span>);<br><br>       <span class="hljs-comment">//查询到的数据中有一个userId，要根据这个userId找到这个用户，然后再返回到前端页面。</span><br>       List&lt;DiscussPost&gt; list = discussPostService.selectDiscussPosts(<span class="hljs-number">0</span>, page.getOffset(), page.getLimit());<br>       List&lt;Map&lt;String,Object&gt;&gt; discussPosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>       <span class="hljs-keyword">if</span> (list!=<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">for</span> (DiscussPost post:list) &#123;<br>               Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>               map.put(<span class="hljs-string">&quot;post&quot;</span>,post);<br>               User user = userService.selectById(post.getUserId());<br>               map.put(<span class="hljs-string">&quot;user&quot;</span>,user);<br>               discussPosts.add(map);<br>           &#125;<br>       &#125;<br>       model.addAttribute(<span class="hljs-string">&quot;discussPosts&quot;</span>,discussPosts);<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="前端页面通过thymeleaf编码风格显示"><a href="#前端页面通过thymeleaf编码风格显示" class="headerlink" title="前端页面通过thymeleaf编码风格显示"></a>前端页面通过thymeleaf编码风格显示</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 分页 --&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mt-5&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;page.rows&gt;0&#125;&quot;</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagination justify-content-center&quot;</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-item&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-link&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;page.path&#125;(current=1)&#125;&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;|page-item $&#123;page.current==1?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-link&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current - 1&#125;)&#125;&quot;</span>&gt;</span>上一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br>						<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;|page-item $&#123;i==page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot;</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;i:$&#123;#numbers.sequence(page.from,page.to)&#125;&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-link&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;i&#125;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br>						<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;|page-item $&#123;page.current==page.total?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-link&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;&quot;</span>&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-item&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-link&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;&quot;</span>&gt;</span>末页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h1 id="登录注册模块设计"><a href="#登录注册模块设计" class="headerlink" title="登录注册模块设计"></a>登录注册模块设计</h1><h2 id="发送验证邮件"><a href="#发送验证邮件" class="headerlink" title="发送验证邮件"></a>发送验证邮件</h2><h3 id="编写邮件工具类。"><a href="#编写邮件工具类。" class="headerlink" title="编写邮件工具类。"></a>编写邮件工具类。</h3><p>核心组件是==JavaMailSender==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.community.util;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.mail.javamail.JavaMailSender;<br><span class="hljs-keyword">import</span> org.springframework.mail.javamail.MimeMessageHelper;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.thymeleaf.TemplateEngine;<br><br><span class="hljs-keyword">import</span> javax.mail.MessagingException;<br><span class="hljs-keyword">import</span> javax.mail.internet.MimeMessage;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(MailClient.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JavaMailSender mailSender;<br><br><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String from;            <span class="hljs-comment">//发送人</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMail</span><span class="hljs-params">(String to,String subject,String context)</span></span>&#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            MimeMessage message = mailSender.createMimeMessage();<br>            MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(message);<br>            helper.setFrom(from);     <span class="hljs-comment">//发送人</span><br>            helper.setTo(to);         <span class="hljs-comment">//收件人</span><br>            helper.setSubject(subject);      <span class="hljs-comment">//主题</span><br>            helper.setText(context,<span class="hljs-keyword">true</span>);           <span class="hljs-comment">//内容，第二个参数表示允许支持html</span><br>            mailSender.send(helper.getMimeMessage());    <span class="hljs-comment">//发送</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (MessagingException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;邮件发送失败&quot;</span>+e.getMessage());<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.community.util;<br><br><span class="hljs-keyword">import</span> com.kai.SpringbootNewCoderApplication;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.thymeleaf.TemplateEngine;<br><span class="hljs-keyword">import</span> org.thymeleaf.context.Context;<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.jupiter.api.Assertions.*;<br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@ContextConfiguration(classes = SpringbootNewCoderApplication.class)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailClientTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MailClient mailClient;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTextMail</span><span class="hljs-params">()</span></span>&#123;<br>        mailClient.sendMail(<span class="hljs-string">&quot;329129866@qq.com&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="通过thymeleaf编码风格发送HTML邮件"><a href="#通过thymeleaf编码风格发送HTML邮件" class="headerlink" title="通过thymeleaf编码风格发送HTML邮件"></a>通过thymeleaf编码风格发送HTML邮件</h3><p>注册邮件demo页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>邮件示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欢迎你，<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过thymeleaf模板引擎（TemplateEngine），将后台的数据传递到邮件demo页面，动态组装之后，通过HTML邮件的方式进行发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.community.util;<br><br><span class="hljs-keyword">import</span> com.kai.SpringbootNewCoderApplication;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.thymeleaf.TemplateEngine;<br><span class="hljs-keyword">import</span> org.thymeleaf.context.Context;<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.jupiter.api.Assertions.*;<br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@ContextConfiguration(classes = SpringbootNewCoderApplication.class)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailClientTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MailClient mailClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TemplateEngine templateEngine;     <span class="hljs-comment">//自动注入模板引擎。这里是因为运行之后他才能自动注入</span><br>    <br>    <span class="hljs-comment">//发送邮件功能简单实现</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTextMail</span><span class="hljs-params">()</span></span>&#123;<br>        mailClient.sendMail(<span class="hljs-string">&quot;329129866@qq.com&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//通过thymeleaf发送HTML邮件</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHtmlMail</span><span class="hljs-params">()</span></span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        context.setVariable(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;sunday&quot;</span>);<br>        <span class="hljs-comment">//模板引擎，将username传递到页面中，然后以HTML网页的形式发送邮件。</span><br>        String content = templateEngine.process(<span class="hljs-string">&quot;/mail/demo&quot;</span>,context);<br>        System.out.println(content);<br>        <span class="hljs-comment">//发送邮件</span><br>        mailClient.sendMail(<span class="hljs-string">&quot;329129866@qq.com&quot;</span>,<span class="hljs-string">&quot;HTML&quot;</span>,content);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="开发注册功能"><a href="#开发注册功能" class="headerlink" title="开发注册功能"></a>开发注册功能</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211201202922628.png" alt="image-20211201202922628"></p>
<h3 id="访问注册页面"><a href="#访问注册页面" class="headerlink" title="访问注册页面"></a>访问注册页面</h3><p>点击主页上面的注册按钮，跳转到注册页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 访问注册页面</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@RequestMapping(path = &quot;/register&quot;,method = RequestMethod.GET)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRegisterPage</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/register&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="提交注册数据"><a href="#提交注册数据" class="headerlink" title="提交注册数据"></a>提交注册数据</h3><p>通过表单往后台提交数据，通过post方法提交</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mt-5&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/register&#125;&quot;</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group row&quot;</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-2 col-form-label text-right&quot;</span>&gt;</span>账号:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;user!=null?user.username:&#x27;&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入您的账号!&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;invalid-feedback&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;usernameMsg&#125;&quot;</span>&gt;</span><br>								该账号已存在!<br>							<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group row mt-4&quot;</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-2 col-form-label text-right&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;|form-control $&#123;passwordMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;user!=null?user.password:&#x27;&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入您的密码!&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;invalid-feedback&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;passwordMsg&#125;&quot;</span>&gt;</span><br>								密码长度不能小于8位!<br>							<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>							<br>						<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group row mt-4&quot;</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;confirm-password&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-2 col-form-label text-right&quot;</span>&gt;</span>确认密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;confirm-password&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;user!=null?user.password:&#x27;&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请再次输入密码!&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;invalid-feedback&quot;</span>&gt;</span><br>								两次输入的密码不一致!<br>							<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group row&quot;</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-2 col-form-label text-right&quot;</span>&gt;</span>邮箱:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;|form-control $&#123;emailMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;user!=null?user.email:&#x27;&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">								   <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入您的邮箱!&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;invalid-feedback&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;emailMsg&#125;&quot;</span>&gt;</span><br>								该邮箱已注册!<br>							<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group row mt-4&quot;</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-10 text-center&quot;</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-info text-white form-control&quot;</span>&gt;</span>立即注册<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>代码解读：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs HTML">||中第一个块必须执行，然后后面的根据判断条件执行<br>th:class=&quot;|form-control $&#123;emailMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot;<br><br>usernameMsg是后台往前传递的数据，里面存储了关于username的异常因信息<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;invalid-feedback&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;usernameMsg&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>





<p>==验证用户信息==</p>
<p>service层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">//空值处理</span><br>        <span class="hljs-keyword">if</span> (user==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数不允许为空！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getUsername()))&#123;<br>            map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;账号不能为空！&quot;</span>);<br>            <span class="hljs-keyword">return</span> map;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getPassword()))&#123;<br>            map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不能为空！&quot;</span>);<br>            <span class="hljs-keyword">return</span> map;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(user.getEmail()))&#123;<br>            map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;邮箱不能为空！&quot;</span>);<br>            <span class="hljs-keyword">return</span> map;<br>        &#125;<br>        <span class="hljs-comment">//验证邮箱</span><br>        User u = userDao.selectByName(user.getUsername());<br>        <span class="hljs-keyword">if</span> (u != <span class="hljs-keyword">null</span>)&#123;<br>            map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;该用户已存在！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//验证账号</span><br>        u = userDao.selectByEmail(user.getEmail());<br>        <span class="hljs-keyword">if</span> (u != <span class="hljs-keyword">null</span>)&#123;<br>            map.put(<span class="hljs-string">&quot;emailMsg&quot;</span>,<span class="hljs-string">&quot;该邮箱已被注册！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 注册新用户</span><br><span class="hljs-comment">         * Salt:随机字符串</span><br><span class="hljs-comment">         * password:密码</span><br><span class="hljs-comment">         * activationCode:激活码</span><br><span class="hljs-comment">         */</span><br>        user.setSalt(CommunityUtil.generateUUID().substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));<br>        user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));<br>        user.setType(<span class="hljs-number">0</span>);<br>        user.setStatus(<span class="hljs-number">0</span>);<br>        user.setActivationCode(CommunityUtil.generateUUID());<br>        user.setHeaderUrl(String.format(<span class="hljs-string">&quot;http://images.nowcoder.com/head/%dt.png&quot;</span>,<br>                <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>)));<br>        user.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>        userDao.insertUser(user);<br><br>        <span class="hljs-comment">//激活邮件</span><br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        context.setVariable(<span class="hljs-string">&quot;email&quot;</span>,user.getEmail());<br>        <span class="hljs-comment">//拼接激活地址：http://localhost:8080/community/activation/101/code</span><br>        String url = domain + contextPath + <span class="hljs-string">&quot;/activation/&quot;</span> +<br>                user.getId() + <span class="hljs-string">&quot;/&quot;</span> + user.getActivationCode();<br>        context.setVariable(<span class="hljs-string">&quot;url&quot;</span>,url);<br>        String content = templateEngine.process(<span class="hljs-string">&quot;/mail/activation&quot;</span>,context);<br>        mailClient.sendMail(user.getEmail(),<span class="hljs-string">&quot;激活邮件&quot;</span>,content);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果填写的用户信息正确，就给用户发送一封激活邮件（thymeleaf发送HTML邮件）。</p>
<h5 id="加密操作："><a href="#加密操作：" class="headerlink" title="加密操作："></a>加密操作：</h5><p>使用MD5进行加密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommunityUtil</span> </span>&#123;<br>    <span class="hljs-comment">//生成随机字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">generateUUID</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//s随机生成的字符串是由字母和‘-’生成的，我们不想要‘-’，使用空字符串进行替换</span><br>        <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//MD5加密</span><br>    <span class="hljs-comment">//只能加密，但是不能解密</span><br>    <span class="hljs-comment">//MD5进行加密是，加密之后的结果是一样的，我们通过使用在 原字符串后+随机字符串 的方式进行加密。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(key))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//加密成16位的字符串。输入要求是byte。</span><br>        <span class="hljs-keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes(StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<p>==发送邮件成功，跳转到已发送邮件页面==</p>
<p>控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/register&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">register</span><span class="hljs-params">(Model model, User user)</span></span>&#123;<br>        Map&lt;String, Object&gt; map = userService.register(user);<br>        <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map.isEmpty())&#123;<br>            model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;注册成功，我们已经向您发送了一封激活邮件，请尽快激活！&quot;</span>);<br>            model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);<br>            <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;/site/operate-result&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            model.addAttribute(<span class="hljs-string">&quot;usernameMsg&quot;</span>,map.get(<span class="hljs-string">&quot;usernameMsg&quot;</span>));<br>            model.addAttribute(<span class="hljs-string">&quot;emailMsg&quot;</span>,map.get(<span class="hljs-string">&quot;emailMsg&quot;</span>));<br>            model.addAttribute(<span class="hljs-string">&quot;passwordMsg&quot;</span>,map.get(<span class="hljs-string">&quot;passwordMsg&quot;</span>));<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/register&quot;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="用户激活"><a href="#用户激活" class="headerlink" title="用户激活"></a>用户激活</h3><p>点击邮箱里面的链接，自动跳转到注册页面，如果重复点击，会出现已经注册过了的提示。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210901192728014.png" alt="image-20210901192728014"></p>
<p>service层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过邮箱里面的激活链接点击激活</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">activation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId,String code)</span></span>&#123;<br>        User user = userDao.selectById(userId);<br>        <span class="hljs-keyword">if</span> (user.getStatus() == <span class="hljs-number">1</span>)&#123;     <span class="hljs-comment">//status初始化为0，等于1说明已经激活</span><br>            <span class="hljs-keyword">return</span> ACTIVATION_REPEAT;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user.getActivationCode().equals(code))&#123;     <span class="hljs-comment">//激活</span><br>            userDao.updateStatus(userId,<span class="hljs-number">1</span>);      <span class="hljs-comment">//更新用户的状态。</span><br>            <span class="hljs-keyword">return</span> ACTIVATION_SUCCESS;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> ACTIVATION_FAILURE;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 访问激活地址：http://localhost:8080/community/activation/101/code</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;activation/&#123;userId&#125;/&#123;code&#125;&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">activation</span><span class="hljs-params">(Model model, <span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-meta">@PathVariable(&quot;code&quot;)</span> String code)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> result = userService.activation(userId,code);<br>        <span class="hljs-keyword">if</span> (result == ACTIVATION_SUCCESS)&#123;<br>            model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;激活成功，您的账号已经可以正常使用了！&quot;</span>);<br>            model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/login&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result == ACTIVATION_REPEAT)&#123;<br>            model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;无效操作，该账号已经激活过了!&quot;</span>);<br>            model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;激活失败，提供的激活码不正确！&quot;</span>);<br>            model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;/site/operate-result&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><h3 id="HTTP的基本特性"><a href="#HTTP的基本特性" class="headerlink" title="HTTP的基本特性"></a>HTTP的基本特性</h3><ul>
<li>HTTP是可扩展的</li>
<li>HTTP是无状态的，有会话的：在同一个连接中，两次相同的请求之间是没有关系的。存在一个问题，用户没有办法在同一个网站上进行连续的交互。==HTTP是无状态的，使用cookie可以建立有状态的连接。==</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>可以弥补HTTP请求无状态的缺点。</p>
<ul>
<li>是服务器发送到浏览器中，并保存在浏览器中的一小部分数据。</li>
<li>浏览器下次访问该服务器时，会自动的携带块该数据，将其发送给服务器。</li>
</ul>
<p>缺点：</p>
<p>存在客户端中，不太安全，不能保存敏感的信息（密码等）</p>
<p>每次发送相同的数据，耗费流量。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902090254545.png" alt="image-20210902090254545"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/alpha&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlphaController</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * cookie实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/cookie/set&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setCookie</span><span class="hljs-params">(HttpServletResponse httpServletResponse)</span></span>&#123;    <span class="hljs-comment">//将数据传递到前端。  </span><br>         <span class="hljs-comment">//创建cookie</span><br>         Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;code&quot;</span>, CommunityUtil.generateUUID());<br>         <span class="hljs-comment">//设置cookie的生效范围(此路径下面的会给他添加上cookie数据)</span><br>         cookie.setPath(<span class="hljs-string">&quot;/community/alpha&quot;</span>);<br>         <span class="hljs-comment">//设置cookie的生存时间</span><br>         cookie.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">10</span>);<br>         <span class="hljs-comment">//发送cookie</span><br>         httpServletResponse.addCookie(cookie);<br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;set cookie&quot;</span>;<br>     &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在其他页面中使用cookie携带的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code：cookie携带的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/cookie/get&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCookie</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;code&quot;)</span> String code)</span></span>&#123;<br>        System.out.println(code);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;get cookie&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><ul>
<li><p>session执行的是JavaEE的标准，将用户信息存放到服务端</p>
</li>
<li><p>数据存放在服务端更加的安全，但是会增加服务端的压力。</p>
</li>
</ul>
<p>session依赖于cookie实现的。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902095510262.png" alt="image-20210902095510262"></p>
<p>==session存在的问题（为什么在分布式中很少使用session）==</p>
<p>session数据可能保存在某一个服务器中，但是下一次请求不一定会到这个服务器中进行处理，所以就可能拿不到数据。</p>
<p>解决方法：</p>
<ul>
<li>粘性session：让某个请求访问对应的服务器。但是有负载均衡问题。</li>
<li>同步session：给每个服务器同步session。但是会造成服务器之间耦合，不是独立的</li>
<li>共享session：一个服务器单独处理session。但是如果这个session挂了，其他的就没法用了。</li>
</ul>
<p>主流解决方法：能不用session就不用，非要用的话就可以使用数据库（redis数据库，存放到内存中）进行存储session。很好的解决了数据共享。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902100811010.png" alt="image-20210902100811010"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 浏览器往后端发送请求，然后后端往前穿带session信息</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> session</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@RequestMapping(path = &quot;/session/set&quot;,method = RequestMethod.GET)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setSession</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>       session.setAttribute(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">1</span>);<br>       session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;liwenkai&quot;</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;set session&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 接受前端发送回来的session信息</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@RequestMapping(path = &quot;/session/get&quot;,method = RequestMethod.GET)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSession</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>       System.out.println(session.getAttribute(<span class="hljs-string">&quot;id&quot;</span>));<br>       System.out.println(session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>));<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;get session&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h2><p>使用Kaptcha工具</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902101754733.png" alt="image-20210902101754733"></p>
<h3 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;!--Kaptcha,生成随机验证码--&gt;<br>&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt;</span><br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;<br>    &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">2.3</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>



<h3 id="编写kaptcha配置类"><a href="#编写kaptcha配置类" class="headerlink" title="编写kaptcha配置类"></a>编写kaptcha配置类</h3><p>kaptcha的核心配置类是：Producer。</p>
<p>通过Properties修改配置参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.code.kaptcha.Producer;<br><span class="hljs-keyword">import</span> com.google.code.kaptcha.impl.DefaultKaptcha;<br><span class="hljs-keyword">import</span> com.google.code.kaptcha.util.Config;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KaptchaConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Producer <span class="hljs-title">kaptchaProducer</span><span class="hljs-params">()</span> </span>&#123;<br>        Properties properties = <span class="hljs-keyword">new</span> Properties();<br>        properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.width&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.height&quot;</span>, <span class="hljs-string">&quot;40&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="hljs-string">&quot;32&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="hljs-string">&quot;0,0,0&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.string&quot;</span>, <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);    <span class="hljs-comment">//长度</span><br>        properties.setProperty(<span class="hljs-string">&quot;kaptcha.noise.impl&quot;</span>, <span class="hljs-string">&quot;com.google.code.kaptcha.impl.NoNoise&quot;</span>);   <span class="hljs-comment">//噪声</span><br><br>        DefaultKaptcha kaptcha = <span class="hljs-keyword">new</span> DefaultKaptcha();<br>        Config config = <span class="hljs-keyword">new</span> Config(properties);<br>        kaptcha.setConfig(config);<br>        <span class="hljs-keyword">return</span> kaptcha;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="生成验证码，并发送回前端页面"><a href="#生成验证码，并发送回前端页面" class="headerlink" title="生成验证码，并发送回前端页面"></a>生成验证码，并发送回前端页面</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生成验证码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/kaptcha&quot;,method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getKaptcha</span><span class="hljs-params">(HttpServletResponse response, HttpSession session)</span></span>&#123;<br>    <span class="hljs-comment">//生成验证码</span><br>    String text = kaptchaProducer.createText();<br>    BufferedImage image = kaptchaProducer.createImage(text);<br><br>    <span class="hljs-comment">//将验证码存入到session中</span><br>    session.setAttribute(<span class="hljs-string">&quot;kaptcha&quot;</span>,text);<br>    <span class="hljs-comment">//将图片输出给浏览器,确定图片的格式是png</span><br>    response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过OutputStream输出流的方式向前端发回数据。</span><br>        OutputStream os = response.getOutputStream();<br>        ImageIO.write(image,<span class="hljs-string">&quot;png&quot;</span>,os);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        logger.error(<span class="hljs-string">&quot;响应验证码失败：&quot;</span>+e.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="前端接收到验证码"><a href="#前端接收到验证码" class="headerlink" title="前端接收到验证码"></a>前端接收到验证码</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-4&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/kaptcha&#125;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;kaptcha&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100px;height:40px;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mr-2&quot;</span>/&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:refresh_kaptcha();&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;font-size-12 align-bottom&quot;</span>&gt;</span>刷新验证码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过js方法实现刷新验证码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refresh_kaptcha</span>(<span class="hljs-params"></span>)</span>&#123;<br>		<span class="hljs-comment">//声明一个路径，有的浏览器访问同一个路径请求是，可能会把他当成一个静态资源而不去请求，</span><br>		<span class="hljs-comment">// 所以要在后面加一个随机数，欺骗服务器</span><br>		<span class="hljs-keyword">var</span> path = CONTEXT_PATH + <span class="hljs-string">&quot;/kaptcha?p=&quot;</span>+<span class="hljs-built_in">Math</span>.random();<br>		$(<span class="hljs-string">&quot;#kaptcha&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>,path);<br>	&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>



<h2 id="登录、退出功能"><a href="#登录、退出功能" class="headerlink" title="登录、退出功能"></a>登录、退出功能</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902113232373.png" alt="image-20210902113232373"></p>
<h3 id="点击访问登录页面"><a href="#点击访问登录页面" class="headerlink" title="点击访问登录页面"></a>点击访问登录页面</h3><p>点击主页上的登录按钮，跳转到登录页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 访问登录页面</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/login&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="登录过程"><a href="#登录过程" class="headerlink" title="登录过程"></a>登录过程</h3><h5 id="登录凭证类"><a href="#登录凭证类" class="headerlink" title="登录凭证类"></a>登录凭证类</h5><p>用户成功登录之后，会注册一个登录凭证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginTicket</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;<br>    <span class="hljs-keyword">private</span> String ticket;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;<br>    <span class="hljs-keyword">private</span> Date expired;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>dao层中调用底层数据库中的方法（这里是使用注解的方式实现的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.community.dao;<br><br><span class="hljs-keyword">import</span> com.kai.community.entity.LoginTicket;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登陆凭证，通过注解写sql语句，不需要再重新创建一个xml文件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoginTicketDao</span> </span>&#123;<br>    <span class="hljs-comment">//给用户填加一个登陆凭证</span><br>    <span class="hljs-meta">@Insert(&#123;</span><br><span class="hljs-meta">            &quot;insert into community.login_ticket(user_id,ticket,status,expired) &quot;,</span><br><span class="hljs-meta">            &quot;values(#&#123;userId&#125;,#&#123;ticket&#125;,#&#123;status&#125;,#&#123;expired&#125;)&quot;</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertLoginTicket</span><span class="hljs-params">(LoginTicket loginTicket)</span></span>;<br><br>    <span class="hljs-comment">//根据ticket查找用户</span><br>    <span class="hljs-meta">@Select(&#123;</span><br><span class="hljs-meta">            &quot;select id,user_id,ticket,status,expired &quot;,</span><br><span class="hljs-meta">            &quot;from login_ticket where ticket = #&#123;ticket&#125;&quot;</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function">LoginTicket <span class="hljs-title">selectByTicket</span><span class="hljs-params">(String ticket)</span></span>;<br><br>    <span class="hljs-comment">//修改状态</span><br>    <span class="hljs-meta">@Update(&#123;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">            &quot;update login_ticket set status = #&#123;status&#125; where ticket=#&#123;ticket&#125;&quot;</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(String ticket,<span class="hljs-keyword">int</span> status)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h5 id="验证前端传过来的登录信息"><a href="#验证前端传过来的登录信息" class="headerlink" title="验证前端传过来的登录信息"></a>验证前端传过来的登录信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登陆功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username：用户名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> password：登陆密码</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> expiredSeconds：登陆凭证多久之后会过期</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">login</span><span class="hljs-params">(String username,String password,<span class="hljs-keyword">int</span> expiredSeconds)</span></span>&#123;<br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">//空值判断</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(username))&#123;<br>        map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;用户名不能为空！&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(password))&#123;<br>        map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不能为空！&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-comment">//验证账号</span><br>    User user = userDao.selectByName(username);<br>    <span class="hljs-keyword">if</span> (user==<span class="hljs-keyword">null</span>)&#123;<br>        map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;用户未注册！&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-comment">//验证状态，如果status等于0，说明他没有被激活</span><br>    <span class="hljs-keyword">if</span> (user.getStatus() == <span class="hljs-number">0</span>)&#123;<br>        map.put(<span class="hljs-string">&quot;usernameMsg&quot;</span>,<span class="hljs-string">&quot;该账号没有被激活！&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-comment">//验证密码,先获得通过md5加密之后的秘钥</span><br>    password = CommunityUtil.md5(password+user.getSalt());<br>    <span class="hljs-keyword">if</span> (!user.getPassword().equals(password))&#123;<br>        map.put(<span class="hljs-string">&quot;passwordMsg&quot;</span>,<span class="hljs-string">&quot;密码不正确！&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-comment">//登录成功，生成一个登陆凭证</span><br>    LoginTicket loginTicket = <span class="hljs-keyword">new</span> LoginTicket();<br>    loginTicket.setUserId(user.getId());<br>    loginTicket.setTicket(CommunityUtil.generateUUID());   <span class="hljs-comment">//生成一个随机的字符串</span><br>    loginTicket.setStatus(<span class="hljs-number">0</span>);<br>    loginTicket.setExpired(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis()+expiredSeconds*<span class="hljs-number">1000</span>));<br>    loginTicketDao.insertLoginTicket(loginTicket);<br><br>    map.put(<span class="hljs-string">&quot;ticket&quot;</span>,loginTicket.getTicket());<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制层处理传入请求</p>
<p>验证码是在这里验证的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> password</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> code：验证码。跟session中的kaptcha进行比较</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> rememberMe：记住我</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> session</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username,String password,String code,<span class="hljs-keyword">boolean</span> rememberMe,</span></span><br><span class="hljs-params"><span class="hljs-function">                    Model model,HttpSession session,HttpServletResponse response)</span></span>&#123;<br>    String kaptcha = (String) session.getAttribute(<span class="hljs-string">&quot;kaptcha&quot;</span>);<br>    <span class="hljs-comment">//判断验证码是否正确，忽略大小写equalsIgnoreCase。</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code))&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;codeMsg&quot;</span>,<span class="hljs-string">&quot;验证码不正确！&quot;</span>);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;/site/login&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//检查密码，时间</span><br>    <span class="hljs-keyword">int</span> expiredSeconds = rememberMe ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;<br>    Map&lt;String,Object&gt; map = userService.login(username,password,expiredSeconds);<br>    <span class="hljs-keyword">if</span> (map.containsKey(<span class="hljs-string">&quot;ticket&quot;</span>))&#123;<br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;ticket&quot;</span>,map.get(<span class="hljs-string">&quot;ticket&quot;</span>).toString());<br>        cookie.setPath(contextPath);<br>        cookie.setMaxAge(expiredSeconds);<br>        response.addCookie(cookie);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/index&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//处理错误</span><br>        model.addAttribute(<span class="hljs-string">&quot;usernameMsg&quot;</span>,map.get(<span class="hljs-string">&quot;usernameMsg&quot;</span>));<br>        model.addAttribute(<span class="hljs-string">&quot;passwordMsg&quot;</span>,map.get(<span class="hljs-string">&quot;passwordMsg&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><p>通过登录凭证修改状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退出登录，根据登录凭证ticket，修改status为无效状态。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ticket</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(String ticket)</span></span>&#123;<br>    loginTicketDao.updateStatus(ticket,<span class="hljs-number">1</span>);   <span class="hljs-comment">//1表示无效</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>退出登录要跳转到登录页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退出登录。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ticket：用户凭证。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/logout&quot;,method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">logout</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;ticket&quot;)</span> String ticket)</span></span>&#123;<br>    userService.logout(ticket);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902165023001.png" alt="image-20210902165023001"></p>
<h3 id="拦截器的实现原理"><a href="#拦截器的实现原理" class="headerlink" title="拦截器的实现原理"></a>拦截器的实现原理</h3><p>这里的Template就是model。</p>
<p>浏览器cookie里面存放着用户登录之后的ticket，浏览器发送ticket到服务端，服务端接受到ticket之后进行处理，再根据这个ticket到login_ticket表中查找数据；通过查找到的数据可以再去user表中得到user相关的信息。</p>
<p>服务器会把这个消息请求进行拦截，然后在template中添加用户信息。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902171946150.png" alt="image-20210902171946150"></p>
<h5 id="cookie工具类"><a href="#cookie工具类" class="headerlink" title="cookie工具类"></a>cookie工具类</h5><p>通过request从cookie中获取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.community.util;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-comment">//从cookie中找到你想要的数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieUtil</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getValue</span><span class="hljs-params">(HttpServletRequest request, String name)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span> || name == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数为空！&quot;</span>);<br>        &#125;<br>        Cookie[] cookies = request.getCookies();<br>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">for</span> (Cookie cookie:cookies)&#123;<br>                <span class="hljs-keyword">if</span> (cookie.getName().equals(name))&#123;<br>                    <span class="hljs-keyword">return</span> cookie.getValue();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="threadlocal容器类"><a href="#threadlocal容器类" class="headerlink" title="threadlocal容器类"></a>threadlocal容器类</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.community.util;<br><br><span class="hljs-keyword">import</span> com.kai.community.entity.User;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 容器的作用，持有用户信息，实现线程隔离，用在多线程的环境下，用于代替session对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostHolder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ThreadLocal&lt;User&gt; users = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>    <span class="hljs-comment">//threadlocal实现线程隔离</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        users.set(user);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> users.get();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清理里面的对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>        users.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="LoginTicketInterceptor登录拦截器"><a href="#LoginTicketInterceptor登录拦截器" class="headerlink" title="LoginTicketInterceptor登录拦截器"></a>LoginTicketInterceptor登录拦截器</h3><p>拦截controller，然后添加一部分的配置信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginTicketInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HostHolder hostHolder;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//从cookie中获取凭证</span><br>        String ticket = CookieUtil.getValue(request,<span class="hljs-string">&quot;ticket&quot;</span>);<br>        <span class="hljs-keyword">if</span> (ticket != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//查询凭证</span><br>            LoginTicket loginTicket = userService.findLoginTicket(ticket);<br>            <span class="hljs-comment">//检查凭证是否有效</span><br>            <span class="hljs-keyword">if</span> (loginTicket!=<span class="hljs-keyword">null</span>&amp;&amp;loginTicket.getStatus()==<span class="hljs-number">0</span>&amp;&amp;loginTicket.getExpired().after(<span class="hljs-keyword">new</span> Date()))&#123;<br>                <span class="hljs-comment">//根据凭证查询用户</span><br>                User user = userService.selectById(loginTicket.getUserId());<br>                <span class="hljs-comment">//在本次请求中持有用户.threadLocal 线程隔离</span><br>                hostHolder.setUser(user);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在模板引擎中用user信息。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> modelAndView</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        User user = hostHolder.getUser();<br>        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span> &amp;&amp; modelAndView !=<span class="hljs-keyword">null</span>)&#123;<br>            modelAndView.addObject(<span class="hljs-string">&quot;loginUser&quot;</span>,user);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在模板运行完之后，要清理对象。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        hostHolder.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><p>配置拦截器对那些请求生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置拦截器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AlphaInterceptor alphaInterceptor;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(alphaInterceptor)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>,<span class="hljs-string">&quot;/**/*.js&quot;</span>,<span class="hljs-string">&quot;/**/*.png&quot;</span>,<span class="hljs-string">&quot;/**/*.jpg&quot;</span>,<span class="hljs-string">&quot;/**/*.jpeg&quot;</span>)<br>                .addPathPatterns(<span class="hljs-string">&quot;/register&quot;</span>,<span class="hljs-string">&quot;/login&quot;</span>);<br>		<span class="hljs-comment">//静态资源可以放过</span><br>        registry.addInterceptor(loginTicketInterceptor)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>,<span class="hljs-string">&quot;/**/*.js&quot;</span>,<span class="hljs-string">&quot;/**/*.png&quot;</span>,<span class="hljs-string">&quot;/**/*.jpg&quot;</span>,<span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>拦截器生效之后</p>
<p>未登录之前，会显示注册、登录。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210902193747728.png" alt="image-20210902193747728"></p>
<p>登录之后，显示消息和用户信息</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902193850314.png" alt="image-20210902193850314"></p>
<h2 id="账号设置"><a href="#账号设置" class="headerlink" title="账号设置"></a>账号设置</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902200149922.png" alt="image-20210902200149922"></p>
<h3 id="上传头像功能"><a href="#上传头像功能" class="headerlink" title="上传头像功能"></a>上传头像功能</h3><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210902210624464.png" alt="image-20210902210624464"></p>
<h5 id="访问账号设置页面"><a href="#访问账号设置页面" class="headerlink" title="访问账号设置页面"></a>访问账号设置页面</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跳转到设置页面。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/setting&quot;,method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSettingPage</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/setting&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="上传头像"><a href="#上传头像" class="headerlink" title="上传头像"></a>上传头像</h5><p>保存到本地——然后修改数据库中headerUrl</p>
<p>将图片保存到内存中，这里的upload里表示的就是存放的地址。在配置文件中进行配置，方便以后修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;springboot_newCoder.path.upload&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String upload;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;springboot_newCoder.path.domain&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String domain;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String contextPath;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HostHolder hostHolder;<br><br><br><span class="hljs-meta">@RequestMapping(path = &quot;/upload&quot;,method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">uploadHeader</span><span class="hljs-params">(MultipartFile headerImage, Model model)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (headerImage == <span class="hljs-keyword">null</span>)&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-string">&quot;您还没有上传图片&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/setting&quot;</span>;<br>    &#125;<br>    String filename = headerImage.getOriginalFilename();<br>    String suffix = filename.substring(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(suffix))&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-string">&quot;文件格式不正确！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//生成随机的文件名</span><br>    filename = CommunityUtil.generateUUID() + suffix;<br>    <span class="hljs-comment">//确定文件存放的路径</span><br>    File dest = <span class="hljs-keyword">new</span> File(upload + <span class="hljs-string">&quot;/&quot;</span> + filename);<br>    <span class="hljs-keyword">try</span> &#123;<br>        headerImage.transferTo(dest);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        logger.error(<span class="hljs-string">&quot;上传文件失败，服务器发生异常：&quot;</span>+e.getMessage());<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;上传文件失败，服务器发生异常！&quot;</span>,e);<br>    &#125;<br>    <span class="hljs-comment">//更新当前用户的头像地址（web访问路径）</span><br>    <span class="hljs-comment">//http://localhost:8080/community/user/header/***.png</span><br>    User user = hostHolder.getUser();<br>    String headerUrl = domain + contextPath + <span class="hljs-string">&quot;/user/header/&quot;</span> + filename;<br>    <span class="hljs-comment">//跟新数据库中投降文件的地址</span><br>    userService.updateHeader(user.getId(),headerUrl);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="获取头像"><a href="#获取头像" class="headerlink" title="获取头像"></a>获取头像</h5><p>通过IO流的方式读取头像。</p>
<p>先拼接成文件保存的地址，然后再通过IO读取头像。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/header/&#123;filename&#125;&quot;,method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHeader</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;filename&quot;)</span> String filename, HttpServletResponse response)</span></span>&#123;<br>    <span class="hljs-comment">//服务器存放的路径</span><br>    filename = upload + <span class="hljs-string">&quot;/&quot;</span> + filename;<br>    <span class="hljs-comment">//文件后缀</span><br>    String suffix = filename.substring(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>    <span class="hljs-comment">//相应图片</span><br>    response.setContentType(<span class="hljs-string">&quot;image/&quot;</span>+suffix);<br>    <span class="hljs-keyword">try</span> (<br>            OutputStream os = response.getOutputStream();<br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(filename);<br>            )&#123;<br><br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((b = fis.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>            os.write(buffer,<span class="hljs-number">0</span>,b);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        logger.error(<span class="hljs-string">&quot;读取头像失败：&quot;</span>+e.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><h5 id="填写表单"><a href="#填写表单" class="headerlink" title="填写表单"></a>填写表单</h5><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210903094805614.png" alt="image-20210903094805614"></p>
<h5 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h5><p>对表单中的数据进行合法性判断，如果合法就更新数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新密码</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> oldPassword</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newPassword</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> confirmPassword</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">checkPassword</span><span class="hljs-params">(String oldPassword,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        String newPassword, String confirmPassword,User user)</span></span>&#123;<br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(oldPassword))&#123;<br>        map.put(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>,<span class="hljs-string">&quot;密码格式不正确&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(newPassword) || newPassword.length()&lt;<span class="hljs-number">8</span>)&#123;<br>        map.put(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>,<span class="hljs-string">&quot;新密码格式不正确&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(confirmPassword) || confirmPassword.length()&lt;<span class="hljs-number">8</span>)&#123;<br>        map.put(<span class="hljs-string">&quot;confirmPasswordMsg&quot;</span>,<span class="hljs-string">&quot;新密码格式不正确&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!confirmPassword.equals(newPassword))&#123;<br>        map.put(<span class="hljs-string">&quot;confirmPasswordMsg&quot;</span>,<span class="hljs-string">&quot;两次密码不相同&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    oldPassword = CommunityUtil.md5(oldPassword+user.getSalt());<br>    <span class="hljs-keyword">if</span> (!oldPassword.equals(user.getPassword()))&#123;<br>        map.put(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>,<span class="hljs-string">&quot;密码错误！&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>    String salt = CommunityUtil.generateUUID();<br>    newPassword = CommunityUtil.md5(newPassword + salt);<br>    userDao.updatePassword(user.getId(),newPassword,salt);<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h5><p>对service层发来的处理结果进行分析。如果密码更新成功就跳转到登录页面，如果没有成功就在前端返回msg</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/updatePassword&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updatePassword</span><span class="hljs-params">(String oldPassword, String newPassword, String confirmPassword, Model model)</span></span>&#123;<br>        User user = hostHolder.getUser();          <span class="hljs-comment">//从threadlocal中获得user对象。</span><br>        Map&lt;String,Object&gt; map = userService.checkPassword(oldPassword,newPassword,confirmPassword,user);<br>        <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map.isEmpty())&#123;<br>            model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;修改密码成功&quot;</span>);<br><span class="hljs-comment">//            model.addAttribute(&quot;target&quot;,&quot;/index&quot;);</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            model.addAttribute(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>,map.get(<span class="hljs-string">&quot;oldPasswordMsg&quot;</span>));<br>            model.addAttribute(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>,map.get(<span class="hljs-string">&quot;newPasswordMsg&quot;</span>));<br>            model.addAttribute(<span class="hljs-string">&quot;confirmPasswordMsg&quot;</span>,map.get(<span class="hljs-string">&quot;confirmPasswordMsg&quot;</span>));<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/setting&quot;</span>;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>





<h2 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210903094744331.png" alt="image-20210903094744331"></p>
<p>==通过自定义注解进行拦截==</p>
<p>在需要拦截的方法上面添加一个自定义的注解就可以了，这样就省去了在WebMvcConfig中配置路径了。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>相当于一个标记的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义注解，打上这么标记之后的方法，只有登录才能访问。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span>       <span class="hljs-comment">//目标</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>    <span class="hljs-comment">//在什么时候生效。</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoginRequired &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="设置一个自定义注解的拦截器"><a href="#设置一个自定义注解的拦截器" class="headerlink" title="设置一个自定义注解的拦截器"></a>设置一个自定义注解的拦截器</h3><p>因为他要在controller之前执行，所以使用preHandle。</p>
<p>被拦截的页面，要重定向到login页面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequiredInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HostHolder hostHolder;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//检查handler能够强转成HandlerMethod类型</span><br>        <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod)&#123;<br>            HandlerMethod handlerMethod = (HandlerMethod) handler;<br>            Method method = handlerMethod.getMethod();<br>            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);<br>            <span class="hljs-keyword">if</span> (loginRequired != <span class="hljs-keyword">null</span> &amp;&amp; hostHolder.getUser() == <span class="hljs-keyword">null</span>)&#123;<br>                response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/login&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="在要拦截的controller上打上标记"><a href="#在要拦截的controller上打上标记" class="headerlink" title="在要拦截的controller上打上标记"></a>在要拦截的controller上打上标记</h3><p>这里是因为如果用户登录，你是不能访问用户设置页面的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@LoginRequired</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/setting&quot;,method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSettingPage</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/setting&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="在WebMvcConfig里过滤静态资源"><a href="#在WebMvcConfig里过滤静态资源" class="headerlink" title="在WebMvcConfig里过滤静态资源"></a>在WebMvcConfig里过滤静态资源</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> LoginRequiredInterceptor loginRequiredInterceptor;   <span class="hljs-comment">//根据自定义注解拦截</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br><br>    registry.addInterceptor(loginRequiredInterceptor)<br>            .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>,<span class="hljs-string">&quot;/**/*.js&quot;</span>,<span class="hljs-string">&quot;/**/*.png&quot;</span>,<span class="hljs-string">&quot;/**/*.jpg&quot;</span>,<span class="hljs-string">&quot;/**/*.jpeg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="Git管理版本"><a href="#Git管理版本" class="headerlink" title="Git管理版本"></a>Git管理版本</h1><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210901194014661.png" alt="image-20210901194014661"></p>
<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Git">git init           初始化一个Git文件<br><br>git --list         查看结构<br><br>git add *          添加所有的文件到本地仓库。<br><br>git commit -m &quot;描述此次提交的说明&quot;      提交文件到本地仓库<br><br>git push           提交到远程仓库<br><br>git log            查看分支的提交记录<br></code></pre></td></tr></table></figure>





<h1 id="社区模块开发"><a href="#社区模块开发" class="headerlink" title="社区模块开发"></a>社区模块开发</h1><h2 id="过滤敏感词"><a href="#过滤敏感词" class="headerlink" title="过滤敏感词"></a>过滤敏感词</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210903110908762.png" alt="image-20210903110908762"></p>
<p>==通过前缀树过滤敏感词。==</p>
<p>前缀树：</p>
<ul>
<li>根节点是空的</li>
<li>除了根节点，每个节点只有一个字符。</li>
<li>从根节点开始，将路径上的每个节点连接起来，就是当前节点的字符串。</li>
<li>每个子节点的字符是不同的，如果相同的话就要合并。</li>
</ul>
<p>例子：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210903112458856.png" alt="image-20210903112458856"></p>
<h2 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h2><p>==异步请求==，更新局部页面，而不是刷新整个页面。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210903153206124.png" alt="image-20210903153206124"></p>
<h3 id="（1）前端页面使用ajax发送请求，在js里面编写"><a href="#（1）前端页面使用ajax发送请求，在js里面编写" class="headerlink" title="（1）前端页面使用ajax发送请求，在js里面编写"></a>（1）前端页面使用ajax发送请求，在js里面编写</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">$(function()&#123;<br>   $(<span class="hljs-string">&quot;#publishBtn&quot;</span>).click(publish);<br>&#125;);<br><br><span class="hljs-function">function <span class="hljs-title">publish</span><span class="hljs-params">()</span> </span>&#123;<br>   $(<span class="hljs-string">&quot;#publishModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);<br><br>   <span class="hljs-comment">//获取标题和内容</span><br>   <span class="hljs-keyword">var</span> title = $(<span class="hljs-string">&quot;#recipient-name&quot;</span>).val();<br>   <span class="hljs-keyword">var</span> content = $(<span class="hljs-string">&quot;#message-text&quot;</span>).val();<br>   <span class="hljs-comment">//发送异步请求（post）</span><br>   $.post(<br>      CONTEXT_PATH + <span class="hljs-string">&quot;/discuss/add&quot;</span>,<br>      &#123;<span class="hljs-string">&quot;title&quot;</span>:title,<span class="hljs-string">&quot;content&quot;</span>:content&#125;,<br>      function (data)&#123;<br>         data = $.parseJSON(data);<br>         console.log(data);<br>         <span class="hljs-comment">//在提示框中显示返回消息</span><br>         $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(data.msg);<br>         <span class="hljs-comment">//显示提示框</span><br>         $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;show&quot;</span>);<br>         <span class="hljs-comment">//2秒后，自动隐藏提示框</span><br>         setTimeout(function()&#123;<br>            $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);<br>            <span class="hljs-comment">//刷新页面</span><br>            <span class="hljs-keyword">if</span> (data.code == <span class="hljs-number">0</span>)&#123;<br>               window.location.reload();<br>            &#125;<br>         &#125;, <span class="hljs-number">2000</span>);<br><br>      &#125;<br>   );<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（2）service层"><a href="#（2）service层" class="headerlink" title="（2）service层"></a>（2）service层</h3><p>底层逻辑判断，把前端的帖子通过controller层发送到这里，然后service层对发送来的数据进行判断，转义HTML标记、过滤敏感词等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//增加帖子的功能，将敏感词过滤掉</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addDiscussPost</span><span class="hljs-params">(DiscussPost post)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (post == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数不能为空&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//转义HTML标记</span><br>    post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));<br>    post.setContent(HtmlUtils.htmlEscape(post.getContent()));<br><br>    <span class="hljs-comment">//过滤敏感词</span><br>    post.setTitle(sensitiveFilter.filter(post.getTitle()));<br>    post.setContent(sensitiveFilter.filter(post.getContent()));<br><br>    <span class="hljs-keyword">return</span> discussPostDao.insertDiscussPost(post);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（3）controller层"><a href="#（3）controller层" class="headerlink" title="（3）controller层"></a>（3）controller层</h3><p>接收到前端发送来的请求之后，对数据封装到一个discussPost里面。再把这个discussPost对象发送到service层进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/discuss&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscussPostController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DiscussPostService discussPostService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HostHolder hostHolder;<br><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/add&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addDiscussPost</span><span class="hljs-params">(String title,String content)</span></span>&#123;<br>        User user = hostHolder.getUser();<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">404</span>,<span class="hljs-string">&quot;你还没有登录哦！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//设置帖子信息</span><br>        DiscussPost post = <span class="hljs-keyword">new</span> DiscussPost();<br>        post.setUserId(user.getId());<br>        post.setTitle(title);<br>        post.setContent(content);<br>        post.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>        discussPostService.addDiscussPost(post);<br>        <span class="hljs-comment">//这里报错没有处理，等后面统一处理。</span><br>        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;发布成功&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="帖子详情"><a href="#帖子详情" class="headerlink" title="帖子详情"></a>帖子详情</h2><p>点击帖子，跳转到查看帖子的详细内容。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210903191923838.png" alt="image-20210903191923838"></p>
<h4 id="（1）service层"><a href="#（1）service层" class="headerlink" title="（1）service层"></a>（1）service层</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回一个帖子详情</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DiscussPost <span class="hljs-title">findDiscussPostById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> discussPostDao.selectDiscussPostById(id);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="（2）controller层"><a href="#（2）controller层" class="headerlink" title="（2）controller层"></a>（2）controller层</h4><p>将帖子内容跟对象返回到前端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/detail/&#123;discussPostId&#125;&quot;, method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDiscussPost</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;discussPostId&quot;)</span> <span class="hljs-keyword">int</span> discussPostId, Model model)</span></span>&#123;<br>    <span class="hljs-comment">//帖子</span><br>    DiscussPost post = discussPostService.findDiscussPostById(discussPostId);<br>    model.addAttribute(<span class="hljs-string">&quot;post&quot;</span>,post);<br>    <span class="hljs-comment">//作者</span><br>    User user = userService.selectById(post.getUserId());<br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/discuss-detail&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210903195107911.png" alt="image-20210903195107911"></p>
<p>注解式事务：</p>
<p>使用@Transactional注解实现，通过参数可以实现不同的隔离级别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserDao userDao;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DiscussPostDao discussPostDao;<br><br><span class="hljs-comment">//注释性事务</span><br><span class="hljs-comment">//REQUIRED:支持当前事务（外部事务），如果不存在就创建新事务</span><br><span class="hljs-comment">//REQUIRED_NEW:创建一个新事务，并且暂停当前事务（外部事务）</span><br><span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">save1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//新增用户</span><br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setUsername(<span class="hljs-string">&quot;alpha&quot;</span>);<br>    user.setSalt(CommunityUtil.generateUUID().substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));<br>    user.setPassword(CommunityUtil.md5(<span class="hljs-string">&quot;123&quot;</span>+user.getSalt()));<br>    user.setEmail(<span class="hljs-string">&quot;123@qq.com&quot;</span>);<br>    user.setHeaderUrl(<span class="hljs-string">&quot;http://images.nowcoder.com/head/25t.png&quot;</span>);<br>    user.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>    userDao.insertUser(user);<br><br>    <span class="hljs-comment">//新增帖子</span><br>    DiscussPost discussPost = <span class="hljs-keyword">new</span> DiscussPost();<br>    discussPost.setUserId(user.getId());<br>    discussPost.setTitle(<span class="hljs-string">&quot;hello&quot;</span>);<br>    discussPost.setContent(<span class="hljs-string">&quot;新人报道&quot;</span>);<br>    discussPost.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>    discussPostDao.insertDiscussPost(discussPost);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="私信设置"><a href="#私信设置" class="headerlink" title="私信设置"></a>私信设置</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210905221331642.png" alt="image-20210905221331642"></p>
<p>发送私信功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送私信功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> toName</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> content</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/letter/send&quot;,method = RequestMethod.POST)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendLetter</span><span class="hljs-params">(String toName,String content)</span></span>&#123;<br><br>    System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);<br>    User target = userService.selectByName(toName);<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;目标用户不存在&quot;</span>);<br>    &#125;<br><br>    Message message = <span class="hljs-keyword">new</span> Message();<br>    message.setFromId(hostHolder.getUser().getId());<br>    message.setToId(target.getId());<br>    <span class="hljs-keyword">if</span> (message.getFromId() &lt; message.getToId())&#123;<br>        message.setConversationId(message.getFromId()+<span class="hljs-string">&quot;_&quot;</span>+message.getToId());<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        message.setConversationId(message.getToId()+<span class="hljs-string">&quot;_&quot;</span>+message.getFromId());<br>    &#125;<br><br>    message.setContent(content);<br>    message.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>    messageService.addMessage(message);<br><br>    <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>更新状态（未读—已读）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">getLetterIds</span><span class="hljs-params">(List&lt;Message&gt; letterList)</span> </span>&#123;<br>    List&lt;Integer&gt; ids = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">if</span> (letterList != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Message message : letterList) &#123;<br>            <span class="hljs-keyword">if</span> (hostHolder.getUser().getId() == message.getToId() &amp;&amp; message.getStatus() == <span class="hljs-number">0</span>) &#123;<br>                ids.add(message.getId());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ids;<br>&#125;<br><br><br><span class="hljs-comment">// 设置已读</span><br>        List&lt;Integer&gt; ids = getLetterIds(letterList);<br>        <span class="hljs-keyword">if</span> (!ids.isEmpty()) &#123;<br>            messageService.readMessage(ids);<br>        &#125;<br></code></pre></td></tr></table></figure>





<p>前端页面点击发送私信按钮之后的事件。</p>
<p>把发送给谁，内容发送到后端，后端进行处理之后再发回一个 json数据。然后前端会接收到这个json数据，再刷新页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send_letter</span>(<span class="hljs-params"></span>) </span>&#123;<br>   $(<span class="hljs-string">&quot;#sendModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);<br><br>   <span class="hljs-keyword">var</span> toName = $(<span class="hljs-string">&quot;#recipient-name&quot;</span>).val();<br>   <span class="hljs-keyword">var</span> content = $(<span class="hljs-string">&quot;#message-text&quot;</span>).val();<br><br>   $.post(<br>      CONTEXT_PATH + <span class="hljs-string">&quot;/letter/send&quot;</span>,<br>      &#123;<span class="hljs-string">&quot;toName&quot;</span>:toName,<span class="hljs-string">&quot;content&quot;</span>:content&#125;,<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>&#123;<br>         data = $.parseJSON(data);<br>         <span class="hljs-keyword">if</span> (data.code==<span class="hljs-number">0</span>)&#123;<br>            $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(<span class="hljs-string">&quot;发送成功&quot;</span>);<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>            $(<span class="hljs-string">&quot;#hintBody&quot;</span>).text(data.msg);<br>         &#125;<br>         $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;show&quot;</span>);<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            $(<span class="hljs-string">&quot;#hintModal&quot;</span>).modal(<span class="hljs-string">&quot;hide&quot;</span>);<br>            location.reload();<br>         &#125;, <span class="hljs-number">2000</span>);<br><br>      &#125;<br>   );<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="统一处理异常"><a href="#统一处理异常" class="headerlink" title="统一处理异常"></a>统一处理异常</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210906163407082.png" alt="image-20210906163407082"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 统一异常处理</span><br><span class="hljs-comment"> * 处理controller层中出现的异常。写到logger日志中。当服务器出现错误时，在前端页面会提醒</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ControllerAdvice(annotations = Controller.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionAdvice</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);<br><br>    <span class="hljs-meta">@ExceptionHandler(&#123;Exception.class&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleException</span><span class="hljs-params">(Exception e, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        logger.error(<span class="hljs-string">&quot;服务器发生异常&quot;</span>+e.getMessage());<br>        <span class="hljs-keyword">for</span> (StackTraceElement element : e.getStackTrace())&#123;<br>            logger.error(element.toString());<br>        &#125;<br>        String xRequestedWith = request.getHeader(<span class="hljs-string">&quot;x-requested-with&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;XMLHttpRequest&quot;</span>.equals(xRequestedWith))&#123;<br>            response.setContentType(<span class="hljs-string">&quot;application/plain;charset=utf-8&quot;</span>);<br>            PrintWriter writer = response.getWriter();<br>            writer.write(CommunityUtil.getJSONString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;服务器异常&quot;</span>));<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            response.sendRedirect(request.getContextPath()+ <span class="hljs-string">&quot;/error&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="统一记录日志"><a href="#统一记录日志" class="headerlink" title="统一记录日志"></a>统一记录日志</h2><p>针对业务模块记录日志。</p>
<p>实现：spring AOP。</p>
<p>AOP：是一种编程思想，是面向切面编程。是对OOP的互补</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210906171647897.png" alt="image-20210906171647897"></p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210906171811642.png" alt="image-20210906171811642"></p>
<ul>
<li>aspect： 切面。我们的编程都是在aspect中进行的。AOP统一处理这些bean中的某些功能。</li>
<li>pointcut：切入点：表示我们的设计的切面要切入到哪里。</li>
<li>target：要切入的目标，程序中已经开发好了，要处理业务逻辑的一些bean。</li>
<li>Joinpoint：连接点，target中能够植入代码的地方。</li>
<li>advice：通知，声明这个切面到底要处理什么样的逻辑。</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210906172639880.png" alt="image-20210906172639880"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210906172903889.png" alt="image-20210906172903889"></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="帖子点赞"><a href="#帖子点赞" class="headerlink" title="帖子点赞"></a>帖子点赞</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210908085148874.png" alt="image-20210908085148874"></p>
<h3 id="（1）生成redis中key的方法"><a href="#（1）生成redis中key的方法" class="headerlink" title="（1）生成redis中key的方法"></a>（1）生成redis中key的方法</h3><p>like:entity:entityType:entityId</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生成redis的key的方法，用set进行保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisKeyUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPLIT = <span class="hljs-string">&quot;:&quot;</span>;<br><br>    <span class="hljs-comment">//前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX_ENTITY_LIKE = <span class="hljs-string">&quot;like:entity&quot;</span>;<br>    <span class="hljs-comment">//某个实体的赞</span><br>    <span class="hljs-comment">//拼接变量，从而得到一个完整的key</span><br>    <span class="hljs-comment">//like:entity:entityType:entityId</span><br>    <span class="hljs-comment">// -&gt;   保存在set(userId)，谁给帖子点了赞，就保存到set中，方面后面统计用户点赞数量。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getEntityLikeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType,<span class="hljs-keyword">int</span> entityId)</span></span>&#123;<br>        <span class="hljs-comment">//实体的key</span><br>        <span class="hljs-keyword">return</span> PREFIX_ENTITY_LIKE + SPLIT +entityType + SPLIT +entityId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（2）业务逻辑层"><a href="#（2）业务逻辑层" class="headerlink" title="（2）业务逻辑层"></a>（2）业务逻辑层</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LikeService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">//点赞,一次是点赞，两次取消点赞</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">like</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId,<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;<br>        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);<br><br>        <span class="hljs-keyword">boolean</span> isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);<br>        <span class="hljs-keyword">if</span> (isMember)&#123;<br>            redisTemplate.opsForSet().remove(entityLikeKey,userId);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            redisTemplate.opsForSet().add(entityLikeKey,userId);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查询某实体点赞的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">findEntityLikeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;<br>        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(entityLikeKey);<br>    &#125;<br><br>    <span class="hljs-comment">//查询某人对某实体的点赞状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findEntityLikeStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId,<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;<br>        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(entityLikeKey,userId) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（3）控制层"><a href="#（3）控制层" class="headerlink" title="（3）控制层"></a>（3）控制层</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LikeService likeService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HostHolder hostHolder;<br><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/like&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">like</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType,<span class="hljs-keyword">int</span> entityId)</span></span>&#123;<br>        User user = hostHolder.getUser();<br>        <span class="hljs-comment">//点赞</span><br>        likeService.like(user.getId(),entityType,entityId);<br>        <span class="hljs-comment">//点赞的数量</span><br>        Long likeCount = likeService.findEntityLikeCount(entityType, entityId);<br>        <span class="hljs-comment">//状态</span><br>        <span class="hljs-keyword">int</span> likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);<br><br><br>        <span class="hljs-comment">//将返回的结果封装到map中，方便传递数据</span><br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;likeCount&quot;</span>,likeCount);<br>        map.put(<span class="hljs-string">&quot;likeStatus&quot;</span>,likeStatus);<br>        System.out.println(<span class="hljs-string">&quot;==============================&quot;</span>);<br>        System.out.println(likeStatus);<br>        <span class="hljs-comment">//通过json数据进行传递。</span><br>        <span class="hljs-keyword">return</span> CommunityUtil.getJSONString(<span class="hljs-number">0</span>,map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（4）前端js"><a href="#（4）前端js" class="headerlink" title="（4）前端js"></a>（4）前端js</h3><p>使用ajax刷新局部页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">like</span>(<span class="hljs-params">btn,entityType,entityId</span>)</span>&#123;<br>    $.post(<br>        CONTEXT_PATH + <span class="hljs-string">&quot;/like&quot;</span>,<br>        &#123;<span class="hljs-string">&quot;entityType&quot;</span>:entityType,<span class="hljs-string">&quot;entityId&quot;</span>:entityId&#125;,<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>&#123;<br>            data = $.parseJSON(data);<br>            <span class="hljs-keyword">if</span> (data.code == <span class="hljs-number">0</span>)&#123;<br>                $(btn).children(<span class="hljs-string">&quot;i&quot;</span>).text(data.likeCount);<br>                $(btn).children(<span class="hljs-string">&quot;b&quot;</span>).text(data.likeStatus==<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;已赞&#x27;</span>:<span class="hljs-string">&quot;赞&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                alert(data.msg);<br>            &#125;<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="我收到的赞"><a href="#我收到的赞" class="headerlink" title="我收到的赞"></a>我收到的赞</h2><p>查询某个人的赞。</p>
<img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210908150640629.png" alt="image-20210908150640629" style="zoom:33%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LikeService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">//点赞,一次是点赞，两次取消点赞</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">like</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId,<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId,<span class="hljs-keyword">int</span> entityUserId)</span></span>&#123;<br><span class="hljs-comment">//        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);</span><br><span class="hljs-comment">//        if (isMember)&#123;</span><br><span class="hljs-comment">//            redisTemplate.opsForSet().remove(entityLikeKey,userId);</span><br><span class="hljs-comment">//        &#125;else&#123;</span><br><span class="hljs-comment">//            redisTemplate.opsForSet().add(entityLikeKey,userId);</span><br><span class="hljs-comment">//        &#125;</span><br>        redisTemplate.execute(<span class="hljs-keyword">new</span> SessionCallback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(RedisOperations operations)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;<br>                String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);<br>                String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);<br>                <span class="hljs-keyword">boolean</span> isMember = operations.opsForSet().isMember(entityLikeKey, userId);<br>                <span class="hljs-comment">//开启事务</span><br>                operations.multi();<br>                <span class="hljs-keyword">if</span> (isMember)&#123;<br>                    operations.opsForSet().remove(entityLikeKey,userId);<br>                    operations.opsForValue().decrement(userLikeKey);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    operations.opsForSet().add(entityLikeKey,userId);<br>                    operations.opsForValue().increment(userLikeKey);<br>                &#125;<br>                <span class="hljs-keyword">return</span> operations.exec();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">//查询某实体点赞的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">findEntityLikeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;<br>        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(entityLikeKey);<br>    &#125;<br><br>    <span class="hljs-comment">//查询某人对某实体的点赞状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findEntityLikeStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId,<span class="hljs-keyword">int</span> entityType, <span class="hljs-keyword">int</span> entityId)</span></span>&#123;<br>        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(entityLikeKey,userId) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//查询某个用户获得的赞</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUserLikeCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;<br>        String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);<br>        Integer count =(Integer) redisTemplate.opsForValue().get(userLikeKey);<br>        <span class="hljs-keyword">return</span> count == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : count.intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="关注列表"><a href="#关注列表" class="headerlink" title="关注列表"></a>关注列表</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210914102755729.png" alt="image-20210914102755729"></p>
<h2 id="使用redis优化登录模块"><a href="#使用redis优化登录模块" class="headerlink" title="使用redis优化登录模块"></a>使用redis优化登录模块</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210914102952962.png" alt="image-20210914102952962"></p>
<h3 id="（1）使用redis存储验证码"><a href="#（1）使用redis存储验证码" class="headerlink" title="（1）使用redis存储验证码"></a>（1）使用redis存储验证码</h3><p>重构了生成验证码的模块</p>
<p>重点：生成验证码发送给浏览器，此时验证码信息保存在cookie中，60s之后过期。</p>
<p>验证码还要保存到redis中，用于后台验证验证码是否正确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成验证码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;/kaptcha&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getKaptcha</span><span class="hljs-params">(HttpServletResponse response<span class="hljs-comment">/*HttpSession session*/</span>)</span></span>&#123;<br>        <span class="hljs-comment">//生成验证码</span><br>        String text = kaptchaProducer.createText();<br>        BufferedImage image = kaptchaProducer.createImage(text);<br><br>        <span class="hljs-comment">//将验证码存入到session中</span><br><span class="hljs-comment">//        session.setAttribute(&quot;kaptcha&quot;,text);</span><br><br>        <span class="hljs-comment">//验证码的归属，将验证码的信息发送给浏览器，保存到cookie中。</span><br>        String kaptchaOwner = CommunityUtil.generateUUID();<br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;kaptchaOwner&quot;</span>,kaptchaOwner);<br>        cookie.setMaxAge(<span class="hljs-number">60</span>);<br>        cookie.setPath(contextPath);<br>        response.addCookie(cookie);<br><br>        <span class="hljs-comment">//将验证码存储到redis中。</span><br>        String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);<br>        redisTemplate.opsForValue().set(redisKey,text,<span class="hljs-number">60</span>, TimeUnit.SECONDS);<br><br><br>        <span class="hljs-comment">//将图片输出给浏览器,确定图片的格式是png</span><br>        response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//通过OutputStream输出流的方式向前端发回数据。</span><br>            OutputStream os = response.getOutputStream();<br>            ImageIO.write(image,<span class="hljs-string">&quot;png&quot;</span>,os);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;响应验证码失败：&quot;</span>+e.getMessage());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>登录的时候，将cookie中的验证码信息跟redis数据库中的验证码信息进行比较，进行登录验证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;/login&quot;,method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username,String password,String code,<span class="hljs-keyword">boolean</span> rememberMe,</span></span><br><span class="hljs-params"><span class="hljs-function">                    Model model<span class="hljs-comment">/*HttpSession session*/</span>,HttpServletResponse response,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-meta">@CookieValue(&quot;kaptchaOwner&quot;)</span> String kaptchaOwner)</span></span>&#123;<br>    <span class="hljs-comment">//String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);</span><br>    String kaptcha = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(kaptchaOwner))&#123;<br>        String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);<br>        kaptcha = (String) redisTemplate.opsForValue().get(redisKey);<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="（2）使用redis存储登录凭证"><a href="#（2）使用redis存储登录凭证" class="headerlink" title="（2）使用redis存储登录凭证"></a>（2）使用redis存储登录凭证</h3><p>登录时候会生成一个ticket</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成一个ticket的key，然后保存到redis中</span><br>String redisKey = RedisKeyUtil.getTicket(loginTicket.getTicket());<br>redisTemplate.opsForValue().set(redisKey, loginTicket);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(String ticket)</span></span>&#123;<br><span class="hljs-comment">//        loginTicketDao.updateStatus(ticket,1);   //1表示无效</span><br>        <span class="hljs-comment">//先从redis中获取，然后把状态修改为1，再存进去</span><br>        String redisKey = RedisKeyUtil.getTicket(ticket);<br>        LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);<br>        loginTicket.setStatus(<span class="hljs-number">1</span>);<br>        redisTemplate.opsForValue().set(redisKey,loginTicket);<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>（3）使用redis缓存用户信息</p>
<p>进行查询用户操作时，先去缓存中查找有没有user（1）。如果没有的话就去数据库中进行查找，查找到对应的user信息并将其写入到缓存中（2）。</p>
<p>如果用户信息信息发生改变就删除缓存中的用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">//根据id查找用户</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">selectById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-comment">//        User user = userDao.selectById(id);</span><br><span class="hljs-comment">//        return user;</span><br>        <span class="hljs-comment">//先去缓存中去user数据，如果没有的话就去数据库中找，并在缓存中初始化一个数据。</span><br>        User user = getCache(id);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            user = initCache(id);<br>        &#125;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br><br><br><span class="hljs-comment">//1.优先从缓存中取值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">getCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;<br>    String redisKey = RedisKeyUtil.getUserKey(userId);<br>    <span class="hljs-keyword">return</span> (User) redisTemplate.opsForValue().get(redisKey);<br>&#125;<br><span class="hljs-comment">//2.取不到时初始化缓存数据</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">initCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;<br>    User user = userDao.selectById(userId);<br>    String redisKey = RedisKeyUtil.getUserKey(userId);<br>    redisTemplate.opsForValue().set(redisKey,user,<span class="hljs-number">3600</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br><br><span class="hljs-comment">//3.数据变更时清除缓存数据</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span></span>&#123;<br>    String redisKey = RedisKeyUtil.getUserKey(userId);<br>    redisTemplate.delete(redisKey);<br>&#125;<br></code></pre></td></tr></table></figure>







<h1 id="Kafka，构架TB级一步消息系统"><a href="#Kafka，构架TB级一步消息系统" class="headerlink" title="Kafka，构架TB级一步消息系统"></a>Kafka，构架TB级一步消息系统</h1><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210914151551505.png" alt="image-20210914151551505"></p>
<p>调用Java中的API接口：==BlockingQueue==</p>
<p>测试例子（生产者消费者）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.community.testBlocking;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueueTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BlockingQueue queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">new</span> Thread( <span class="hljs-keyword">new</span> Produce(queue)).start();<br>        <span class="hljs-keyword">new</span> Thread( <span class="hljs-keyword">new</span> Consumer(queue)).start();<br>        <span class="hljs-keyword">new</span> Thread( <span class="hljs-keyword">new</span> Consumer(queue)).start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Produce</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Integer&gt; blockingQueue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Produce</span><span class="hljs-params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.blockingQueue = blockingQueue;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>                blockingQueue.put(i);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;生产&quot;</span> + blockingQueue.size());<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Integer&gt; blockingQueue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.blockingQueue = blockingQueue;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));<br>                blockingQueue.take();       <span class="hljs-comment">//消费</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;消费&quot;</span> +blockingQueue.size());<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="kafka入门"><a href="#kafka入门" class="headerlink" title="kafka入门"></a>kafka入门</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20210915104045480.png" alt="image-20210915104045480"></p>
<h3 id="（1）kafka用于消息队列"><a href="#（1）kafka用于消息队列" class="headerlink" title="（1）kafka用于消息队列"></a>（1）kafka用于消息队列</h3><ul>
<li>消息持久化：数据放到硬盘中，硬盘中的顺序读取会高于内存中的随机读取。</li>
</ul>
<p>Broker：kafka的服务器 </p>
<p>Zookeeper：管理集群。</p>
<p>Topic：主题。文件夹，用来存放消息的位置。</p>
<p>partition：分区。</p>
<p>leader replica：主副本。</p>
<p>follower replica：随从副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@ContextConfiguration(classes = SpringbootNewCoderApplication.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaTests</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KafkaProducer kafkaProducer;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testKafka</span><span class="hljs-params">()</span></span>&#123;<br>        kafkaProducer.sendMessage(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;你好&quot;</span>);<br>        kafkaProducer.sendMessage(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaProducer</span></span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate kafkaTemplate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String topic,String content)</span></span>&#123;<br>        kafkaTemplate.send(topic,content);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConsumer</span></span>&#123;<br>    <span class="hljs-meta">@KafkaListener(topics = &#123;&quot;test&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(ConsumerRecord record)</span></span>&#123;<br>        System.out.println(record.value());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2021/11/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9AKafka/</url>
    <content><![CDATA[<p>Kafka是一个分布式的基于发布、订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。</p>
<span id="more"></span>

<h1 id="Kafka概述"><a href="#Kafka概述" class="headerlink" title="Kafka概述"></a>Kafka概述</h1><p>Kafka是一个分布式的基于发布、订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。</p>
<p>中间件。常用于做消息队列，处理实时问题。例如：</p>
<ul>
<li>实时支付和金融交易。</li>
<li>实时跟踪和监控汽车。</li>
<li>监测住院病人并预测病情变化。</li>
<li>收集客户互动信息和订单信息并作出反应。</li>
</ul>
<p>关键字：中间件，解耦，实时。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211227144038229.png" alt="image-20211227144038229"></p>
<h3 id="使用消息队列的好处："><a href="#使用消息队列的好处：" class="headerlink" title="使用消息队列的好处："></a>使用消息队列的好处：</h3><p>（1）解耦</p>
<p>（2）可恢复性：系统中的一部分失效，不会影响到整个系统。</p>
<p>（3）缓冲：有助于控制和延缓数据流经过系统的速度，解决生产消息和消费消息处理速度不一致的情况。</p>
<p>（4）灵活性 &amp; 峰值处理能力。</p>
<p>（5）异步通信。</p>
<h3 id="消息队列的两种模式："><a href="#消息队列的两种模式：" class="headerlink" title="消息队列的两种模式："></a>消息队列的两种模式：</h3><p>（1）点对点模式（<strong>一对一</strong>，消费者主动拉取数据，消息收到后消息清除）</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211227144055848.png" alt="image-20211227144055848"></p>
<p>缺点：不可复用。</p>
<p>（2）发布订阅模式（<strong>一对多</strong>，消费者消费数据之后不会清除消息）</p>
<p>消息发布者将消息发布到topic（主题）中，同时多个消费者（订阅）消费该消息。但是topic中的消息是有一个过期时间的。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211227144107611.png" alt="image-20211227144107611"></p>
<p>有两种方式：</p>
<ol>
<li>消息队列主动推送消息（消费者是被动接收的）</li>
<li>消费者主动拉取消息。</li>
</ol>
<h1 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h1><p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20211227144630233.png" alt="image-20211227144630233"></p>
<p>1）<strong>Producer</strong> ：消息生产者，就是向Kafka broker发消息的客户端；</p>
<p>2）<strong>Consumer</strong> ：消息消费者，向Kafka broker取消息的客户端；</p>
<p>3） <strong>Consumer Group</strong> （CG）：消费者组</p>
<p>4）<strong>Broker</strong> ：kafka实例，每台服务器上可以有一个或者多个实例。一个集群由多个broker组成。一个broker可以容纳多个topic；</p>
<p>5）<strong>Topic</strong> ：消息的主题。kafka中的所有数据都保存在topic中</p>
<p>6）<strong>Partition</strong>：Topic的分区，每个Topic有多个分区，分区的目的是负载，提高kafka的吞吐量。（同一个分区中的数据是有序的）</p>
<p>7）<strong>Replication</strong>：备份，每一个Partition都有多个备份。当一个Leader崩溃了之后，会从follower中选举出来一个新的Leader。写入生产数据、消费数据都是对Leader进行操作。</p>
<p>8）<strong>Message</strong>：消息主体。</p>
<p>9）<strong>Offset</strong>：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka。</p>
<p>10）<strong>Zookeeper</strong>：kafka集群依赖zookeeper来保存集群的元信息，保证系统的可用性。</p>
<h1 id="Kafka工作流程"><a href="#Kafka工作流程" class="headerlink" title="Kafka工作流程"></a>Kafka工作流程</h1><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><p>producer就是生产者，是数据的入口。Producer在写入数据的时候<strong>永远的找leader</strong>，不会直接将数据写入follower！</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-b7e72e9c5b9971e89ec174a2c2201ed9_720w.jpg" alt="img"></p>
<p>消息写入leader后，follower主动拉取leader中的信息进行同步！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证<strong>同一分区</strong>内的数据是有序的！写入示意图如下：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-87d558aaa349bf920711b9c157e11f6a_r.jpg" alt="preview"></p>
<h3 id="问题1：kafka为什么要做分区？"><a href="#问题1：kafka为什么要做分区？" class="headerlink" title="问题1：kafka为什么要做分区？"></a>问题1：kafka为什么要做分区？</h3><p><strong>1、 方便扩展</strong>。因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。</p>
<p><strong>2、 提高并发</strong>。以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</p>
<h3 id="问题2：怎么确定消息要写入哪一个分区？"><a href="#问题2：怎么确定消息要写入哪一个分区？" class="headerlink" title="问题2：怎么确定消息要写入哪一个分区？"></a>问题2：怎么确定消息要写入哪一个分区？</h3><p>1、 partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。</p>
<p>2、 如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。</p>
<p>3、 如果既没指定partition，又没有设置key，则会轮询选出一个partition</p>
<h3 id="问题3：kafka怎么确保信息不丢失"><a href="#问题3：kafka怎么确保信息不丢失" class="headerlink" title="问题3：kafka怎么确保信息不丢失"></a>问题3：kafka怎么确保信息不丢失</h3><p>通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为<strong>0</strong>、<strong>1</strong>、<strong>all</strong>。</p>
<ul>
<li><strong>0</strong>代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li>
<li><strong>1</strong>代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。</li>
<li><strong>all</strong>代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li>
</ul>
<p>默认配置是1.</p>
<h2 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a>数据保存</h2><p>kafka的数据是保存在磁盘上的。</p>
<p>写入磁盘会耗时？kafka初始化时会单独的开辟一块磁盘空间，顺序写入数据（效率比随机写入快）。</p>
<h3 id="Partition结构"><a href="#Partition结构" class="headerlink" title="Partition结构"></a>Partition结构</h3><p>Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， <strong>log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息</strong>。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-72e50c12fd9c6fbf58d3b5ca14c90623_r.jpg" alt="preview"></p>
<p>如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。<strong>文件的命名是以该segment最小offset来命名的</strong>，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。</p>
<h3 id="Message结构"><a href="#Message结构" class="headerlink" title="Message结构"></a>Message结构</h3><p>1、 offset：8byte的有序id号，它可以唯一确定每条消息在parition内的位置。</p>
<p>2、 消息大小：4byte，用于描述消息的大小。</p>
<p>3、 消息体：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</p>
<h3 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h3><p>无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？</p>
<p>1、 基于时间，默认配置是168小时（7天）。</p>
<p>2、 基于大小，默认配置是1073741824。</p>
<p>需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！</p>
<h2 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h2><p>消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。<strong>Kafka采用的是发布订阅的模式</strong>，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是<strong>找leader</strong>去拉取。</p>
<p>多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！<strong>同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据</strong>！！！</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-75a79cba9cfafe5c2f4d5349acb72207_r.jpg" alt="preview"></p>
<p>建议<strong>消费者组的consumer的数量与partition的数量一致</strong>！</p>
<h3 id="查找消息"><a href="#查找消息" class="headerlink" title="查找消息"></a>查找消息</h3><p>在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-87051d884344edf9f8fd97a3dacb32d0_r.jpg" alt="preview"></p>
<p>1、 先找到offset的368801message所在的segment文件（利用<strong>二分法查找</strong>），这里找到的就是在第二个segment文件。</p>
<p>2、 打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的<strong>相对offset</strong>为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样<strong>利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。</strong></p>
<p>3、 根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。</p>
<p>这套机制是建立在offset为有序的基础上，利用<strong>segment</strong>+<strong>有序offset</strong>+<strong>稀疏索引</strong>+<strong>二分查找</strong>+<strong>顺序查找</strong>等多种手段来高效的查找数据！</p>
<p>消费者记录消费的数据：</p>
<ul>
<li>旧版本：将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好。</li>
<li>消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！不需要借助Zookeeper。</li>
</ul>
<h1 id="Java连接Kafka做消息队列"><a href="#Java连接Kafka做消息队列" class="headerlink" title="Java连接Kafka做消息队列"></a>Java连接Kafka做消息队列</h1><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--kafka--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>配置信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#kafka</span><br><span class="hljs-comment">###########【Kafka集群】###########</span><br><span class="hljs-meta">spring.kafka.bootstrap-servers</span>=<span class="hljs-string">127.0.0.1:9092</span><br><span class="hljs-comment">###########【初始化生产者配置】###########</span><br><span class="hljs-comment"># 重试次数</span><br><span class="hljs-meta">spring.kafka.producer.retries</span>=<span class="hljs-string">0</span><br><span class="hljs-comment"># 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)</span><br><span class="hljs-meta">spring.kafka.producer.acks</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 批量大小</span><br><span class="hljs-meta">spring.kafka.producer.batch-size</span>=<span class="hljs-string">16384</span><br><span class="hljs-comment"># 提交延时</span><br><span class="hljs-meta">spring.kafka.producer.properties.linger.ms</span>=<span class="hljs-string">0</span><br><span class="hljs-comment"># 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka</span><br><span class="hljs-comment"># linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了</span><br><span class="hljs-comment"># 生产端缓冲区大小</span><br><span class="hljs-meta">spring.kafka.producer.buffer-memory</span> = <span class="hljs-string">33554432</span><br><span class="hljs-comment"># Kafka提供的序列化和反序列化类</span><br><span class="hljs-meta">spring.kafka.producer.key-serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br><span class="hljs-meta">spring.kafka.producer.value-serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br><span class="hljs-comment"># 自定义分区器</span><br><span class="hljs-comment"># spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.CustomizePartitioner</span><br><span class="hljs-comment">###########【初始化消费者配置】###########</span><br><span class="hljs-comment"># 默认的消费组ID</span><br><span class="hljs-meta">spring.kafka.consumer.properties.group.id</span>=<span class="hljs-string">defaultConsumerGroup</span><br><span class="hljs-comment"># 是否自动提交offset</span><br><span class="hljs-meta">spring.kafka.consumer.enable-auto-commit</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 提交offset延时(接收到消息后多久提交offset)</span><br><span class="hljs-meta">spring.kafka.consumer.auto.commit.interval.ms</span>=<span class="hljs-string">1000</span><br><span class="hljs-comment"># 当kafka中没有初始offset或offset超出范围时将自动重置offset</span><br><span class="hljs-comment"># earliest:重置为分区中最小的offset;</span><br><span class="hljs-comment"># latest:重置为分区中最新的offset(消费分区中新产生的数据);</span><br><span class="hljs-comment"># none:只要有一个分区不存在已提交的offset,就抛出异常;</span><br><span class="hljs-meta">spring.kafka.consumer.auto-offset-reset</span>=<span class="hljs-string">latest</span><br><span class="hljs-comment"># 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)</span><br><span class="hljs-meta">spring.kafka.consumer.properties.session.timeout.ms</span>=<span class="hljs-string">120000</span><br><span class="hljs-comment"># 消费请求超时时间</span><br><span class="hljs-meta">spring.kafka.consumer.properties.request.timeout.ms</span>=<span class="hljs-string">180000</span><br><span class="hljs-comment"># Kafka提供的序列化和反序列化类</span><br><span class="hljs-meta">spring.kafka.consumer.key-deserializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="hljs-meta">spring.kafka.consumer.value-deserializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="hljs-comment"># 消费端监听的topic不存在时，项目启动会报错(关掉)</span><br><span class="hljs-meta">spring.kafka.listener.missing-topics-fatal</span>=<span class="hljs-string">false</span><br><span class="hljs-comment"># 设置批量消费</span><br><span class="hljs-comment"># spring.kafka.listener.type=batch</span><br><span class="hljs-comment"># 批量消费每次最多消费多少条消息</span><br><span class="hljs-comment"># spring.kafka.consumer.max-poll-records=50</span><br></code></pre></td></tr></table></figure>

<p>生产者，发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;Object, Object&gt; kafkaTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产者</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message：消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/kafka/&#123;message&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;message&quot;)</span> String message)</span> </span>&#123;<br>        kafkaTemplate.send(<span class="hljs-string">&quot;topic1&quot;</span>,<span class="hljs-string">&quot;key&quot;</span>, message);    <span class="hljs-comment">//发送数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>消费者监控指定主题，当生产者发送消息之后，消费者进行消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;<br><br>    <span class="hljs-comment">//监听当前的topic。当前topic中有数据的话，就进行消费</span><br>    <span class="hljs-meta">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;)</span><br>    <span class="hljs-comment">//创建一条记录，以从指定的主题和分区接收</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage1</span><span class="hljs-params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费简单模拟主题：&quot;</span> + record.topic());<br>        System.out.println(<span class="hljs-string">&quot;offset:&quot;</span> + record.offset());<br>        System.out.println(<span class="hljs-string">&quot;timestamp&quot;</span> + record.timestamp());<br>        System.out.println(record.key());<br>        System.out.println(record.value());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>关系型数据库：MySQL</title>
    <url>/2021/10/16/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySQL/</url>
    <content><![CDATA[<p>MySQL是一个<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/696511">关系型数据库管理系统</a>，由瑞典[MySQL AB](<a href="https://baike.baidu.com/item/MySQL">https://baike.baidu.com/item/MySQL</a> AB/2620844) 公司开发，属于 <a href="https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品。MySQL 是最流行的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/696511">关系型数据库管理系统</a>之一，在 <a href="https://baike.baidu.com/item/WEB/150564">WEB</a> 应用方面，MySQL是最好的 <a href="https://baike.baidu.com/item/RDBMS/1048260">RDBMS</a> (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<span id="more"></span>

<h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><h2 id="1、使用数据库的优势"><a href="#1、使用数据库的优势" class="headerlink" title="1、使用数据库的优势"></a>1、使用数据库的优势</h2><p>使用数据库有两个优势：</p>
<ul>
<li>持久化数据到本地。</li>
<li>可以实现结构化查询，方便管理。</li>
</ul>
<h2 id="2、数据库相关概念"><a href="#2、数据库相关概念" class="headerlink" title="2、数据库相关概念"></a>2、数据库相关概念</h2><p>**DB(Database)**：数据库，保存一组有组织的数据的容器。</p>
<p>**DBMS(Database Management System)**：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据。</p>
<p>**SQL(Structured Query Language)**：结构化查询语言，用于和DBMS通信的语言，包括数据插入、查询、更新、删除，数据库模式创建和修改，以及数据访问控制。</p>
<h2 id="3、SQL的语言分类"><a href="#3、SQL的语言分类" class="headerlink" title="3、SQL的语言分类"></a>3、SQL的语言分类</h2><p><strong>DDL(Data Definition Language)<strong>：数据定义语言。允许用户</strong>定义</strong>数据，包括创建（create）、删除（drop）、修改（alter）这些操作。通常，DDL由数据库管理员执行。</p>
<p><strong>DML(Data Manipulation Language</strong>)：数据操作语言。DML为用户提供添加（insert）、删除（delete）、更新数据（update）的能力，这些是应用程序对数据库的日常操作。</p>
<p>**DQL(Data Query Language)**：数据查询语言，执行查询（select）操作。<br>**TCL(Transaction Control Language)**：事务控制语言，执行commit、rollback等操作。</p>
<h1 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h1><h2 id="1、什么是关系型数据库"><a href="#1、什么是关系型数据库" class="headerlink" title="1、什么是关系型数据库"></a>1、什么是关系型数据库</h2><p>**RDBMS(Relational Database Management System)**：关系型数据库管理系统，即基于关系模型的数据库。</p>
<p><strong>关系模型</strong>把数据看作是一个二维表格，任何数据都可以通过行号和列号来唯一确定，它的数据模型看起来就是一个Excel表。</p>
<h2 id="2、RDBMS存储数据的特点"><a href="#2、RDBMS存储数据的特点" class="headerlink" title="2、RDBMS存储数据的特点"></a>2、RDBMS存储数据的特点</h2><p>RDBMS存储数据的特点：</p>
<ul>
<li>数据以表格的形式出现，每个表都有唯一的名字，用于标识自己。</li>
<li>若干的表格组成数据库。</li>
<li>表本身具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>表中的<strong>列</strong>也称为<strong>字段（Column）</strong>。列类似于java 中的”属性”。</li>
<li>表中的<strong>行</strong>称为<strong>记录（Record）</strong>，每一行是一组相关的数据。行类似于java中的“对象”。</li>
</ul>
<h2 id="3、常见的关系型数据库"><a href="#3、常见的关系型数据库" class="headerlink" title="3、常见的关系型数据库"></a>3、常见的关系型数据库</h2><ul>
<li>商用数据库，例如：<a href="https://www.oracle.com/">Oracle</a>，<a href="https://www.microsoft.com/sql-server/">SQL Server</a>，<a href="https://www.ibm.com/db2/">DB2</a>等；</li>
<li>开源数据库，例如：<a href="https://www.mysql.com/">MySQL</a>，<a href="https://www.postgresql.org/">PostgreSQL</a>等；</li>
<li>桌面数据库，以微软<a href="https://products.office.com/access">Access</a>为代表，适合桌面应用程序使用；</li>
<li>嵌入式数据库，以<a href="https://sqlite.org/">Sqlite</a>为代表，适合手机应用和桌面程序。</li>
</ul>
<h2 id="4、NoSQL"><a href="#4、NoSQL" class="headerlink" title="4、NoSQL"></a>4、NoSQL</h2><p>NoSQL数据库，也就是非SQL的数据库，包括MongoDB、Cassandra、Dynamo等等，它们都不是关系数据库。SQL数据库从始至终从未被取代过，NoSQL的发展历程：</p>
<ul>
<li>1970: NoSQL = We have no SQL</li>
<li>1980: NoSQL = Know SQL</li>
<li>2000: NoSQL = No SQL!</li>
<li>2005: NoSQL = Not only SQL</li>
<li>2013: NoSQL = No, SQL!</li>
</ul>
<p>今天，SQL数据库仍然承担了各种应用程序的核心数据存储，而NoSQL数据库作为SQL数据库的补充，两者不再是二选一的问题，而是主从关系。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1、MySQL介绍"><a href="#1、MySQL介绍" class="headerlink" title="1、MySQL介绍"></a>1、MySQL介绍</h2><p>MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。</p>
<p>MySQL优势：</p>
<ul>
<li>开源、免费、成本低</li>
<li>性能高、移植性好</li>
<li>体积小，便于安装</li>
</ul>
<h2 id="2、MySQL安装"><a href="#2、MySQL安装" class="headerlink" title="2、MySQL安装"></a>2、MySQL安装</h2><p>MySQL属于c/s架构的软件，一般来讲只安装服务端。以下案例以 MySQL5.7 为例</p>
<p>下载<a href="https://dev.mysql.com/downloads/mysql/">链接</a></p>
<h2 id="3、MySQL服务的启动和停止"><a href="#3、MySQL服务的启动和停止" class="headerlink" title="3、MySQL服务的启动和停止"></a>3、MySQL服务的启动和停止</h2><p>Windows下，MySQL启动和停止有两种方式：</p>
<ul>
<li>计算机—右击管理—服务，启动MySQL服务</li>
<li>通过管理员身份运行cmd：<ul>
<li>net start 服务名（启动服务），例<code>net start mysql57</code></li>
<li>net stop 服务名（停止服务），例<code>net stop mysql57</code></li>
</ul>
</li>
</ul>
<h2 id="4、MySQL服务的登录和退出"><a href="#4、MySQL服务的登录和退出" class="headerlink" title="4、MySQL服务的登录和退出"></a>4、MySQL服务的登录和退出</h2><p> 方式一：通过mysql自带的客户端（MySQL Line Client），只限于root用户</p>
<p> 方式二：通过windows的命令提示符，以管理员身份打开</p>
<ul>
<li><p>登录：<code>mysql [-h 主机名 -P 端口号] -u 用户名 -p密码</code>，<code>[]</code>里的内容表示可以省略</p>
<blockquote>
<p>其中<code>p</code>参数和密码直接不能有空格，其他参数和值之间空格可有可无，比如<code>-uroot</code>，表示root用户。</p>
<p>密码可以不添加值，直接回车，然后输入密码，不会显示出明文。</p>
<p>如果是本机，并且端口是3306，可以省略<code>-h</code>和<code>-P</code>参数，直接输入用户名和密码即可。</p>
</blockquote>
</li>
<li><p>退出：<code>exit</code></p>
</li>
</ul>
<p>如下图：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_1.png"><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/mysql-basis_1.png" alt="img"></a></p>
<h2 id="5、MySQL的常见命令"><a href="#5、MySQL的常见命令" class="headerlink" title="5、MySQL的常见命令"></a>5、MySQL的常见命令</h2><p>查看当前所有的数据库:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">show databases<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>打开指定的库:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">use 库名<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>查看当前库的所有表:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br></code></pre></td></tr></table></figure>

<p>查看其它库的所有表：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span> <span class="hljs-keyword">from</span> 库名;<br></code></pre></td></tr></table></figure>

<p>查看表结构：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">desc 表名<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>查看表的列属性：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></table></figure>

<p>查看表的索引：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></table></figure>

<p>查看xx状态：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 查看指定表的状态信息</span><br>show table status from 表名/数据库;<br><br><span class="hljs-comment"># 查看主从复制中的主机状态</span><br>show <span class="hljs-keyword">master</span> <span class="hljs-title">status</span>;<br><br><span class="hljs-comment"># 查看主从复制中从机状态</span><br>show <span class="hljs-literal">slave</span> status;<br></code></pre></td></tr></table></figure>

<p>查看服务器的版本：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 方式一，在mysql服务端查看：</span><br>select <span class="hljs-built_in">version</span>();<br><span class="hljs-comment"># 方式二，在cmd窗口查看：</span><br>mysql <span class="hljs-comment">--version</span><br>或<br>mysql <span class="hljs-comment">--V</span><br></code></pre></td></tr></table></figure>

<p>用户管理指令：</p>
<p><strong>添加用户的两种方式</strong></p>
<p>1、使用insert指令，在mysql.user表中添加用户：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 比如想添加用户：<span class="hljs-keyword">user</span>，密码：<span class="hljs-number">123456</span>，并授予<span class="hljs-keyword">select</span>权限<br># 只需要在<span class="hljs-keyword">user</span>表的指定列添加内容即可。<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> mysql.<span class="hljs-keyword">user</span>(host,<span class="hljs-keyword">user</span>,<span class="hljs-keyword">password</span>，select_priv)<br>	<span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-keyword">password</span>(<span class="hljs-string">&#x27;123456&#x27;</span>),<span class="hljs-string">&#x27;Y&#x27;</span>);<br>flush <span class="hljs-keyword">privileges</span>;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">其中host列表示限制登陆的主机，localhost表示只能当前主机登陆，</span><br><span class="hljs-comment">可以指定ip，使用%表示任意主机。</span><br><span class="hljs-comment">MySQL5.7以后，password改名为authentication_string。</span><br><span class="hljs-comment">密码需要使用password()函数进行加密，MySQL8.0.11移除了这个函数，可以使用MD5()代替。</span><br><span class="hljs-comment">可以根据需求授予其他权限，只需要相应列赋值为&#x27;Y&#x27;即可。</span><br><span class="hljs-comment">添加完后，使用flush privileges语句刷新授权表，使之立即生效，</span><br><span class="hljs-comment">否则需要重启MySQL服务才生效。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>2、使用grant命令</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 比如给指定数据库比如student库，添加用户user，密码123,授予select权限</span><br><span class="hljs-attribute">grant</span> <span class="hljs-literal">select</span>   <span class="hljs-comment"># 指定授予的权限</span><br><span class="hljs-literal">on</span> <span class="hljs-regexp">student.*</span>   <span class="hljs-comment"># 指定数据库和表，*表示所有，这里表示student库所有表</span><br>to <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>  <span class="hljs-comment"># 指定用户名和登陆主机，localhost根据需求填写</span><br>indentified by <span class="hljs-string">&#x27;123&#x27;</span>;   <span class="hljs-comment"># 指定登录密码。</span><br></code></pre></td></tr></table></figure>

<p>grant指令更多内容，参考<a href="https://dev.mysql.com/doc/refman/8.0/en/grant.html#grant-overview">GRANT Statement</a></p>
<h2 id="6、MySQL的语法规范"><a href="#6、MySQL的语法规范" class="headerlink" title="6、MySQL的语法规范"></a>6、MySQL的语法规范</h2><p>MySQL中的命令有以下规范：</p>
<ul>
<li><strong>不区分大小写</strong>，建议关键字大写，表名和列名小写</li>
<li>每条命令以<code>;</code>或<code>\g</code>结尾</li>
<li>每条命令根据需要，可以进行缩进或换行。关键字不能缩写或分行。</li>
<li>注释<ul>
<li>单行注释：<code>#注释文字</code></li>
<li>单行注释：<code>-- 注释文字</code>,(注意<code>--</code>后面有空格)</li>
<li>多行注释：<code>/* 注释文字 */</code></li>
</ul>
</li>
</ul>
<p>字符（建议加，有时必须加）和日期型要加引号，数值不需要加。<strong>表的别名不需要加引号</strong></p>
<h1 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h1><p>MySQL支持所有标准SQL数值数据类型（SQL数据类型参考<a href="https://www.runoob.com/sql/sql-datatypes-general.html">链接</a>）。作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。详细参考<a href="https://www.runoob.com/mysql/mysql-data-types.html">MySQL数据类型</a></p>
<p><strong>MySQL中的TRUE和FALSE，也可以分别用1和0表示。</strong></p>
<p>MySQL中的数据类型包括<strong>数值型</strong>、<strong>字符型</strong>、<strong>日期型</strong>等。</p>
<p><strong>数值型</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>类型</strong></th>
<th><strong>字节</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>整型</td>
<td>Tinyint</td>
<td>1</td>
<td>有符号：-128<del>127 无符号：0</del>255</td>
</tr>
<tr>
<td>Smallint</td>
<td>2</td>
<td>有符号：-32768<del>32767 无符号：0</del>65535</td>
<td></td>
</tr>
<tr>
<td>Mediumint</td>
<td>3</td>
<td>有符号：-8,388,608<del>8,388,607 无符号：0</del>16,777,215</td>
<td></td>
</tr>
<tr>
<td>Int/Integer</td>
<td>4</td>
<td>有符号：-2,147,483,648<del>2,147,483,647 无符号：0</del>4,294,967,296</td>
<td></td>
</tr>
<tr>
<td>Bigint</td>
<td>8</td>
<td>有符号：-2^63<del>2^63-1 无符号：0</del>2^64</td>
<td></td>
</tr>
<tr>
<td>浮点型小数</td>
<td>float(M,D)</td>
<td>4</td>
<td>±1.75494351E-38 ~ ±3.402823466E+38</td>
</tr>
<tr>
<td>double(M,D)</td>
<td>8</td>
<td>±2.2250738585072014E-308 ~ ±1.7976931348623157E+308</td>
<td></td>
</tr>
<tr>
<td>定点型小数</td>
<td>DEC(M,D) DECIMAL(M,D)</td>
<td>M+2</td>
<td>最大取值范围与double相同， 给定decimal的有效取值范围由M和D决定</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li>如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要在类型后面添加<code>unsigned</code>关键字</li>
<li>如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值</li>
<li>如果不设置长度，会有默认的长度。长度不决定范围，长度代表了显示的最大宽度。可以选择在长度不够时，用0在左边填充，需要在类型后面添加<code>zerofill</code>。zerofill只支持正数（无符号）</li>
<li>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</li>
<li>M表示整数部位个数+小数部位个数的总长度。D表示小数部位长度。如果插入的数值超过范围，会报out of range异常，并插入临界值。</li>
<li>M和D都可以省略。如果是decimal，则M默认为10，D默认为0。</li>
<li>float和double，会根据插入的数值的精度来决定精度。</li>
</ul>
<p><strong>字符型</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>最多字符数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>char(M)</td>
<td>M</td>
<td>M为0~255之间的整数，固定长度的字符，比较耗费空间，效率高</td>
</tr>
<tr>
<td>varchar(M)</td>
<td>M</td>
<td>M为0~65535之间的整数，可变长度的字符，比较节省空间，效率低</td>
</tr>
</tbody></table>
<p>M表示最大的字符个数，而不是存储空间。</p>
<p>M</p>
<p>其他字符型类型：</p>
<ul>
<li><code>binary</code>和<code>varbinary</code>用于保存较短的二进制</li>
<li><code>enum</code>用于保存枚举类型，要求插入的值必须属于列表中指定的值之一。如果列表成员为<code>1~255</code>，则需要1个字节存储。如果列表成员为<code>255~65535</code>，则需要2个字节存储，最多为65535个成员。</li>
<li><code>set</code>用于保存集合。里面可以保存0~64个成员。一次可以选取多个成员。根据成员个数不同，存储所占的字节从1-8变化。</li>
<li><code>text</code>用于存放较长的文本</li>
<li><code>blob</code>用于存放较大的二进制</li>
</ul>
<p><strong>日期型</strong></p>
<table>
<thead>
<tr>
<th>日期和时间类型</th>
<th>字节</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td><code>date</code></td>
<td>4</td>
<td>1000-01-01</td>
<td>9999-12-31</td>
</tr>
<tr>
<td><code>datetime</code></td>
<td>8</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>4</td>
<td>1970-01-01 00:00:00</td>
<td>2038-1-19某一时刻</td>
</tr>
<tr>
<td><code>time</code></td>
<td>3</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td><code>year</code></td>
<td>1</td>
<td>1901</td>
<td>2155</td>
</tr>
</tbody></table>
<p>其中字符型和日期型的常量值必须要用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>包起来。数值型不需要。</p>
<p><strong>datetime和timestamp的对比</strong></p>
<ul>
<li>二者都是保存日期和时间。</li>
<li>datetime占用8字节，范围是1000-9999，不受时区的影响。</li>
<li>timestamp占用4字节，范围为1970-2038，受时区的影响，其值会根据时区的变化而变化。即插入数据以后，如果修改时区，表中的时间戳也会改变为对应时区的值。</li>
</ul>
<h1 id="DQL语言"><a href="#DQL语言" class="headerlink" title="DQL语言"></a>DQL语言</h1><p>DQL为数据查询语言，执行查询（select）操作。</p>
<p>DQL的完整查询语句结构：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> 字段,...				<span class="hljs-meta"># 7</span><br><span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> [别名]				<span class="hljs-meta"># 1</span><br>[<span class="hljs-meta">连接类型 join 表2</span>]...			<span class="hljs-meta"># 2</span><br>[<span class="hljs-meta">on 连接条件</span>]				<span class="hljs-meta"># 3</span><br>[<span class="hljs-meta">where 筛选条件</span>]			<span class="hljs-meta"># 4</span><br>[<span class="hljs-meta">group by 分组字段</span>]			<span class="hljs-meta"># 5</span><br>[<span class="hljs-meta">having 分组后的筛选条件</span>]		<span class="hljs-meta"># 6</span><br>[<span class="hljs-meta">order by 排序的字段或表达式</span>]		<span class="hljs-meta"># 8</span><br>[<span class="hljs-meta">limit 偏移量(起始条目索引),条数</span>]; 	<span class="hljs-meta"># 9</span><br></code></pre></td></tr></table></figure>

<p>以上各部分的执行顺序：<br><code>from</code>→<code>join</code>→<code>on</code>→<code>where</code>→<code>group by</code>(开始使用select中的别名，后面的语句都可以使用)-</p>
<p>→<code>AVG/SUM/MAX/MIN等分组函数</code>→<code>having</code>→<code>select</code>→<code>distinct</code>→<code>order by</code>→<code>limit</code></p>
<p>以下案例使用的数据库：<code>myemployees</code>，其中有<code>departments</code>、<code>employees</code>、<code>job_grades</code>、<code>jobs</code>、<code>locations</code>共五张表。各自的包含的字段如下：</p>
<p><code>departments</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_3.png"><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/mysql-basis_3.png" alt="img"></a></p>
<p><code>employees</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_2.png"><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/mysql-basis_2.png" alt="img"></a></p>
<p><code>job_grades</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_4.png"><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/mysql-basis_4.png" alt="img"></a></p>
<p><code>jobs</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_5.png"><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/mysql-basis_5.png" alt="img"></a></p>
<p><code>locations</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_6.png"><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/mysql-basis_6.png" alt="img"></a></p>
<h2 id="1、基础查询"><a href="#1、基础查询" class="headerlink" title="1、基础查询"></a>1、基础查询</h2><p>语法：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> 查询内容 [<span class="hljs-keyword">FROM</span> 表名];<br></code></pre></td></tr></table></figure>

<blockquote>
<p>类似于Java中的System.out.println(要打印的东西);</p>
<p>查询的结果是一个虚拟的表，不会改变原来的表格。</p>
</blockquote>
<p>特点：<br>①通过select查询出的结果 ，是一个虚拟的表格，不是真实存在</p>
<p>②查询内容可以是<strong>常量值</strong>、<strong>表达式</strong>、<strong>字段</strong>、<strong>函数</strong></p>
<p>示例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#1.查询单个字段<br><span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">FROM</span> employees;<br><br>#2.查询多个字段<br><span class="hljs-keyword">SELECT</span> last_name,salary,email <span class="hljs-keyword">FROM</span> employees;<br><br>#3.查询所有字段<br><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-symbol">`employee_id`</span>,<br>    <span class="hljs-symbol">`first_name`</span>,<br>    <span class="hljs-symbol">`last_name`</span>,<br>    <span class="hljs-symbol">`phone_number`</span>,<br>    <span class="hljs-symbol">`last_name`</span>,<br>    <span class="hljs-symbol">`job_id`</span>,<br>    <span class="hljs-symbol">`phone_number`</span>,<br>    <span class="hljs-symbol">`job_id`</span>,<br>    <span class="hljs-symbol">`salary`</span>,<br>    <span class="hljs-symbol">`commission_pct`</span>,<br>    <span class="hljs-symbol">`manager_id`</span>,<br>    <span class="hljs-symbol">`department_id`</span>,<br>    <span class="hljs-symbol">`hiredate`</span> <br><span class="hljs-keyword">FROM</span><br>    employees ;<br>#方式二，*号表示所有字段：  <br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees;<br><br>#4.查询常量<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span>;<br><br>#5.查询函数<br><span class="hljs-keyword">SELECT</span> VERSION();<br><br>#6.查询表达式<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span>%<span class="hljs-number">98</span>;<br></code></pre></td></tr></table></figure>

<p><strong>别名</strong>：如果要查询的字段有重名的情况，可以使用别名区分；同样，表也可以起别名。</p>
<p>定义别名有两种方式：</p>
<ul>
<li><p>使用<code>as</code>:</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">SELECT 100%98 AS 结果;<br><span class="hljs-section">/*运行结果为：</span><br><span class="hljs-section">+------+</span><br><span class="hljs-section">| 结果 |</span><br><span class="hljs-section">+------+</span><br><span class="hljs-section">|    2 |</span><br><span class="hljs-section">+------+</span><br>*/<br>SELECT last_name AS 姓,first_name AS 名 FROM employees;<br></code></pre></td></tr></table></figure></li>
<li><p>使用空格，将<code>as</code>替换为空格即可：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> last_name 姓,first_name 名 <span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>去重</strong>：使用<code>distinct</code>对结果去重</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例：查询员工表中涉及到的所有的部门编号<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id <span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure>

<p><strong>+号在MySQL中的作用</strong>：</p>
<p>MySQL中的<code>+</code>号只有运算符的作用，其运算规则如下：</p>
<ul>
<li>如果两个操作值都是数值型，做加法运算</li>
<li>如果一方为字符型，则尝试进行转换，转换成功就做加法运算，如果转换失败，则将字符值当作0</li>
<li>任何数和<code>null</code>做加法运算，结果都是<code>null</code></li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">select</span> <span class="hljs-number">100</span>+<span class="hljs-number">90</span>;  # 结果为<span class="hljs-number">190</span>select &#x27;<span class="hljs-number">123</span>&#x27;+<span class="hljs-number">90</span>; # 结果为<span class="hljs-number">213</span>select &#x27;john&#x27;+<span class="hljs-number">90</span>; # 结果为<span class="hljs-number">90</span>select null+<span class="hljs-number">10</span>;  # 结果为null<br></code></pre></td></tr></table></figure>

<h2 id="2、条件查询"><a href="#2、条件查询" class="headerlink" title="2、条件查询"></a>2、条件查询</h2><p>语法：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> 要查询的字段|表达式|常量值|函数<span class="hljs-keyword">from</span> 表<span class="hljs-keyword">where</span> 筛选条件;  <span class="hljs-meta"># where后面加筛选条件</span><br></code></pre></td></tr></table></figure>

<p>根据筛选条件的不同，可以分为以下几种：</p>
<p>① <strong>条件表达式</strong></p>
<p>使用以下条件运算符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>=</code></td>
<td align="left">等于，也可以作为赋值符号，为了便于区分，变量赋值尽量用<code>:=</code>符号。 不能用于判断<code>null</code>值</td>
</tr>
<tr>
<td align="center"><code>&gt;</code></td>
<td align="left">大于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="left">小于</td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="center"><code>&lt;&gt;</code>或<code>!=</code></td>
<td align="left">不等于，两种写法均可，不能用于判断<code>null</code>值</td>
</tr>
</tbody></table>
<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询工资&gt;12000的员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> salary&gt;<span class="hljs-number">12000</span>;#案例2：查询部门编号不等于90号的员工名和部门编号<span class="hljs-keyword">SELECT</span> 	last_name,	department_idFROM employeesWHERE department_id&lt;&gt;<span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure>

<p>②<strong>逻辑表达式</strong></p>
<p>使用以下逻辑运算符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>and</code>或<code>&amp;&amp;</code></td>
<td>与</td>
</tr>
<tr>
<td><code>or</code>或</td>
<td>或</td>
</tr>
<tr>
<td><code>not</code>或<code>!</code></td>
<td>非</td>
</tr>
</tbody></table>
<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金<span class="hljs-keyword">SELECT</span>	last_name,	salary,	commission_pctFROM employeesWHERE salary&gt;=<span class="hljs-number">10000</span> <span class="hljs-keyword">AND</span> salary&lt;=<span class="hljs-number">20000</span>;#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE <span class="hljs-keyword">NOT</span>(department_id&gt;=<span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> department_id&lt;=<span class="hljs-number">110</span>) <span class="hljs-keyword">OR</span> salary&gt;<span class="hljs-number">15000</span>;<br></code></pre></td></tr></table></figure>

<p>③<strong>其他</strong></p>
<p>包括以下几种：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>like</code></td>
<td align="left">模糊查询，<code>%</code>用于匹配<strong>任意个</strong>字符，包括0个，<code>_</code>用于匹配<strong>任意一个</strong>字符</td>
</tr>
<tr>
<td><code>between ... and ...</code></td>
<td align="left">判断是否在范围之间，相当于<code>&gt;=</code>和<code>&lt;=</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td align="left">使用<code>=</code>号判断</td>
</tr>
<tr>
<td><code>is null</code>，<code>is not null</code></td>
<td align="left">用于判断是否为<code>null</code></td>
</tr>
</tbody></table>
<p><code>like</code> 一般用于字符型数据，也可以查询数值型数据。使用通配符查询，默认<code>\</code>为转义字符，也可以使用<code>escape</code>自定义转移字符。</p>
<p>案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#查询员工名中包含字符a的员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span>;#查询员工名中第二个字符为_的员工名<span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">FROM</span> employeesWHERE last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_#_%&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;#&#x27;</span>; # 自定义#作为转义字符<br></code></pre></td></tr></table></figure>

<p><code>between and</code>语句包含两个临界值，且要求是合法的范围：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#查询员工编号在100到120之间的员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE employee_id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">120</span>;#等价于：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE employee_id &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> employee_id&lt;=<span class="hljs-number">120</span>;<br></code></pre></td></tr></table></figure>

<p><code>in</code>用于判断某字段的值是否属于<strong>in列表</strong>中的某一项，使用<code>=</code>号判断</p>
<ul>
<li>in列表的值类型必须一致或兼容</li>
<li>in列表中不支持通配符</li>
</ul>
<p>案例：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">#查询工种编号是IT_PROG、AD_VP、AD_PRES中其中一个的所有员工的姓名和工种编号<span class="hljs-meta">SELECT</span> last_name, job_id <span class="hljs-meta">FROM</span> employeesWHERE job_id <span class="hljs-meta">IN(</span> <span class="hljs-string">&#x27;IT_PROT&#x27;</span> ,<span class="hljs-string">&#x27;AD_VP&#x27;</span>,<span class="hljs-string">&#x27;AD_PRES&#x27;</span>);#等价于<span class="hljs-meta">SELECT</span> last_name, job_id <span class="hljs-meta">FROM</span> employeesWHERE job_id = <span class="hljs-string">&#x27;IT_PROT&#x27;</span> <span class="hljs-meta">OR</span> job_id = <span class="hljs-string">&#x27;AD_VP&#x27;</span> <span class="hljs-meta">OR</span> JOB_ID =<span class="hljs-string">&#x27;AD_PRES&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><code>is null</code>和<code>is not null</code>用于判断字段是否为<code>null</code>，且只能用于判断是否为<code>null</code>，不能用于判断是否等于某个数值：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#查询没有奖金的员工名和奖金率<span class="hljs-keyword">SELECT</span> last_name,commission_pct <span class="hljs-keyword">FROM</span> employeesWHERE commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p><code>&lt;=&gt;</code>既可以判断是否等于某个数值，也能用于判断是否为<code>null</code>：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询没有奖金的员工名和奖金率<span class="hljs-keyword">SELECT</span> last_name, commission_pctFROM employeesWHERE commission_pct &lt;=&gt;<span class="hljs-literal">NULL</span>;#案例2：查询工资为12000的员工名和工资<span class="hljs-keyword">SELECT</span> last_name, salaryFROM employeesWHERE salary &lt;=&gt; <span class="hljs-number">12000</span>;<br></code></pre></td></tr></table></figure>

<h2 id="3、排序查询"><a href="#3、排序查询" class="headerlink" title="3、排序查询"></a>3、排序查询</h2><p>语法：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表名[<span class="hljs-keyword">where</span> 筛选条件]<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序的字段|表达式|函数|别名 [<span class="hljs-keyword">asc</span>|<span class="hljs-keyword">desc</span>];  # 使用<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>排序<br></code></pre></td></tr></table></figure>

<blockquote>
<p>默认asc，表示升序。也可以使用desc指定为降序</p>
<p>order by的位置一般放在最后面（除limit外)</p>
</blockquote>
<p>案例：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-string">#1</span>、按单个字段排序<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>;<span class="hljs-string">#2</span>、添加筛选条件再排序#查询部门编号&gt;=<span class="hljs-number">90</span>的员工信息，并按员工编号降序<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id&gt;=<span class="hljs-number">90</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> employee_id <span class="hljs-keyword">DESC</span>;<span class="hljs-string">#3</span>、按表达式排序#查询员工信息 按年薪降序<span class="hljs-keyword">SELECT</span> *,salary*<span class="hljs-number">12</span>*(<span class="hljs-number">1</span>+IFNULL(commission_pct,<span class="hljs-number">0</span>)) <span class="hljs-keyword">FROM</span> employeesORDER <span class="hljs-keyword">BY</span> salary*<span class="hljs-number">12</span>*(<span class="hljs-number">1</span>+IFNULL(commission_pct,<span class="hljs-number">0</span>)) <span class="hljs-keyword">DESC</span>;<span class="hljs-string">#4</span>、按别名排序#查询员工信息 按年薪升序<span class="hljs-keyword">SELECT</span> *,salary*<span class="hljs-number">12</span>*(<span class="hljs-number">1</span>+IFNULL(commission_pct,<span class="hljs-number">0</span>)) 年薪<span class="hljs-keyword">FROM</span> employeesORDER <span class="hljs-keyword">BY</span> 年薪 <span class="hljs-keyword">ASC</span>;<span class="hljs-string">#5</span>、按函数排序#查询员工名，并且按名字的长度降序<span class="hljs-keyword">SELECT</span> LENGTH(last_name),last_name <span class="hljs-keyword">FROM</span> employeesORDER <span class="hljs-keyword">BY</span> LENGTH(last_name) <span class="hljs-keyword">DESC</span>;<span class="hljs-string">#6</span>、按多个字段排序#案例：查询员工信息，要求先按工资降序，再按employee_id升序<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesORDER <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>,employee_id <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure>

<h2 id="4、常见函数"><a href="#4、常见函数" class="headerlink" title="4、常见函数"></a>4、常见函数</h2><p>MySQL中的函数类似于java中的方法，将一组逻辑语句封装在方法体中，对外暴露方法名。</p>
<p>优势：提高代码重用性，隐藏了实现细节。</p>
<p>调用函数的语法：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> 函数名(实参列表) [<span class="hljs-keyword">from</span> 表名...]<br></code></pre></td></tr></table></figure>

<p>函数根据作用对象的个数不同，可以分为<strong>单行函数</strong>和<strong>分组函数</strong>。</p>
<p><strong>单行函数</strong></p>
<ul>
<li><p>字符函数</p>
<ul>
<li><code>length</code>：求参数的字节个数，比如一个汉字三个字节</li>
<li><code>concat</code>：字符拼接，只要有一个为null，则结果为null</li>
<li><code>substr</code>：截取子串。sql中的索引是从1开始的</li>
<li><code>instr</code>：返回子串第一次出现的索引</li>
<li><code>trim</code>：去除首尾指定的空格和字符</li>
<li><code>upper</code>：转换成大写</li>
<li><code>lower</code>：转换成小写</li>
<li><code>lpad</code>：左填充</li>
<li><code>rpad</code>：右填充</li>
<li><code>replace(str,a,b)</code>：将str中的a替换成b</li>
</ul>
<p>案例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#截取从指定索引处指定字符长度的字符(不是字节长度)</span><br><span class="hljs-function">SELECT <span class="hljs-title">SUBSTR</span>(<span class="hljs-params"><span class="hljs-string">&#x27;你好，MySQL&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span></span>) out_put</span>;   <span class="hljs-meta"># 你好</span><br><br><span class="hljs-function">SELECT <span class="hljs-title">LENGTH</span>(<span class="hljs-params">TRIM(<span class="hljs-string">&#x27;    张 翠 山    &#x27;</span></span>)) AS out_put</span>; <span class="hljs-meta"># 11</span><br><span class="hljs-meta"># trim只能去除首尾的空格，length求得是字节的个数</span><br></code></pre></td></tr></table></figure></li>
<li><p>数学函数</p>
<ul>
<li><code>round</code>：四舍五入</li>
<li><code>rand</code>：返回一个[0,1)之间的随机数</li>
<li><code>ceil</code>：向上取整，返回&gt;=该参数的最小整数</li>
<li><code>floor</code>：向下取整，返回&lt;=该参数的最大整数</li>
<li><code>truncate</code>：截断（直接截断，不会四舍五入），保留小数点后的n位</li>
<li><code>mod</code>：取余</li>
</ul>
<p>案例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> ROUND(-<span class="hljs-number">1</span>.<span class="hljs-number">55</span>); #-<span class="hljs-number">2</span><br><span class="hljs-attribute">SELECT</span> CEIL(-<span class="hljs-number">1</span>.<span class="hljs-number">02</span>);  #-<span class="hljs-number">1</span><br><span class="hljs-attribute">SELECT</span> FLOOR(-<span class="hljs-number">9</span>.<span class="hljs-number">99</span>);  #-<span class="hljs-number">10</span><br><span class="hljs-attribute">SELECT</span> TRUNCATE(<span class="hljs-number">1</span>.<span class="hljs-number">69999</span>,<span class="hljs-number">1</span>); # <span class="hljs-number">1</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li>
<li><p>日期函数</p>
<ul>
<li><code>now</code>：返回当前系统日期+时间</li>
<li><code>curdate</code>：返回当前系统日期，不包含时间</li>
<li><code>curtime</code>：返回当前时间，不包含日期</li>
<li><code>year</code>：获取指定日期的年份</li>
<li><code>month</code>：获取指定日期的月份</li>
<li><code>monthname</code>：获取指定日期月份的英文</li>
<li><code>day</code>：获取指定日期的日</li>
<li><code>hour</code>：获取指定日期的小时</li>
<li><code>minute</code>：获取指定日期的分钟</li>
<li><code>second</code>：获取指定日期的秒</li>
<li><code>str_to_date</code>：将字符通过指定的格式转换成日期</li>
<li><code>date_format</code>：将日期转换成字符</li>
<li><code>datediff</code>：返回两个日期相差的天数</li>
</ul>
<p>案例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> YEAR(&#x27;<span class="hljs-number">1998</span>-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&#x27;) 年;  # <span class="hljs-number">1998</span>SELECT DATE_FORMAT(NOW(),&#x27;%y年%m月%d日&#x27;) AS out_put;  # <span class="hljs-number">21</span>年<span class="hljs-number">04</span>月<span class="hljs-number">25</span>日<br></code></pre></td></tr></table></figure></li>
<li><p>流程控制函数，包括<code>if</code>和<code>case</code>函数。这里作为函数，可以用在任何地方，包括begin end里面和外面，注意和后面的<code>if</code>结构和<code>case</code>结构区分。</p>
<ul>
<li><code>if</code>函数：<code>if(条件，值1，值2)</code>，如果条件成立，返回值1，否则返回值2</li>
<li><code>case</code>函数：作为函数，其有两种用法，格式如下：</li>
</ul>
</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment">#用法1：</span><br><span class="hljs-keyword">case</span> 要判断的字段或表达式<br><span class="hljs-keyword">when</span> 常量<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">1</span><br><span class="hljs-keyword">when</span> 常量<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">2</span><br>...<br><span class="hljs-keyword">else</span> 值n<br>endl;<br>    <br><span class="hljs-comment">#用法2：</span><br><span class="hljs-keyword">case</span> <br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">1</span><br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">2</span><br>...<br><span class="hljs-keyword">else</span> 值n<br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>if/case结构作为函数时，可以应用在begin end结构中或外面，其返回结果必须是值；语句中不用加分号，最后结束才加分号。</p>
<p>if/case作为流程控制结构时，只能用于begin end结构中，其返回的是执行语句，中间需要加分号，且end后面要加if/case。作为流程控制结构的语法参考最后一章流程控制。</p>
</blockquote>
<p>案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-keyword">if</span><br># 例一<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">IF</span>(<span class="hljs-number">10</span>&lt;<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;大&#x27;</span>,<span class="hljs-string">&#x27;小&#x27;</span>);<br><br># 例<span class="hljs-number">2</span><br><span class="hljs-keyword">SELECT</span> <br>	last_name,<br>	commission_pct,<br>	<span class="hljs-keyword">IF</span>(commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;没奖金&#x27;</span>,<span class="hljs-string">&#x27;有奖金&#x27;</span>) 备注<br><span class="hljs-keyword">FROM</span> employees;<br><br># <span class="hljs-keyword">case</span><br># 例<span class="hljs-number">1</span><br><span class="hljs-keyword">SELECT</span> salary 原始工资,department_id,<br><span class="hljs-keyword">CASE</span> department_id<br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">30</span> <span class="hljs-keyword">THEN</span> salary*<span class="hljs-number">1.1</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">40</span> <span class="hljs-keyword">THEN</span> salary*<span class="hljs-number">1.2</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">50</span> <span class="hljs-keyword">THEN</span> salary*<span class="hljs-number">1.3</span><br><span class="hljs-keyword">ELSE</span> salary<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> 新工资<br><span class="hljs-keyword">FROM</span> employees;<br><br># 例<span class="hljs-number">2</span><br><span class="hljs-keyword">SELECT</span> salary,<br><span class="hljs-keyword">CASE</span> <br><span class="hljs-keyword">WHEN</span> salary&gt;<span class="hljs-number">20000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-keyword">WHEN</span> salary&gt;<span class="hljs-number">15000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-keyword">WHEN</span> salary&gt;<span class="hljs-number">10000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;C&#x27;</span><br><span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;D&#x27;</span><br><span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> 工资级别<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>其他</p>
<ul>
<li><code>version</code>：获取MySQL当前版本</li>
<li><code>database</code>：获取当前数据库</li>
<li><code>user</code>：获取当前用户</li>
<li><code>if null(参数,指定值)</code>：如果参数值为<code>null</code>，则返回指定值，否则返回参数的值</li>
<li><code>is null(参数)</code>：判断字段或表达式是否为<code>null</code>，如果是，返回1，否则返回0</li>
<li><code>password(&quot;str&quot;)</code>：返回str的密码形式</li>
<li><code>md5(&quot;str&quot;)</code>：返回str的MD5形式</li>
</ul>
<p>案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> VERSION();<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DATABASE</span>();<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">USER</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>分组函数</strong></p>
<ul>
<li><code>sum</code>：求和。一般用于处理数值</li>
<li><code>max</code> ：最大值</li>
<li><code>min</code>： 最小值</li>
<li><code>avg</code>：平均值。一般用于处理数值</li>
<li><code>count</code>：计数。参数可以是<code>字段</code>、<code>*</code>、<code>常量值（一般用1）</code>，<code>*</code>表示所有字段同时考虑，一般用来统计行数。常量值也能用来统计行数。</li>
</ul>
<blockquote>
<p>1.、以上五个分组函数都忽略<code>null</code>值，除了<code>count(*)</code>，因为主键一定不为空<br>2、max、min、count可以处理任何数据类型。<br>3、都可以搭配distinct使用，用于统计去重后的结果</p>
<p>4、MYISAM存储引擎下 ，<code>COUNT(*)</code>的效率高；INNODB存储引擎下，<code>COUNT(*)</code>和<code>COUNT(1)</code>的效率差不多，比COUNT(字段)要高一些。</p>
</blockquote>
<p>和分组函数同时查询的字段，必须是group by后的字段，不然会出现错误结果。</p>
<p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(salary) <span class="hljs-keyword">FROM</span> employees;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees;# 与<span class="hljs-keyword">distinct</span>搭配使用<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> salary),<span class="hljs-built_in">COUNT</span>(salary) <span class="hljs-keyword">FROM</span> employees;  <br># <span class="hljs-number">57</span>,<span class="hljs-number">107</span><br># 和分组函数一同查询的字段有限制<br># 下面这种，employee_id是无意义的，只有<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>后的字段才能和分组函数一起查询<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary),employee_id  <span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure>

<h2 id="5、分组查询"><a href="#5、分组查询" class="headerlink" title="5、分组查询"></a>5、分组查询</h2><p>语法：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表[<span class="hljs-keyword">where</span> 筛选条件]<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组的字段  # 使用<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>进行分组[<span class="hljs-keyword">having</span> 条件语句];<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>1、和分组函数一同查询的字段必须是group by后出现的字段，确保意义正确</p>
<p>2、筛选分为两类：分组前筛选(where)和分组后(having)筛选。having后面一般跟的分组函数，表示对初步筛选后的结果再进行筛选。</p>
<p>3、分组可以按单个字段也可以按多个字段。</p>
<p>4、可以搭配排序使用。</p>
<p>5、having 和group by后，mysql支持别名，Oracle不支持。一般也不使用。</p>
<p>6、having后面的条件一般是分组函数，如果是一般的字段，必须是select中的字段（自己实验得出）。规范来说，having必须是在使用group by语句之后才能使用，如果不是在group by后面，having的作用和where的作用相同，但是不建议这么做，最好按照规范来做。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">MySQL 5.7版本，出现以下结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> salary&gt;<span class="hljs-number">15000</span>; # 输出正确结果<br><br><span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary&gt;<span class="hljs-number">15000</span>; # 输出正确结果<br>#－－－－－－－－－－－－－－－－－－<br><span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">HAVING</span> salary&gt;<span class="hljs-number">15000</span>; # 输出正确结果<br><br>#如果<span class="hljs-keyword">having</span>后的字段，没在<span class="hljs-keyword">select</span>中，会报错<br><span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">HAVING</span> salary&gt;<span class="hljs-number">15000</span>; # 显示语法错误，原因是‘<span class="hljs-keyword">having</span> clause’中没有salary列<br></code></pre></td></tr></table></figure>

<p><strong><code>where</code>和<code>having</code>的区别：</strong></p>
<ul>
<li>where是分组前进行筛选，是对原始表筛选；having是在分组后筛选，是对分组后的结果再进行筛选，一般的筛选条件是分组函数。可以根据代码执行顺序进行推断。</li>
<li>在语句格式上，where写在group by 前面，having写在group by后面。</li>
</ul>
<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询每个工种的员工平均工资<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary),job_id  #和分组函数同时查询的字段，是用于分组的字段<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id;<br><br>#案例2：查询邮箱中包含a字符的每个部门的最高工资<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary),department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br><br>#案例3：查询哪个部门的员工个数&gt;5<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*),department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id  # 先查询每个部门员工个数<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(*)&gt;<span class="hljs-number">5</span>;  # 然后选出个数&gt;5的<br><br>#案例4：查询每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序<br><span class="hljs-keyword">SELECT</span> job_id,<span class="hljs-built_in">MAX</span>(salary) m<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br><span class="hljs-keyword">HAVING</span> m&gt;<span class="hljs-number">6000</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> m;<br><br>#按多个字段分组<br>#案例5：查询每个查询每个工种每个部门的平均工资<br><span class="hljs-keyword">SELECT</span> department_id, job_id,<span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id,job_id; # 顺序可以颠倒<br># 这两种写法等价，每个A，每个B和每个B，每个A结果相同。<br><span class="hljs-keyword">SELECT</span> department_id, job_id,<span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id,department_id;<br></code></pre></td></tr></table></figure>

<h2 id="6、多表连接查询"><a href="#6、多表连接查询" class="headerlink" title="6、多表连接查询"></a>6、多表连接查询</h2><p>当查询的字段来自多个表时，就需要使用连接查询。</p>
<p>如果不使用连接条件，或者连接条件无效，则多个表会按照笛卡儿乘积的形式连接，即查询的结果为m*n的表。</p>
<p>解决这种现象就需要添加有效的连接条件。</p>
<p>连接方式按照功能分类：</p>
<ul>
<li>内连接<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
<li>外连接。<ul>
<li>左外连接，left join左边是主表</li>
<li>右外连接，right join右边是主表</li>
<li>全外连接</li>
</ul>
</li>
<li>交叉连接</li>
</ul>
<p>其中，SQL 92标准仅支持内连接，ORACLE和SQL Server支持一部分外连接（mysql不支持），SQL 99标准支持内连接+外连接+交叉连接(mysql不支持全外连接)。</p>
<p>下面以两个表连接为例，说明连接查询的语法格式。</p>
<p><strong>内连接</strong></p>
<p>等值连接</p>
<p>等值内连接的结果是多表的交集。n表连接，至少需要n-1个连接条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># SQL 92语法<br>select 查询列表<br>from 表1 别名，表2 别名<br>where 表1.字段= 表2.字段   # 连接条件 <br>[and 筛选条件]<br>其他结构...<br><br># SQL 99语法<br>select 查询列表<br>from 表1 别名<br>[inner] join 表2 别名<br>on 连接条件<br>其他结构...<br># SQL 99语法将筛选条件和连接条件分离，便于阅读<br></code></pre></td></tr></table></figure>

<p>非等值连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># SQL 92<br>select 查询列表<br>from 表1 别名，表2, 别名...<br>where 非等值连接条件<br>[and 筛选条件]<br>其他结构...<br><br># SQL 99<br>select 查询列表<br>from 表1 别名<br>[inner] join 表2 别名<br>on 非等值连接条件<br>其他结构...<br></code></pre></td></tr></table></figure>

<p>自连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 自连接是指同一张表自己和自己连接。<br>#将同一张表看作两个表，起两个别名。<br># SQL 92<br>select 查询列表<br>from 表 别名1,表 别名2<br>where 连接条件<br>[and 筛选条件]<br>其他结构...<br><br># SQL 99语法<br>select 查询列表<br>from 表 别名1<br>[inner] join 表 别名2<br>on 连接条件<br>其他结构...<br></code></pre></td></tr></table></figure>

<p>总结：对于内连接，SQL 92和SQL 99标准只有在连接表的方式和连接条件的位置不同，其余用法相同。SQL 99语法将连接条件写在<code>on</code>语句后面，与筛选条件分离，提高了易读性。</p>
<p>内连接案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#案例1：查询有奖金的每个部门的部门名、部门的领导编号，以及该部门的最低工资<br># SQL 92，等值连接<br>SELECT department_name,d.`manager_id`,MIN(salary)<br>FROM departments d,employees e<br>WHERE d.`department_id`=e.`department_id`<br>AND commission_pct IS NOT NULL<br>GROUP BY department_name,d.`manager_id`;<br><br># SQL 99，等值连接<br>SELECT d.department_name,d.manager_id,MIN(salary)<br>FROM employees e <br>JOIN departments d<br>ON e.`department_id` = d.`department_id`<br>WHERE e.`commission_pct` IS NOT NULL<br>GROUP BY e.`department_id`;<br><br>#案例2：查询员工的工资和工资级别<br># SQL 92，非等值连接<br>SELECT salary,grade_level<br>FROM employees e,job_grades g<br>WHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`;<br><br># SQL 99，非等值连接<br>SELECT salary,grade_level<br>FROM employees e<br>JOIN job_grades g <br>ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;<br><br>#案例3：查询员工名和上级的名称<br># SQL 92，自连接<br>SELECT e.last_name,m.last_name<br>FROM employees e,employees m<br>WHERE e.`manager_id`=m.`employee_id`;<br><br># SQL 99，自连接<br>SELECT e.last_name,m.last_name<br>FROM employees e<br>JOIN employees m<br>ON e.`manager_id`= m.`employee_id`;<br></code></pre></td></tr></table></figure>

<p><strong>外连接</strong></p>
<p>外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的，则显示匹配的值，如果从表中没有和它匹配的，则从表的结果显示<code>null</code>。外连接查询结果=内连接结果+主表中有，从表没有的记录。</p>
<p>外连接的特性决定了其应用场景为一般<strong>用于查询两个表交集以外的部分</strong>。即用于查询一个表中有，另一个表没有的记录。</p>
<p>左外连接和右外连接交换两个表的顺序，可以实现同样的效果 。</p>
<p>全外连接=内连接的结果+表1有，表2没有+表2有，表1没有。</p>
<p>交叉连接可以省略连接条件，其结果是笛卡尔积。</p>
<p>MySQL中只有SQL 99支持外连接（但不支持全外连接），只介绍SQL 99，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 语法：<br>select 查询内容<br>from 表1<br>left [outer]|right [outer]|full [outer]|cross join 表2 <br>on 连接条件<br>其他结构...;<br><br>#outer可以省略<br></code></pre></td></tr></table></figure>

<p>外连接案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#案例1：查询哪个部门没有员工<br>#左外<br>SELECT d.*,e.employee_id<br>FROM departments d<br>LEFT OUTER JOIN employees e<br>ON d.`department_id` = e.`department_id`<br>WHERE e.`employee_id` IS NULL;<br> <br>#右外,调换两个表的顺序后使用右外连接，和上面写法等价 <br>SELECT d.*,e.employee_id<br>FROM employees e<br>RIGHT OUTER JOIN departments d<br>ON d.`department_id` = e.`department_id`<br>WHERE e.`employee_id` IS NULL;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>以集合关系来理解内连接和外连接：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_7.png"><img src="https://gitee.com/wenkailllll/blog-img/raw/master/img/mysql-basis_7.png" alt="img"></a></p>
<h2 id="7、子查询"><a href="#7、子查询" class="headerlink" title="7、子查询"></a>7、子查询</h2><p>嵌套在其他语句内部的select语句称为<strong>子查询</strong>或<strong>内查询</strong>。外面的语句可以是insert、update、delete、select等，一般为select语句较多。</p>
<p>如果外面的语句是select语句，则称其为<strong>主查询</strong>或<strong>外查询</strong>。</p>
<p>子查询根据位置的不同和结果集的不同可以有以下分类。</p>
<p><strong>按子查询出现的位置分类</strong>：</p>
<ul>
<li><code>select</code>后面：仅支持标量子查询</li>
<li><code>from</code>后面：表子查询</li>
<li><code>where</code>或<code>having</code>后面(常用)：标量子查询、列子查询、行子查询</li>
<li><code>exists</code>后面（相关子查询）：均可。<code>exists</code>返回结果0或1，可以用<code>in</code>代替</li>
</ul>
<p><strong>按结果集的行列数不同分类</strong>：</p>
<ul>
<li>标量子查询（结果集只有一行一列）</li>
<li>列子查询（结果集只有一列多行）</li>
<li>行子查询（结果集一行多列）</li>
<li>表子查询（又称嵌套子查询。结果集一般为多行多列,一或多都可）</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>子查询放在小括号内。</li>
<li>子查询一般放在条件的右侧。</li>
<li>子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果。</li>
<li>标量、单行子查询，一般搭配着<strong>单行操作符</strong>使用：<code>&lt;</code>，<code>&gt;</code>，<code>=</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>&lt;&gt;</code></li>
<li>多行子查询，一般搭配着<strong>多行操作符</strong>使用：<code>in/not in</code>、<code>any|some</code>、<code>all</code></li>
</ul>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">in/<span class="hljs-literal">not</span> in`表示等于/不等于列表中的**任意一个**，例：`xxx in ()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><code>any|some</code>表示和子查询返回的<strong>某一个值</strong>进行比较（只要有一个满足即可），例：<code>xxx &gt;any();</code>。大于<code>any|some</code>等价于大于最小值，小于<code>any|some</code>等价于小于最大值。<code>any|some</code>一般很少使用。</p>
<p><code>all</code>表示和子查询返回的<strong>所有值</strong>进行比较。</p>
<p><strong>相关子查询和嵌套子查询对比</strong></p>
<p><strong>嵌套子查询</strong>的执行<strong>不依赖于外部的查询</strong>。其执行过程为：</p>
<ul>
<li>执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。</li>
<li>执行外部查询，并显示整个结果。</li>
</ul>
<p><strong>相关子查询</strong>的执行<strong>依赖于外部查询</strong>。多数情况下是子查询的WHERE子句中引用了外部查询的表。其执行过程为：</p>
<ul>
<li>从外层查询中取出一个元组，将元组相关列的值传给内层查询。</li>
<li>执行内层查询，得到子查询操作的值。</li>
<li>外查询根据子查询返回的结果或结果集得到满足条件的行。</li>
<li>然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。</li>
</ul>
<p>比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 嵌套子查询<br># 查询工资大于平均工资的员工信息<br>/*<br>平均工资是子查询，其不依赖于外查询<br>*/<br>SELECT * FROM employees<br>WHERE salary&gt;( <br>	SELECT AVG(salary) FROM employees<br>);<br><br># 相关子查询<br># 查询每个部门的员工数量和部门信息<br>/*<br>可以使用子查询的方式，也可以使用外连接+分组查询的方式。<br>查询员工数量时，需要将子查询和父查询根据部门id关联起来，<br>先统计一个部门的数量，然后继续统计下一个部门数量,<br>子查询和父查询二者交替执行<br>*/<br>SELECT d.*,(<br>	SELECT COUNT(*) FROM employees e<br>	WHERE e.`department_id`=d.`department_id`<br>	) AS &#x27;NUMBER&#x27;<br>FROM departments d;<br><br># exist也是相关子查询。能用exist的，也能使用in代替<br># 查询有员工的部门名<br>SELECT department_name<br>FROM departments d<br>WHERE EXISTS(<br>	SELECT *   <br>	FROM employees e<br>	WHERE d.`department_id`=e.`department_id`<br>);<br></code></pre></td></tr></table></figure>

<p>子查询案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># -------------用在where和having后使用子查询------------<br>#案例1：查询最低工资大于50号部门最低工资的 部门id 和 其最低工资<br>/*思路：<br>1.先查出50号部门的最低工资<br>2.然后查出每个部门的最低工资，<br>3.根据前两步的结果筛选出最低工资大于50号部门最低工资的部门信息<br>*/<br>SELECT MIN(salary),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING MIN(salary)&gt;(<br>	SELECT  MIN(salary)<br>	FROM employees<br>	WHERE department_id = 50<br>);<br><br>#案例2：查询其它工种中，比‘IT_PROG’工种任一工资低的员工的 员工号、工种和薪资<br>/*思路：<br>1.查询‘IT_PROG’部门的任一工资<br>2.查询员工信息，salary&lt;1的结果<br>*/<br>SELECT employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;ANY(<br>	SELECT DISTINCT salary<br>	FROM employees<br>	WHERE job_id = &#x27;IT_PROG&#x27;<br>) AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;<br><br># 小于any，只要比最大值小就可以，因此可以不用any<br>SELECT employee_id,job_id,salary<br>FROM employees<br>WHERE salary&lt;(<br>	SELECT MAX(salary) <br>	FROM employees<br>	WHERE job_id = &#x27;IT_PROG&#x27;<br><br>) AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;<br><br># -------------用在select后使用子查询------------<br>#案例：查询每个部门的员工个数和部门信息<br>SELECT d.*,(<br>	SELECT COUNT(*)<br>	FROM employees e<br>	WHERE e.department_id = d.`department_id`<br> ) 个数<br> FROM departments d;<br> <br># -------------用在from后使用子查询------------<br># from后面的子查询结果作为一张表，必须起别名<br># 案例：查询每个部门的平均工资的工资等级<br>/*思路：<br>1.使用子查询，查询每个部门的平均工资<br>2.根据平均工资查找工资等级<br>*/<br>SELECT  ag_dep.*,g.`grade_level`<br>FROM (<br>	SELECT AVG(salary) ag,department_id<br>	FROM employees<br>	GROUP BY department_id<br>) ag_dep<br>INNER JOIN job_grades g<br>ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;<br><br># -------------用在exists后使用子查询------------<br># 查询有员工的部门名<br># 使用 in<br>SELECT department_name<br>FROM departments d<br>WHERE d.`department_id` IN(<br>	SELECT department_id<br>	FROM employees<br>);<br># 使用外连接<br>SELECT DISTINCT department_name<br>FROM departments d<br>INNER JOIN employees e<br>ON d.`department_id`=e.`department_id`<br>WHERE e.`employee_id` IS NOT NULL;<br><br># 使用exists<br>SELECT department_name<br>FROM departments d<br>WHERE EXISTS(<br>	SELECT *<br>	FROM employees e<br>	WHERE d.`department_id`=e.`department_id`<br>);<br></code></pre></td></tr></table></figure>

<h2 id="8、分页查询"><a href="#8、分页查询" class="headerlink" title="8、分页查询"></a>8、分页查询</h2><p>如果想要显示查询结果中的一部分，就需要使用分页查询，使用<code>limit</code>限制返回的结果开始位置和条数。</p>
<p>分页查询通常用于实际web项目中，根据用户需求提交对应页数的查询结果。</p>
<p>语法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> 查询内容<br><span class="hljs-keyword">from</span> 表<br>[<span class="hljs-keyword">where</span> 条件]<br>[<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段]<br>[<span class="hljs-keyword">having</span> 条件]<br>[<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段]<br><span class="hljs-keyword">limit</span> [偏移量,] 条目数;  # 使用<span class="hljs-keyword">limit</span>语句进行分页<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>偏移量从0开始，可以省略，默认为0，理解为索引-1。偏移量为0表示从第一条开始</li>
<li><code>limit</code>子句放在查询语句的最后。</li>
</ul>
<p>如果每页显示条目数为<code>sizePage</code>，当前页数为<code>page</code>，则查询语句为：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表<br><span class="hljs-keyword">limit</span> (page<span class="hljs-number">-1</span>)*sizePage,sizePage;<br></code></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询第11条到第25条信息<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span>  employees <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>,<span class="hljs-number">15</span>;<br><br>#案例2：查询有奖金的员工中，工资较高的前10名员工信息<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span> <br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p><strong>子查询经典案例，使用排序和分页组合求最值</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># 1.查询工资最低的员工姓名和工资<br><span class="hljs-keyword">SELECT</span> last_name,salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary = ( # 先使用子查询查找最低工资<br>	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-keyword">FROM</span> employees<br>);<br><br># 2.查询平均工资最低的部门信息<br><span class="hljs-comment">/*思路：</span><br><span class="hljs-comment">1.先查询每个部门的平均工资</span><br><span class="hljs-comment">2.筛选出平均工资中最低的部门</span><br><span class="hljs-comment">3.根据上一步的结果，查询出部门信息</span><br><span class="hljs-comment">*/</span><br># 方式一：<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> departments d # d.根据id，查询部门信息<br><span class="hljs-keyword">WHERE</span> d.<span class="hljs-symbol">`department_id`</span> = <br>(<br>	<span class="hljs-keyword">SELECT</span> department_id # c.找出平均工资为最低平均工资的部门id<br>	<span class="hljs-keyword">FROM</span> employees<br>	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>	<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary)=<br>    ( <br>		<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(ag.a_s) # b.找出最低的平均工资<br>		<span class="hljs-keyword">FROM</span>( # a.查询出每个部门的平均工资和id<br>			<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) a_s,department_id <br>            <span class="hljs-keyword">FROM</span> employees<br>			<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>			) <span class="hljs-keyword">AS</span> ag<br>	)<br>);<br># 方式二，使用limit，求出平均工资以后进行排序，就可以直接选出部门id<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">WHERE</span> d.<span class="hljs-symbol">`department_id`</span>= <br>(<br>	<span class="hljs-keyword">SELECT</span> department_id <br>	<span class="hljs-keyword">FROM</span> employees<br>	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>	<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">AVG</span>(salary)<br>	<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>   # 递增排序中的第一条就是要查询的部门<br>);<br><br># 3.各个部门中 最高工资最低的部门的最低工资是多少<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id = ( # 子查询将排序和分页组合找出最值<br>	<span class="hljs-keyword">SELECT</span> department_id <br>    <span class="hljs-keyword">FROM</span> employees<br>	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>	<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">MAX</span>(salary) <br>	<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span><br>);<br><br># 4.查询平均工资最高的部门的manager信息<br><span class="hljs-keyword">SELECT</span> last_name,department_id,email,salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> employee_id=<br>( # b,根据部门id找出管理者id<br>	<span class="hljs-keyword">SELECT</span> manager_id <span class="hljs-keyword">FROM</span> departments<br>	<span class="hljs-keyword">WHERE</span> department_id = <br>    (  # a,找出平均工资最高的部门id<br>		<span class="hljs-keyword">SELECT</span> department_id <span class="hljs-keyword">FROM</span> employees<br>		<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>		<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">DESC</span><br>		<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span><br>	)<br>);<br></code></pre></td></tr></table></figure>

<h2 id="9、联合查询"><a href="#9、联合查询" class="headerlink" title="9、联合查询"></a>9、联合查询</h2><p>如果要查询的结果<strong>来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</strong>，可以使用<strong>联合查询</strong>。联合查询使用<code>union</code>将多次的查询结果合并成一个结果。</p>
<p>语法：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q"># 使用<span class="hljs-built_in">union</span>将多个查询语句合并<span class="hljs-keyword">select</span> xxxunion [<span class="hljs-built_in">all</span>]<span class="hljs-keyword">select</span> xxxunion [<span class="hljs-built_in">all</span>].....<span class="hljs-keyword">select</span> xxx<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>要求多条查询语句的查询的<strong>列数必须一致</strong></li>
<li>多条查询语句的查询的列的类型和含义尽量相同</li>
<li><code>union</code>默认去重，<code>union all</code>代表不去重</li>
</ul>
<p><strong><code>join</code>和<code>union</code>的区别</strong></p>
<ul>
<li><code>join</code>用于外连接，是根据一定的<strong>连接条件</strong>将两张表连接，并生成连接后的结果表，连接条件是<code>on</code>后面的条件。连接包括左外连接、右外连接、全连接和交叉连接。</li>
<li><code>union</code>表示联合查询，是将两个查询结果合并在一起，不需要进行表的连接。<code>union</code>连接的查询语句查询的字段个数必须一致。<code>union</code>默认去重，可以使用<code>all</code>保留全部结果。</li>
</ul>
<h1 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h1><p>DML指数据操作语言。</p>
<p>主要是对表格的添加（insert）、删除（delete）、修改（update）操作。</p>
<h2 id="1、insert"><a href="#1、insert" class="headerlink" title="1、insert"></a>1、insert</h2><p>向表格中插入数据有两种方式：</p>
<p><strong>方式一</strong>：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">insert</span> into 表名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>,...) values(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...);<br></code></pre></td></tr></table></figure>

<p>要求：</p>
<ul>
<li>字段类型和值类型必须一致或兼容，字段和值的顺序可以和表中不一致，但是字段和值必须一一对应。</li>
<li>可以为空的字段，如果要插入<code>null</code>值，有两种方式：①字段和值都省略，此时值默认为<code>null</code>；②字段和值都写，值为<code>null</code>。</li>
<li>不可以为空的字段，必须插入值。</li>
<li>字段个数和值的个数必须一致。</li>
<li>字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致。</li>
</ul>
<p><strong>方式二</strong>：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">insert into 表名<span class="hljs-builtin-name">set</span> 列名<span class="hljs-attribute">1</span>=值,列名2=值,...;<br></code></pre></td></tr></table></figure>

<p>两种方式的对比：</p>
<ul>
<li><p>方式一支持插入多行，方式二不支持：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(employee_id,last_name,salary)<span class="hljs-keyword">values</span>(<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;john&#x27;</span>,<span class="hljs-string">&#x27;15000&#x27;</span>),<span class="hljs-keyword">values</span>(<span class="hljs-number">124</span>,<span class="hljs-string">&#x27;jerry&#x27;</span>,<span class="hljs-string">&#x27;12000&#x27;</span>),<span class="hljs-keyword">values</span>(<span class="hljs-number">125</span>,<span class="hljs-string">&#x27;mickey&#x27;</span>,<span class="hljs-string">&#x27;11000&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>方式一支持子查询，方式二不支持：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 查询标量<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(employee_id,last_name,salary)<span class="hljs-keyword">SELECT</span> <span class="hljs-number">123</span>,<span class="hljs-string">&#x27;john&#x27;</span>,<span class="hljs-string">&#x27;15000&#x27;</span>;# 从表<span class="hljs-number">2</span>中查询到的结果插入表<span class="hljs-number">1</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(employee_id,last_name,salary)<span class="hljs-keyword">SELECT</span> id,name,salaryFROM employees <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">3</span>; <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、update"><a href="#2、update" class="headerlink" title="2、update"></a>2、update</h2><p><strong>修改单表的记录</strong>：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q"><span class="hljs-keyword">update</span> 表名 <span class="hljs-built_in">set</span> 字段=新值,字段=新值...[<span class="hljs-built_in">where</span> 条件];# 案例# 将<span class="hljs-number">90</span>号部门的员工工资修改为<span class="hljs-number">15000</span><span class="hljs-keyword">update</span> employeesset salary=<span class="hljs-number">15000</span><span class="hljs-built_in">where</span> department_id90;<br></code></pre></td></tr></table></figure>

<p><strong>修改多表记录</strong>：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># SQL 92语法<br><span class="hljs-keyword">update</span> 表<span class="hljs-number">1</span> 别名<span class="hljs-number">1</span>,表<span class="hljs-number">2</span> 别名<span class="hljs-number">2</span><br><span class="hljs-keyword">set</span> 字段=新值，字段=新值...<br><span class="hljs-keyword">where</span> 连接条件<br>[<span class="hljs-keyword">and</span> 筛选条件];<br><br># SQL 99语法，唯一不同的就是连接表的方式不同。其余相同<br><span class="hljs-keyword">update</span> 表<span class="hljs-number">1</span> 别名<br>[<span class="hljs-keyword">inner</span>]|<span class="hljs-keyword">left</span> [<span class="hljs-keyword">outer</span>]|<span class="hljs-keyword">right</span> [<span class="hljs-keyword">outer</span>] <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名<br><span class="hljs-keyword">on</span> 连接条件<br><span class="hljs-keyword">set</span> 列=值,...<br>[<span class="hljs-keyword">where</span> 筛选条件];<br></code></pre></td></tr></table></figure>

<h2 id="3、delete"><a href="#3、delete" class="headerlink" title="3、delete"></a>3、delete</h2><p>delete表示删除表中的一条或多条记录（一行或多行），有两种方式</p>
<p><strong>方式1，使用delete</strong></p>
<p>单表的删除：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <br>[<span class="hljs-keyword">where</span> 筛选条件]<br>[<span class="hljs-keyword">limit</span> 条目数]<br></code></pre></td></tr></table></figure>

<p>一般会使用<code>where</code>筛选特定的记录删除，如果没有筛选条件，会删除所有的记录。</p>
<p>可以使用<code>limit</code>限定删除的条数，只能用一个参数，表示删除查询结果的前几条。</p>
<p>多表的删除（级联删除）：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 同样地，也分为两种标准的语句，仅仅是连接表的时候不同，其余语句完全相同。</span><br><span class="hljs-comment"># 以SQL 92为例</span><br><span class="hljs-attribute">delete</span> 别名<span class="hljs-number">1</span>，别名<span class="hljs-number">2</span><br><span class="hljs-attribute">from</span> 表<span class="hljs-number">1</span> 别名<span class="hljs-number">1</span>，表<span class="hljs-number">2</span> 别名<span class="hljs-number">2</span><br><span class="hljs-attribute">where</span> 连接条件<span class="hljs-meta"></span><br><span class="hljs-meta">[and 筛选条件];</span><br></code></pre></td></tr></table></figure>

<p><strong>方式2，使用truncate</strong>：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名;<br></code></pre></td></tr></table></figure>

<p><code>delete</code>和<code>truncate</code>两种方式删除记录的区别（详细对比可以参考<a href="https://kangshitao.github.io/2021/04/26/mysql-basis/#refer1">下文</a>）：</p>
<ul>
<li><code>truncate</code>不能加<code>where</code>条件，而<code>delete</code>可以加<code>where</code>条件，意味着<code>truncate</code>会删除表中的所有记录。</li>
<li><code>truncate</code>的效率稍高。</li>
<li><code>truncate</code> 删除带自增长的列的表后，如果再插入数据，数据从1开始，<code>delete</code> 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始</li>
<li><code>truncate</code>删除没有返回值，<code>delete</code>删除有返回值</li>
<li><code>truncate</code>属于DDL语言，删除不能回滚，<code>delete</code>是DML语言，支持事务，可以回滚</li>
</ul>
<h1 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h1><p>DDL为数据定义语言。允许用户<strong>定义</strong>数据，包括创建（create）、删除（drop）、修改（alter）表和数据库，操作对象是<strong>表和数据库</strong>。通常，DDL由数据库管理员执行。</p>
<h2 id="1、create"><a href="#1、create" class="headerlink" title="1、create"></a>1、create</h2><p><strong>创建数据库</strong>：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>] 库名;<br></code></pre></td></tr></table></figure>

<p><strong>创建表</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 语法：<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> [if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>] 表名(	列名 列的类型[(长度) 约束],	列名 列的类型[(长度) 约束],	列名 列的类型[(长度) 约束],	...	列名 列的类型[(长度) 约束]);# 例：创建名为stuinfo的表，包含的列和类型如下：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> stuinfo(	stuId <span class="hljs-type">INT</span>,	stuName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),  # <span class="hljs-type">varchar</span>类型必须有长度	gender <span class="hljs-type">CHAR</span>,	bornDate DATETIME);<br></code></pre></td></tr></table></figure>

<p>创建库/表的时候，可以使用<code>if not exists</code>进行判断，如果要创建的库/表不存在，则创建，否则不会创建。不能创建名字相同的两个库/表。</p>
<p><strong>表的复制</strong></p>
<p>将<code>create</code>和<code>select</code>语句结合，可以实现表的复制：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 仅复制表的结构<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表名 <span class="hljs-keyword">like</span> 旧表<br><br># 复制表的字段和数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表名<br><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 旧表 [<span class="hljs-keyword">where</span> 筛选条件];<br><br>#仅仅复制某些字段<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表名<br><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 旧表 <span class="hljs-keyword">where</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<h2 id="2、alter"><a href="#2、alter" class="headerlink" title="2、alter"></a>2、alter</h2><p>修改库/表使用<code>alter</code>语句</p>
<p>修改数据库，一般很少对现有数据库进行修改：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#已废弃.现在需要去文件路径中重命名<br><span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">DATABASE</span> books <span class="hljs-keyword">TO</span> 新库名; <br># 更数据库字符集<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> books <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> gbk;<br></code></pre></td></tr></table></figure>

<p>修改表：</p>
<p>修改表中的字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 添加新的列，必须指定类型<br># 新列默认在表中的位置为最后，可以使用<span class="hljs-keyword">first</span>或after参数指定位置<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> 列名 类型 [约束] [<span class="hljs-keyword">first</span><span class="hljs-operator">|</span>after 列名];<br><br># 删除某列（无法使用if exist进行判断）<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 列名;<br><br># 修改列名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 change <span class="hljs-keyword">column</span> 旧列名 新列名 类型;<br><br># 修改列的类型或约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 类型 [约束];<br></code></pre></td></tr></table></figure>

<p>修改表名：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 格式：<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">rename</span> [<span class="hljs-keyword">to</span>] 新表名;<br># 案例：<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> author <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> book_author;<br></code></pre></td></tr></table></figure>

<h2 id="3、drop"><a href="#3、drop" class="headerlink" title="3、drop"></a>3、drop</h2><p>删除数据库：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>] 库名;<br></code></pre></td></tr></table></figure>

<p>删除表：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>] 表名;<br></code></pre></td></tr></table></figure>

<p>同样地，删除数据库/表的时候，可以使用<code>if exists</code>判断是否存在，避免报错。</p>
<h1 id="约束和标识列"><a href="#约束和标识列" class="headerlink" title="约束和标识列"></a>约束和标识列</h1><h2 id="1、约束"><a href="#1、约束" class="headerlink" title="1、约束"></a>1、约束</h2><p>约束指的是一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性。</p>
<p>主要有以下六大约束：</p>
<ul>
<li><code>NOT NULL</code>：非空，用于保证该字段的值不能为空。比如姓名、学号等</li>
<li><code>DEFAULT</code>：默认，用于保证该字段有默认值。比如性别</li>
<li><code>CHECK</code>：检查约束[mysql中不支持]。比如年龄、性别，检查年龄是否在某个区间内、性别是否是男或女。</li>
<li><code>PRIMARY KEY</code>：主键，用于保证该字段的值具有唯一性，并且非空。比如学号、员工编号等</li>
<li><code>UNIQUE</code>：唯一，用于保证该字段的值具有唯一性，可以为空（<code>unique key</code>可以插入多个<code>null</code>值，空值并不受唯一性约束）。比如座位号。</li>
<li><code>FOREIGN KEY</code>：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值在从表添加外键约束，用于引用主表中某列的值。比如学生表的专业编号（学生表为从表，专业表为主表），员工表的部门编号，员工表的工种编号。</li>
</ul>
<p>其中主键、外键、唯一键都是<code>key</code>，会默认生成索引。</p>
<blockquote>
<p><strong>关于key</strong></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html">MySQL文档</a>：key是索引的近义词，可以将key理解为索引。</p>
<p><a href="https://sqlrelease.com/sql-server-tutorial/types-of-keys">参考1</a>：key是表中的字段，它们参与RDBMS系统中的以下活动<br>a.表与表中数据之间的依赖关系由key建立<br>b.标识数据的唯一性。<br>c.使表的约束有效果, 进而能够保证数据都是有效的。<br>d.有可能会提升数据库表的查询效率。</p>
<p>key 包含两层意义和作用：<br>一是约束（偏重于约束和规范数据库的结构完整性）；<br>二是索引（辅助查询用）包括primary key (主键)、unique key(唯一键)、foreign key(外键) 等</p>
</blockquote>
<p>约束可以在<strong>创建表</strong>和**修改表(添加数据前)**时添加。</p>
<p>添加约束有两类：</p>
<ul>
<li>列级约束：六大约束语法上都支持，但外键约束没有效果。不可以起约束名。</li>
<li>表级约束：除了非空、默认，其他的都支持。可以起约束名（约束名对于主键没有效果，一直是primary）</li>
</ul>
<p><strong>主键和唯一键对比</strong>：</p>
<ul>
<li>主键的值是唯一的，非空，一个表中最多只能有一个主键，允许多个字段组合在一起作为主键，但不推荐。</li>
<li>唯一键的值是唯一的，但是允许值为空，一个表中可以有多个唯一键，同样允许多个字段组合在一起作为唯一键，但不推荐。</li>
</ul>
<p><strong>外键</strong>：</p>
<ul>
<li>要求在从表设置外键关系</li>
<li>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</li>
<li>主表的关联列必须是一个key（一般是主键或唯一）</li>
<li>插入数据时，先插入主表，再插入从表。删除数据时，先删除从表，再删除主表：</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#方式一：级联删除，删除主表数据时，将从表中相关的记录(整行)也删除#添加外键时，在最后添加 <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">cascade</span>。例如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stuinfo_major <span class="hljs-keyword">FOREIGN KEY</span>(majorid) <span class="hljs-keyword">REFERENCES</span> major(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span>; # 方式二：级联置空，删除主表数据时，将从表中相关的记录中对应的字段置为<span class="hljs-keyword">null</span>#添加外键时，在最后添加 <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">null</span>。例如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stuinfo_major <span class="hljs-keyword">FOREIGN KEY</span>(majorid) <span class="hljs-keyword">REFERENCES</span> major(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>; <br></code></pre></td></tr></table></figure>

<p><strong>添加约束</strong></p>
<p>列级约束，直接在类型后添加约束名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 例如。<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(    字段名 字段类型 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,  # 非空    字段名 字段类型 <span class="hljs-keyword">primary</span> key,  # 主键    字段名 字段类型 <span class="hljs-keyword">unique</span>,  # 唯一键    字段名 字段类型 <span class="hljs-keyword">default</span>,  # 默认    ...);<br></code></pre></td></tr></table></figure>

<p>表级约束，在字段都定义完后，再为指定的列添加约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 语法：[<span class="hljs-keyword">constraint</span> 约束别名] 约束(字段名);# 例如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> stuinfo(	id <span class="hljs-type">INT</span>,	stuname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),	gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),	seat <span class="hljs-type">INT</span>,	age <span class="hljs-type">INT</span>,	majorid <span class="hljs-type">INT</span>,    	<span class="hljs-keyword">CONSTRAINT</span> pk <span class="hljs-keyword">PRIMARY</span> KEY(id),#主键	<span class="hljs-keyword">CONSTRAINT</span> uq <span class="hljs-keyword">UNIQUE</span>(seat),#唯一键	<span class="hljs-keyword">CONSTRAINT</span> ck <span class="hljs-keyword">CHECK</span>(gender <span class="hljs-operator">=</span><span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">OR</span> gender  <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>),#检查（MySQL不支持）	<span class="hljs-keyword">CONSTRAINT</span> fk_stuinfo_major <span class="hljs-keyword">FOREIGN</span> KEY(majorid) <span class="hljs-keyword">REFERENCES</span> major(id)#外键);<br></code></pre></td></tr></table></figure>

<p>如果多个字段组合作为主键或唯一键，将这几个字段都写在表级约束的括号中，逗号隔开。</p>
<p>表级约束和列级约束可以一起使用，定义外键时使用表级约束，其他约束使用列级约束即可。</p>
<p>查看表中的所有索引（主键、外键、唯一键）：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure>

<p>除了在定义表时添加约束，也可以在修改表的时候添加约束：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#<span class="hljs-number">1</span>、添加列级约束<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 字段名 字段类型 新约束;#<span class="hljs-number">2</span>、添加表级约束<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> [<span class="hljs-keyword">constraint</span> 约束名] 约束类型(字段名) [外键相关];<br></code></pre></td></tr></table></figure>

<p><strong>删除约束</strong></p>
<p>在修改表的语句中，也可以删除约束，一般的约束在类型后面不加约束就代表删除，对于<code>key</code>，则需要使用<code>drop</code>显式删除，具体如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#<span class="hljs-number">1.</span>删除非空约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> stuname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span>;#<span class="hljs-number">2.</span>删除默认约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">INT</span>;#<span class="hljs-number">3.</span>删除主键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;#<span class="hljs-number">4.</span>删除唯一键，使用删除索引的语法<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> INDEX seat;#<span class="hljs-number">5.</span>删除外键，需要先将对应的索引删除<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> INDEX fk_stuinfo_major;<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY fk_stuinfo_major;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>MySQL中直接删除外键以后，外键依然存在，需要先将同名索引删除，然后再删除外键，这样查询时就不会显示外键了。</p>
<p>删除外键的时候，同名索引如果没被删，MYSQL认为外键仍然存在，MYSQL会在show keys命令里继续显示外键，当drop table时，MYSQL会提示Can’t DROP ‘xxx’; check that column/key exists”<br>如果再次想删除外键的时候，会报1091错误，提示外键名错误，因为实际上外键已经不存在了。因此MySQL中需要先将对应的索引删除，再删除外键。</p>
</blockquote>
<h2 id="2、标识列"><a href="#2、标识列" class="headerlink" title="2、标识列"></a>2、标识列</h2><p><strong>标识列</strong>又称为<strong>自增长列</strong>，可以不用手动的插入值，系统提供默认的序列值，默认从1开始。</p>
<p><strong>格式</strong>：在key的约束后面加上<code>auto_increment</code>即可。</p>
<p><strong>用法</strong>：添加数据时，标识列可以填<code>null</code>，或者不赋值，系统都会自动在已有的基础上+1。也可以手动指定值。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>标识列不是必须和主键搭配，但要求是一个key。</li>
<li>一个表最多只能有一个标识列。</li>
<li>标识列的类型只能是数值型，一般是int型。如果是非int型，自动赋值时是整数，可以手动插入小数。</li>
<li>可以通过<code>SHOW VARIABLES LIKE &#39;%auto_increment%&#39;;</code> 查看标识列的步长和默认起始值.</li>
<li>标识列可以通过<code>SET auto_increment_increment=n</code>设置步长。mysql不支持设置起始值，但可以通过手动插入值，设置起始值。</li>
</ul>
<p><strong>使用</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 创建表时设置标识列<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tab_identity(	id <span class="hljs-type">INT</span>,	NAME <span class="hljs-type">FLOAT</span> <span class="hljs-keyword">UNIQUE</span> AUTO_INCREMENT,	seat <span class="hljs-type">INT</span> );# 修改表时设置标识列<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tab_identity MODIFY <span class="hljs-keyword">COLUMN</span> id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT;#三、修改表时删除标识列<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tab_identity MODIFY <span class="hljs-keyword">COLUMN</span> id <span class="hljs-type">INT</span>;<br></code></pre></td></tr></table></figure>

<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p><strong>TCL（Transaction Control Language）</strong>： 事务控制语言</p>
<h2 id="1、事务概述"><a href="#1、事务概述" class="headerlink" title="1、事务概述"></a>1、事务概述</h2><p><strong>事务</strong>：一个或一组SQL语句（一般是DML语句）组成的一个<strong>执行单元</strong>，这个执行单元要么全部执行，要么全部不执行。</p>
<p>DDL语句不支持事务，可以认为DDL语句执行完自动提交，因此也无法回滚。</p>
<p><strong>事务的四大特性（ACID）</strong>：</p>
<ul>
<li><strong>原子性</strong>（<strong>A</strong>tomic）：组成事务的SQL语句要么都执行，要么都不执行（回滚）。</li>
<li><strong>一致性</strong>（<strong>C</strong>onsistent）：事务完成前后，所有数据的状态都是一致的。比如A账户只要减去了100，B账户则必定加上了100。</li>
<li><strong>隔离性</strong>（<strong>I</strong>solation）：多个事务同时操作相同数据库的同一个数据时，即多个事务并发执行，每个事务作出的修改必须与其他事务隔离。</li>
<li><strong>持久性</strong>（<strong>D</strong>uration）：事务一旦提交，对数据库数据的修改被持久化到本地存储。</li>
</ul>
<p><strong>事务分类</strong>：</p>
<ul>
<li><strong>隐式事务</strong>：没有明显的开启和结束的标记，本身就是一个事务。对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。<strong>隐式事务系统会自动提交</strong>。</li>
<li><strong>显式事务</strong>：具有明显的开启和结束的标记，即手动开启事务。显式事务必须保证系统的自动提交功能被禁用，实际上，MySQL中显示开启事务时，自动提交是无效的，不需要手动设置。</li>
</ul>
<h2 id="2、事务的开启"><a href="#2、事务的开启" class="headerlink" title="2、事务的开启"></a>2、事务的开启</h2><p>一个完整的事务包括以下执行流程：开启事务→执行事务语句→提交或回滚。</p>
<p>事务的执行结果要么是提交，要么是回滚。</p>
<p><strong>步骤一：开启事务</strong></p>
<p>开启事务有两种方式，一种是关闭自动提交模式，隐式开启事务；另一种是显式开启事务，有两种显式开启事务的语法，具体如下：</p>
<p>方式一：<strong>关闭自动提交模式</strong>，之后遇到需要开启事务的sql时，会自动开启事务，相当于隐式开启事务:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">autocommit</span>=0; # 将自动提交模式关闭<br>执行语句<br></code></pre></td></tr></table></figure>

<p>方式二：<strong>显式开启事务</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 方式一：</span><br><span class="hljs-built_in">start</span> transaction;<br><br><span class="hljs-comment">#方式二：</span><br><span class="hljs-keyword">begin</span>;<br></code></pre></td></tr></table></figure>

<p><strong>步骤二：执行语句</strong></p>
<p>在这一步，可以编写执行语句，包括insert、update、delete等语句。</p>
<p>DDL语言（create、drop、truncate等）是非事务的，可以理解为事务中的DDL语言执行完后会自动提交（禁用自动提交也没用），无法回滚，影响事务其他DML操作。</p>
<p>如果事务中掺杂了DDL语句，执行完DDL语句后会自动提交，导致之前的执行语句被提交，无法回滚，因此为了安全起见，尽量将DDL和DML完全分开，便于回滚。</p>
<p><strong>步骤三：结束事务</strong></p>
<p>事务的结束有两种情况：</p>
<ul>
<li><code>commit [work]</code>：提交，表示事务的执行单元都执行了。</li>
<li><code>rollback [work]</code> ：回滚，表示事务的执行单元都没执行。</li>
</ul>
<blockquote>
<p>事务相关的其他关键字：</p>
<p><code>savepoint identifier</code>：设置一个名为identifier的保存点</p>
<p><code>release savepoint identifier</code>：删除一个事务的名为identifier的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</p>
<p><code>rollback to identifier</code> ：把事务回滚到保存点。不算真正地结束事务，仍可以使用rollback将整个事务的修改撤销，因此执行了此语句后，也需要显式运行commit或rollback命令结束事务。</p>
</blockquote>
<p>事务的使用案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#开启事务，三种均可#<span class="hljs-keyword">SET</span> autocommit=<span class="hljs-number">0</span>;#<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<span class="hljs-keyword">begin</span>;#事务执行语句<span class="hljs-keyword">UPDATE</span> employees <span class="hljs-keyword">SET</span> salary = <span class="hljs-number">17200</span> <span class="hljs-keyword">WHERE</span> username=<span class="hljs-string">&#x27;K_ing&#x27;</span>;<span class="hljs-keyword">UPDATE</span> employees <span class="hljs-keyword">SET</span> salary = <span class="hljs-number">10000</span> <span class="hljs-keyword">WHERE</span> username=<span class="hljs-string">&#x27;Marry&#x27;</span>;#结束事务，要么提交，要么回滚<span class="hljs-keyword">ROLLBACK</span>;#<span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure>

<p><strong>drop、delete、truncate三者的区别</strong>：</p>
<ul>
<li>drop用于删除整个表。</li>
<li>delete可以使用筛选条件，删除表中的一行或多行记录。并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</li>
<li>truncate table则一次性地从表中删除所有的数据，即所有行，不能使用筛选条件。并不把单独的删除操作记录记入日志保存，操作不能恢复。</li>
<li>delete是DML语言，支持事务，delete操作可以会滚；而truncate和drop是ddl语言，不支持事务，因此无法回滚。</li>
<li>truncate和delete只删除数据，drop则删除整个表，包括结构和数据。</li>
<li>delete可以激活触发器。truncate不能激活触发器。</li>
<li>当表被truncate后，这个表和索引所占用的空间会<strong>恢复到初始大小</strong>，并且标识列也从1重新开始计数；delete操作不会减少表或索引所占用的空间，标识列还是从断点处计数。drop语句将表所占用的空间全释放掉。</li>
<li>速度上：drop&gt;truncate&gt;delete</li>
</ul>
<h2 id="3、事务的隔离级别"><a href="#3、事务的隔离级别" class="headerlink" title="3、事务的隔离级别"></a>3、事务的隔离级别</h2><p>当多个事务同时操作同一个数据库的相同数据时，容易导致并发问题，包括以下问题：</p>
<p><strong>脏写（丢失修改）</strong>：一个事务修改了其他事务还没有提交的数据，如果其他事务回滚，导致当前事务的修改丢失。事务B去修改了事务A修改过的值，但是此时事务A还没提交，所以事务A随时会回滚，导致事务B修改的值也没了。<br><strong>脏读</strong>：一个事务读取到了其他事务未提交（一般指<strong>数据修改</strong>）的数据。事务B去查询了事务A修改过的数据，但是此时事务A还没提交，所以事务A随时会回滚，导致事务B再次查询就读不到刚才事务A修改的数据了。</p>
<blockquote>
<p>脏读和脏写都是因为一个事务去更新或者查询了另外一个还没提交的事务更新过的数据。因为另外一个事务还没提交，所以它随时可能会回滚，那么必然导致你更新的数据就没了，或者你之前查询到的数据就没了，这就是脏写和脏读两种场景。</p>
</blockquote>
<p><strong>不可重复读</strong>：同一个事务中，多次读取到的数据不一致，即中间有其他事务提交了修改（一般指<strong>数据修改</strong>）。事务A读取一个字段后，事务B更新了该字段并提交了，导致A再次读取的时候和之前不一致了，即无法重复读取到相同的某个值。</p>
<p><strong>幻读</strong>：一个事务多次读取数据时，中间有其他事务提交了更新操作（一般指<strong>插入或删除</strong>）的数据。比如同样的查询语句，第一次查询出n条，然后别的事务进行了插入或删除，第二次查询出m条，同样的查询语句得到的结果不一样，就像出现了幻觉。</p>
<p>可以通过设置<strong>隔离级别</strong>避免事务的并发问题，主要有以下四种隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted</td>
<td>未解决</td>
<td>未解决</td>
<td>未解决</td>
<td>允许事务读取未被其他事务提交的更改</td>
</tr>
<tr>
<td>read committed</td>
<td>解决</td>
<td>未解决</td>
<td>未解决</td>
<td>只允许事务读取已经被其它事务提交的更改。<strong>Oracle的默认隔离级别</strong></td>
</tr>
<tr>
<td>repeatable read</td>
<td>解决</td>
<td>解决</td>
<td>未解决</td>
<td>确保事务可以多次从一个字段中读取相同的值，事务持续期间，禁止其他事务对这个字段更新。<strong>MySQL的默认隔离级别</strong></td>
</tr>
<tr>
<td>serializable</td>
<td>解决</td>
<td>解决</td>
<td>解决</td>
<td>确保事务可以多次从一个表中读取相同的行，事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。可以避免所有并发问题，性能最差。</td>
</tr>
</tbody></table>
<p>上述四种隔离级别，MySQL全部支持，Oracle只支持<code>read committed</code>和<code>serializable</code>。</p>
<h2 id="4、设置隔离级别"><a href="#4、设置隔离级别" class="headerlink" title="4、设置隔离级别"></a>4、设置隔离级别</h2><p>事务的隔离级别包括<strong>全局级别</strong>和<strong>会话级别</strong>：</p>
<ul>
<li>全局级别：对后续新的所有会话连接有效，对已经存在的会话连接无效。</li>
<li>会话级别：对数据库会话连接的<strong>后续新发起或当前未提交</strong>的事务有效。如果没有session关键字的话，只对当前数据库会话连接的<strong>后续新发起</strong>的事务有效，当前未提交的事务，还是继续使用之前的事务隔离级别。</li>
</ul>
<p>设置隔离级别的语法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 设置全局隔离级别<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> 隔离级别名;# 设置当前会话连接的隔离级别<span class="hljs-keyword">set</span> [<span class="hljs-keyword">session</span>] <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> 隔离级别名;<br></code></pre></td></tr></table></figure>

<p>查看隔离级别：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#查看当前会话隔离级别</span><br><span class="hljs-keyword">select</span> @<span class="hljs-symbol">@tx_isolation</span><span class="hljs-comment">;</span><br><span class="hljs-meta">#查看全局隔离级别</span><br><span class="hljs-keyword">select</span> @<span class="hljs-symbol">@global</span>.tx_isolation<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h2 id="5、MyISAM引擎和InnoDB引擎对比"><a href="#5、MyISAM引擎和InnoDB引擎对比" class="headerlink" title="5、MyISAM引擎和InnoDB引擎对比"></a>5、MyISAM引擎和InnoDB引擎对比</h2><p>InnoDB引擎是MySQL5.5开始引入的。InnoDB和MyISAM引擎的对比：</p>
<ul>
<li><strong>是否支持行级锁</strong>。MyISAM只支持表锁，而InnoDB支持表锁和行锁，且默认为行锁。</li>
<li><strong>是否支持事务</strong>。MyISAM不支持事务，InnoDB支持事务，具有提交和回滚事务的能力。</li>
<li><strong>是否支持外键</strong>。MyISAM不支持外键，InnoDB支持外键。</li>
<li><strong>是否支持数据库异常崩溃后的安全恢复</strong>。MyISAM不支持，InnoDB支持。InnoDB引擎能够保证，在数据库异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，恢复的过程依赖于<code>redo log</code></li>
</ul>
<p>扩展：InnoDB是如何保证ACID特性的？</p>
<p>1、InnoDB引擎使用<strong>redo log(重做日志)<strong>保证事务的</strong>持久性</strong></p>
<p>2、InnoDB引擎使用<strong>undo log(回滚日志)<strong>保证事务的</strong>原子性</strong></p>
<p>3、InnoDB引擎使用<strong>锁机制</strong>、<strong>MVCC</strong>等手段保证事务的<strong>隔离性</strong></p>
<p>4、保证了上述三个特性后，<strong>一致性</strong>才得以保障。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>视图是MySQL 5.1的新特性。视图是一张<strong>虚拟的表</strong>，它的数据来自于表，通过执行时动态生成。视图的用法和表相同。视图只保存了SQL逻辑，没有保存查询结果，因此其几乎不占用物理空间，视图一般仅用于查询，仅仅少数情况下才能修改数据。</p>
<p>视图的优势：</p>
<ul>
<li>提高SQL语句的重用性，简化了复杂的SQL操作，提高了效率</li>
<li>和表实现了分离，提高了安全性</li>
</ul>
<h2 id="2、创建视图"><a href="#2、创建视图" class="headerlink" title="2、创建视图"></a>2、创建视图</h2><p>创建视图：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or replace</span>] <span class="hljs-keyword">view</span> 视图名 <span class="hljs-keyword">as</span> 查询语句;# 使用<span class="hljs-keyword">or replace</span>还可以用于视图的修改<br></code></pre></td></tr></table></figure>

<p>使用案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># 使用视图，查询各部门的平均工资级别# 1.创建视图查看每个部门的平均工资<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> myview ASSELECT <span class="hljs-built_in">AVG</span>(salary) ag,department_idFROM employeesGROUP <span class="hljs-keyword">BY</span> department_id;# 2.使用创建的视图查询<span class="hljs-keyword">SELECT</span> myview.<span class="hljs-symbol">`ag`</span>,g.grade_levelFROM myviewJOIN job_grades gON myview.<span class="hljs-symbol">`ag`</span> <span class="hljs-keyword">BETWEEN</span> g.<span class="hljs-symbol">`lowest_sal`</span> <span class="hljs-keyword">AND</span> g.<span class="hljs-symbol">`highest_sal`</span>;<br></code></pre></td></tr></table></figure>

<h2 id="3、删除视图"><a href="#3、删除视图" class="headerlink" title="3、删除视图"></a>3、删除视图</h2><p>删除视图：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">drop</span> view 视图名,视图名,...;  # 可以一次删除多个视图#案例：删除myv<span class="hljs-number">1</span>，myv<span class="hljs-number">2</span>，myv<span class="hljs-number">3</span>三个视图DROP VIEW myv<span class="hljs-number">1</span>,myv<span class="hljs-number">2</span>,myv<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<h2 id="4、查看视图"><a href="#4、查看视图" class="headerlink" title="4、查看视图"></a>4、查看视图</h2><p>查看视图有两种方式：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#方式一：</span><br>DESC 视图名;<br><br><span class="hljs-meta">#方式二：</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-built_in">VIEW</span> 视图名;<br></code></pre></td></tr></table></figure>

<h2 id="5、更新视图"><a href="#5、更新视图" class="headerlink" title="5、更新视图"></a>5、更新视图</h2><p>和修改表相似，更新视图包括修改视图本身，和修改视图中的内容两部分。</p>
<p><strong>修改视图本身</strong>：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#方式一：可用于修改和创建视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or replace</span> <span class="hljs-keyword">view</span>  视图名<br><span class="hljs-keyword">as</span> 查询语句;<br><br># 方式二：<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">view</span> 视图名<br><span class="hljs-keyword">as</span> 查询语句;<br></code></pre></td></tr></table></figure>

<p><strong>修改视图的内容</strong></p>
<p>一般的视图只用来查询，对视图进行插入、删除、修改数据，如果能操作成功，则会对源表中的数据也会进行修改。但是绝大多数情况下无法对视图进行修改，而且也不建议对视图进行修改。</p>
<p>以下情况的视图无法更新：</p>
<ul>
<li>SQL语句包含<code>分组函数</code>、<code>distinct</code>、<code>group by</code>、<code>having</code>、<code>union</code>或者<code>union all</code>的视图</li>
<li>常量视图</li>
<li><code>select</code>中包含子查询的视图</li>
<li>包含<code>join</code>的视图</li>
<li><code>from</code>一个不能更新的视图</li>
<li><code>where</code>子句的子查询引用了<code>from</code>子句中的表</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量包括：</p>
<ul>
<li>系统变量<ul>
<li>全局变量</li>
<li>会话变量</li>
</ul>
</li>
<li>自定义变量<ul>
<li>用户变量</li>
<li>局部变量</li>
</ul>
</li>
</ul>
<h2 id="1、系统变量"><a href="#1、系统变量" class="headerlink" title="1、系统变量"></a>1、系统变量</h2><p><strong>系统变量</strong>：变量由系统定义，不是用户定义，属于服务器层面。必须拥有super权限才能修改系统变量。</p>
<p>系统变量分为<strong>全局变量</strong>和<strong>会话变量</strong>。全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认为会话级别。</p>
<p><strong>全局变量</strong></p>
<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有会话（连接）有效，但不能跨重启。</p>
<p>查看全局变量：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 查看所有全局变量</span><br>SHOW <span class="hljs-keyword">GLOBAL</span> VARIABLES<span class="hljs-comment">;</span><br><br><span class="hljs-meta"># 查看满足条件的部分系统变量</span><br>SHOW <span class="hljs-keyword">GLOBAL</span> VARIABLES LIKE <span class="hljs-string">&#x27;xxx&#x27;</span><span class="hljs-comment">;</span><br><br><span class="hljs-meta"># 查看指定的系统变量的值，</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-symbol">@global</span>.变量名<br></code></pre></td></tr></table></figure>

<p>设置全局变量：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 以autocommit为例</span><br><span class="hljs-comment"># 方式一：</span><br><span class="hljs-builtin-name">SET</span> @@global.变量名=值;<br><span class="hljs-comment"># 方式二：</span><br><span class="hljs-builtin-name">SET</span> GLOBAL 变量名=值;<br></code></pre></td></tr></table></figure>

<p><strong>会话变量</strong></p>
<p>作用域：针对于当前会话（连接）有效</p>
<p>查看会话变量：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 查看所有会话变量</span><br><span class="hljs-keyword">SHOW</span> [SESSION] VARIABLES;<br><br><span class="hljs-meta"># 查看满足条件的部分会话变量</span><br><span class="hljs-keyword">SHOW</span> [SESSION] VARIABLES LIKE &#x27;xxx&#x27;;<br><br><span class="hljs-meta"># 查看指定的会话变量的值</span><br><span class="hljs-meta">#SELECT <span class="hljs-comment">@@</span>[session.]变量名;</span><br><span class="hljs-meta"># 例：</span><br><span class="hljs-built_in">SELECT</span> <span class="hljs-comment">@@</span>autocommit;<br><span class="hljs-meta"># 或写成</span><br><span class="hljs-built_in">SELECT</span> <span class="hljs-comment">@@</span>session.autocommit;<br></code></pre></td></tr></table></figure>

<p>设置会话变量：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> @@<span class="hljs-keyword">session</span>.变量名=值;<span class="hljs-keyword">SET</span> [<span class="hljs-keyword">SESSION</span>] 变量名=值;<br></code></pre></td></tr></table></figure>

<h2 id="2、自定义变量"><a href="#2、自定义变量" class="headerlink" title="2、自定义变量"></a>2、自定义变量</h2><p><strong>自定义变量</strong>是由用户自定义，而不是系统提供的。其分为<strong>用户变量</strong>和<strong>局部变量</strong>。</p>
<p>自定义变量的使用一般都有<strong>声明、赋值、使用</strong>（查看、比较、运算等）三个步骤。</p>
<p><strong>用户变量</strong></p>
<p>作用域：和会话变量的作用域相同，对于当前会话（连接）有效。在<code>begin end</code>里面和外面都可以使用。</p>
<p>声明用户变量，要求声明时必须初始化值。有两种赋值操作符：<code>=</code>和<code>:=</code></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#方式一</span><br><span class="hljs-builtin-name">SET</span> @变量名=值;<br><br><span class="hljs-comment">#方式二</span><br><span class="hljs-builtin-name">SET</span> @变量名:=值;<br><br><span class="hljs-comment">#方式三</span><br>SELECT @变量名:=值;<br></code></pre></td></tr></table></figure>

<p>为用户变量赋值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 方式一，和初始化时相同：</span><br><span class="hljs-builtin-name">SET</span> @变量名=值;<br><span class="hljs-builtin-name">SET</span> @变量名:=值;<br>SELECT @变量名:=值;<br><br><span class="hljs-comment"># 方式二：</span><br>SELECT 字段 INTO @变量名 <span class="hljs-keyword">FROM</span> 表;<br></code></pre></td></tr></table></figure>

<p>查看用户变量：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">SELECT</span> @变量名;<br></code></pre></td></tr></table></figure>

<p><strong>局部变量</strong></p>
<p>作用域：仅在定义它的<code>begin end</code>块中有效。</p>
<p>声明局部变量必须在<code>begin end</code>块中的最前面部分。</p>
<p>局部变量一般不用加<code>@</code>符号，但是声明时需要指定类型，用户变量不需要指定类型。</p>
<p>声明局部变量：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DECLARE</span> 变量名 类型 [<span class="hljs-keyword">DEFAULT</span> 值];<br></code></pre></td></tr></table></figure>

<p>为局部变量赋值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#方式一，同样是三种：</span><br><span class="hljs-builtin-name">SET</span> 局部变量名=值;<br><span class="hljs-builtin-name">SET</span> 局部变量名:=值;<br>SELECT @局部变量名:=值;<br><br><span class="hljs-comment">#方式二：</span><br>SELECT 字段 INTO 局部变量名 <span class="hljs-keyword">FROM</span> 表;<br></code></pre></td></tr></table></figure>

<p>查看局部变量的值：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">SELECT 局部变量名<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h1 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h1><p>存储过程和函数都是事先经过编译 并存储在数据库中的一段SQL语句的集合。</p>
<p>优势：</p>
<ul>
<li>提高了sql语句的重用性，减少了开发人员的压力</li>
<li>提高了数据处理的效率</li>
<li>减少数据在数据库和应用服务器之间的传输次数</li>
</ul>
<h2 id="1、存储过程"><a href="#1、存储过程" class="headerlink" title="1、存储过程"></a>1、存储过程</h2><p><strong>创建存储过程</strong></p>
<p>语法：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-function"><span class="hljs-keyword">procedure</span> 存储过程名<span class="hljs-params">(参数模式 参数名 参数类型,...)</span><span class="hljs-title">begin</span>	存储过程体<span class="hljs-params">(一条或多条合法的SQL语句)</span>;</span><span class="hljs-keyword">end</span> 结束符<br></code></pre></td></tr></table></figure>

<p>参数可以有0个（比如只有插入语句）或多个。参数模式包括三种：</p>
<ul>
<li><code>IN</code>：表示该参数可以作为输入，即该参数需要调用方传入值</li>
<li><code>OUT</code>：表示该参数可以作为输出，即该参数可以作为返回值</li>
<li><code>INOUT</code>：表示该参数既可以作为输入又可以作为输出，即该参数既需要传入值，又可以返回值</li>
</ul>
<p>存储过程体如果只有一个SQL语句，可以省略<code>begin</code>和<code>end</code>，如果有多个SQL语句，<strong>每条SQL语句必须需要使用<code>;</code>结尾</strong>。</p>
<p>MySQL默认将<code>;</code>作为结束符，所以如果存储过程中有多个语句，但又希望将多个语句都执行，因此创建存储过程之前需要将修改默认的结束符。使用 <code>delimiter</code>重新设置结束符，保证过程体中的<code>;</code>被直接传递到服务器，而不会被客户端解释。例如，将<code>//</code>设置结束符的语句为：<code>delimiter //</code></p>
<p>SQLyog 10.0，定义存储过程前必须要设置结束符，生成的存储过程会自动将结束符设置为<code>$$</code>，如果没有手动将结束符改为<code>;</code>，系统会自动添加<code>delimiter ;</code>语句，因此每次创建存储过程都要重新设置结束符。</p>
<p>手写存储过程，建议在开头设置结束符，在末尾将结束符重新设置为<code>;</code></p>
<p><strong>调用存储过程</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">call 存储结构名(实参);<br># 如果是<span class="hljs-keyword">in</span>模式的参数，可以直接传入值<br># 如果是<span class="hljs-keyword">out</span>或<span class="hljs-keyword">inout</span>模式的参数，必须预先定义变量，然后作为参数传入。<br></code></pre></td></tr></table></figure>

<p><strong>删除存储过程</strong></p>
<p>存储过程不能修改，一般做法是将原来的删除，然后新建。</p>
<figure class="highlight cal"><table><tr><td class="code"><pre><code class="hljs cal"># 每次只能删除一个，不能删除多个<br>DROP <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> [<span class="hljs-title">IF</span> <span class="hljs-title">EXISTS</span>] 存储过程名;</span><br></code></pre></td></tr></table></figure>

<p><strong>查看存储过程</strong></p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene">SHOW <span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> 存储过程名;</span><br></code></pre></td></tr></table></figure>

<p>例：创建存储过程，输入员工id，输出其管理者的id和名字</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-comment">/* 声明存储结构</span><br><span class="hljs-comment">*/</span><br>DELIMITER @@  # 设置结束符为@@<br># 确保存储过程能正确创建，如果已经存在，删除原有的<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-symbol">`myp`</span>@@<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> myp(<span class="hljs-keyword">IN</span> id INT,<br>                     OUT managerId INT,<br>                     OUT managerName VARCHAR(<span class="hljs-number">20</span>))<br><span class="hljs-keyword">BEGIN</span><br>	# 将查询的结果值赋给输出变量，这里参数为局部变量<br>	<span class="hljs-keyword">SELECT</span> m.<span class="hljs-symbol">`employee_id`</span>,m.<span class="hljs-symbol">`last_name`</span> <span class="hljs-keyword">INTO</span> managerId,managerName<br>	<span class="hljs-keyword">FROM</span> employees m <br>	<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> employees <span class="hljs-built_in">e</span><br>	<span class="hljs-keyword">ON</span> m.<span class="hljs-symbol">`employee_id`</span>=<span class="hljs-built_in">e</span>.<span class="hljs-symbol">`manager_id`</span><br>	<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`employee_id`</span>=id;<br>END @@  # end后面要加设置的结束符<br>DELIMITER ;  # 将结束符改回分号<br><br><span class="hljs-comment">/*调用存储结构</span><br><span class="hljs-comment">in模式参数直接传入值，</span><br><span class="hljs-comment">out模式的参数要先声明，或者传入的时候指定名字</span><br><span class="hljs-comment">*/</span><br>CALL myp (110,@mid,@mname);  # 调用存储结构，传入参数<br><span class="hljs-keyword">SELECT</span> @mid,@mname;  # 查看结果值<br></code></pre></td></tr></table></figure>

<h2 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数</h2><p>函数和存储过程相似，唯一的区别是，<strong>存储过程可以有0个返回值</strong>，也可以有多个返回，适合做批量插入、批量更新；而<strong>函数有且仅有1个返回值</strong>，适合做处理数据后返回一个结果的情况。</p>
<p><strong>创建函数</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">CREATE <span class="hljs-keyword">FUNCTION</span> <span class="hljs-title">函数名</span>(参数名 参数类型,...) RETURNS 返回类型BEGIN	函数体;	<span class="hljs-keyword">RETURN</span> <span class="hljs-type">xx</span>;  #必须有返回值<span class="hljs-keyword">END</span> 结束符<br></code></pre></td></tr></table></figure>

<p>和存储过程相同，函数的参数也可是是0个或多个；结束符和存储过程的用法也相同；如果函数体只有一句，同样可以省略<code>begin end</code>语句。</p>
<p><strong>调用函数</strong></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">SELECT</span> 函数名(参数列表);  # 存储过程用的是<span class="hljs-keyword">CALL</span><br></code></pre></td></tr></table></figure>

<p><strong>删除函数</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># 同样每次只能删除一个<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span>] 函数名; <br></code></pre></td></tr></table></figure>

<p><strong>查看函数</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> 函数名;<br></code></pre></td></tr></table></figure>

<p>函数使用案例：根据部门名，返回该部门的平均工资</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*创建函数*/</span><span class="hljs-keyword">DELIMITER</span> @@   # 先将分隔符设置为@@<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> `myf`@@<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf(deptName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)) <span class="hljs-keyword">RETURNS</span> DOUBLEBEGIN	#声明一个局部变量，用于接收查询结果，并返回	<span class="hljs-keyword">DECLARE</span> sal <span class="hljs-type">DOUBLE</span> ;	<span class="hljs-keyword">SELECT</span> AVG(salary) <span class="hljs-keyword">INTO</span> sal	<span class="hljs-keyword">FROM</span> employees e	<span class="hljs-keyword">JOIN</span> departments d <span class="hljs-keyword">ON</span> e.department_id = d.department_id	<span class="hljs-keyword">WHERE</span> d.department_name=deptName;	<span class="hljs-keyword">RETURN</span> sal;  # 返回结果值<span class="hljs-keyword">END</span> @@<span class="hljs-keyword">DELIMITER</span> ;  # 将分隔符重新设置为分号<span class="hljs-comment">/*调用函数*/</span><span class="hljs-keyword">SELECT</span> myf(<span class="hljs-string">&#x27;IT&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h1 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h1><p>流程控制结构包括以下三种：</p>
<ul>
<li>顺序结构：程序从上到下依次执行</li>
<li>分支结构：程序从两条或多条路径中选择一条去执行，比如<code>if</code>、<code>case</code>结构</li>
<li>循环结构：程序在满足一定条件的基础上，重复执行一段代码，比如<code>while</code>、<code>loop</code>、<code>repeat</code></li>
</ul>
<h2 id="1、分支结构"><a href="#1、分支结构" class="headerlink" title="1、分支结构"></a>1、分支结构</h2><p>分支结构包括<code>if结构</code>和<code>case结构</code>，只能用于<code>begin end</code>中，要和<code>if函数</code>、<code>case函数</code>区分开，<a href="https://kangshitao.github.io/2021/04/26/mysql-basis/#refer2">流程控制函数</a>既可以用在<code>begin end</code>里面，也可以用在外面。<code>if函数</code>适用于简单双分支，而<code>if结构</code>适用于区间判断的多分支，<code>case</code>适用于等值判断。</p>
<p><strong>if结构</strong></p>
<p>语法：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">if 条件<span class="hljs-number">1</span> then 语句<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>elseif 条件<span class="hljs-number">1</span> then 语句<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>...<br>else 语句n<span class="hljs-comment">;</span><br>end if<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>case结构</strong></p>
<p>语法：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 方式一：类似于switch</span><br><span class="hljs-keyword">case</span> 表达式<br><span class="hljs-keyword">when</span> 值<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">when</span> 值<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 语句<span class="hljs-number">2</span>;<br>...<br><span class="hljs-keyword">else</span> 语句n;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br><br><span class="hljs-comment"># 方式二：类似于多重if</span><br><span class="hljs-keyword">case</span> <br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 语句<span class="hljs-number">2</span>;<br>...<br><span class="hljs-keyword">else</span> 语句n;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br></code></pre></td></tr></table></figure>

<p><strong>分支结构使用案例</strong></p>
<p>创建函数，实现传入成绩返回等级的功能。如果成绩&gt;90，返回A，如果成绩&gt;80，返回B，如果成绩&gt;60，返回C，否则返回D。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 方式一：使用<span class="hljs-keyword">if</span>结构<br><span class="hljs-keyword">DELIMITER</span> @@   # 先将分隔符设置为@@<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> `myf_if`@@<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf_if(score <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">CHAR</span><br><span class="hljs-keyword">BEGIN</span><br>	# 设置局部变量保存结果<br>	<span class="hljs-keyword">DECLARE</span> ch <span class="hljs-type">CHAR</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>	<span class="hljs-keyword">IF</span> score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;A&#x27;</span>;<br>	ELSEIF score&gt;<span class="hljs-number">80</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;B&#x27;</span>;<br>	ELSEIF score&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;C&#x27;</span>;<br>	<span class="hljs-keyword">ELSE</span> ch=<span class="hljs-string">&#x27;D&#x27;</span>;<br>	<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>	<span class="hljs-keyword">RETURN</span> ch;<br><span class="hljs-keyword">END</span> @@<br><span class="hljs-keyword">DELIMITER</span> ;<br>#调用函数<br><span class="hljs-keyword">SELECT</span> myf_if(<span class="hljs-number">87</span>);<br><br># 方式二：使用<span class="hljs-keyword">case</span>结构<br><span class="hljs-keyword">DELIMITER</span> @@   # 先将分隔符设置为@@<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> `myf_case`@@<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf_case(score <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">CHAR</span><br><span class="hljs-keyword">BEGIN</span> <br>	#设置局部变量保存结果<br>	<span class="hljs-keyword">DECLARE</span> ch <span class="hljs-type">CHAR</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>	<span class="hljs-keyword">CASE</span> <br>	<span class="hljs-keyword">WHEN</span> score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;A&#x27;</span>;<br>	<span class="hljs-keyword">WHEN</span> score&gt;<span class="hljs-number">80</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;B&#x27;</span>;<br>	<span class="hljs-keyword">WHEN</span> score&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;C&#x27;</span>;<br>	<span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;D&#x27;</span>;<br>	<span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br>	<span class="hljs-keyword">RETURN</span> ch;<br><span class="hljs-keyword">END</span> @@<br><span class="hljs-keyword">DELIMITER</span> ;<br>#调用函数<br><span class="hljs-keyword">SELECT</span> myf_case(<span class="hljs-number">56</span>);<br></code></pre></td></tr></table></figure>

<h2 id="2、循环结构"><a href="#2、循环结构" class="headerlink" title="2、循环结构"></a>2、循环结构</h2><p>循环结构包括<code>while</code>，<code>loop</code>，<code>repeat</code>三种。</p>
<p>同样，循环结构只能在<code>begin end</code>中使用。</p>
<p>循环结构中，包括两个循环控制语句：</p>
<ul>
<li><code>iterate</code>：类似于java中的continue，结束本次循环，进入下一次循环。</li>
<li><code>leave</code>：类似于java中的breek，跳出当前循环体。</li>
</ul>
<p><strong>循环控制语句后面必须有循环结构的标签名</strong>，也就是说，如果循环结构中使用了循环控制语句，此循环结构必须添加标签。</p>
<p><strong>while结构</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">[标签:] <span class="hljs-keyword">WHILE</span> 循环条件 <span class="hljs-keyword">DO</span><br>	循环体<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span> [标签];<br></code></pre></td></tr></table></figure>

<p><strong>loop结构</strong></p>
<p><code>loop</code>结构没有循环条件，想要结束循环必须使用<code>leave</code>语句，<code>loop</code>结构可以用于模拟简单的死循环。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">[标签:] <span class="hljs-keyword">loop</span><br>	循环体;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span> [标签];<br></code></pre></td></tr></table></figure>

<p><strong>repeat结构</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">[标签:] <span class="hljs-keyword">repeat</span><br>	循环体;<br><span class="hljs-keyword">until</span> 结束循环条件<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">repeat</span> [标签];<br></code></pre></td></tr></table></figure>

<p>使用循环结构的案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 使用存储结构和循环结构，实现批量插入，要求只插入偶数次的记录<br><span class="hljs-keyword">DELIMITER</span> @@   # 先将分隔符设置为@@<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> test_while@@<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> test_while(<span class="hljs-keyword">IN</span> insertCount <span class="hljs-type">INT</span>)<br><span class="hljs-keyword">BEGIN</span><br>	<span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>	a: <span class="hljs-keyword">WHILE</span> i&lt;=insertCount <span class="hljs-keyword">DO</span><br>		<span class="hljs-keyword">SET</span> i=i+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">IF</span> MOD(i,<span class="hljs-number">2</span>)!=<span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> ITERATE a;<br>		<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>		<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">admin</span>(username,`<span class="hljs-keyword">password</span>`) <br>		<span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;xiaohua&#x27;</span>,i),<span class="hljs-string">&#x27;0000&#x27;</span>);<br>	<span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span> a;<br><span class="hljs-keyword">END</span> @@<br><span class="hljs-keyword">DELIMITER</span> ;<br><br># 传入<span class="hljs-number">100</span>，只会插入偶数时的记录<br><span class="hljs-keyword">CALL</span> test_while1(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列中间件：RabbitMQ</title>
    <url>/2021/11/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9ARabbitMQ/</url>
    <content><![CDATA[<p>消息队列（MQ，Message Queue）本质是一个队列，队列中存放的内容是message，是一种跨进程的通信机制，用于上下游传递消息。RabbitMQ是一个消息中间件，它接受、存储、转发消息数据。</p>
<span id="more"></span> 



<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="1-1-MQ相关概念"><a href="#1-1-MQ相关概念" class="headerlink" title="1.1 MQ相关概念"></a>1.1 MQ相关概念</h2><h3 id="1-1-1-什么是MQ"><a href="#1-1-1-什么是MQ" class="headerlink" title="1.1.1 什么是MQ"></a>1.1.1 什么是MQ</h3><p>消息队列（MQ，Message Queue）本质是一个队列，队列中存放的内容是message，是一种跨进程的通信机制，用于上下游传递消息。</p>
<p>使用MQ以后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>
<h3 id="1-1-2-MQ的作用"><a href="#1-1-2-MQ的作用" class="headerlink" title="1.1.2 MQ的作用"></a>1.1.2 MQ的作用</h3><ul>
<li><p>流量削峰</p>
</li>
<li><p>应用解耦</p>
</li>
<li><p>异步处理</p>
</li>
</ul>
<h3 id="1-1-3-MQ分类"><a href="#1-1-3-MQ分类" class="headerlink" title="1.1.3 MQ分类"></a>1.1.3 MQ分类</h3><p>常见的MQ有以下几种：</p>
<ul>
<li>ActiveMQ：高吞吐量场景较少使用。</li>
<li>Kafka：为大数据而生，百万级TPS，吞吐量高，在日志领域比较成熟。适合有日志采集需求的大型企业。</li>
<li>RocketMQ：出自阿里巴巴，单机吞吐量十万级，消息0丢失，支持10亿级别的消息堆积。适合金融互联网。</li>
<li>RabbitMQ：由Erlang语言开发，在AMQP（高级消息队列协议）基础上完成，当前最流行的MQ。吞吐量万级，支持多种语言。适合数据量不是特别大的中小型公司。</li>
</ul>
<h2 id="1-2-RabbitMQ"><a href="#1-2-RabbitMQ" class="headerlink" title="1.2 RabbitMQ"></a>1.2 RabbitMQ</h2><h3 id="1-2-1-核心概念"><a href="#1-2-1-核心概念" class="headerlink" title="1.2.1 核心概念"></a>1.2.1 核心概念</h3><p><strong>RabbitMQ</strong></p>
<p>RabbitMQ是一个消息中间件，它接受、存储、转发消息数据。</p>
<p><strong>生产者（Producer）</strong></p>
<p>产生数据、发送消息的程序是生产者。</p>
<p><strong>交换机（Exchange）</strong></p>
<p>交换机是RabbitMQ的一个重要组件。它一方面接收来自生产者的消息，另一方面将消息推送到队列中。交换机决定了将消息推送到特定队列还是推送到多个队列。</p>
<p><strong>队列（Queue）</strong></p>
<p>队列是RabbitMQ内部使用的一种数据结构。消息只能存储在队列中，队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者也可以尝试从一个队列接收数据。</p>
<p><strong>消费者（Consumer）</strong></p>
<p>消费者指的是等待接受消息的程序。同一个应用程序既可以是生产者也可以是消费者。</p>
<h3 id="1-2-2-安装"><a href="#1-2-2-安装" class="headerlink" title="1.2.2 安装"></a>1.2.2 安装</h3><p>RabbitMQ官方文档：<a href="https://www.rabbitmq.com/documentation.html">Docs</a></p>
<p>RabbitMQ基于Erlang环境，因此需要先安装Erlang。</p>
<p>安装之前需要确保RabbitMQ和Erlang的版本要对应：<a href="https://www.rabbitmq.com/which-erlang.html">RabbitMQ Erlang Version Requirements</a></p>
<p>本机环境：</p>
<ul>
<li>CentOS-7.9</li>
<li>Erlang-23.2.3</li>
<li>RabbitMQ-3.8.15</li>
</ul>
<p>使用<code>rpm</code>方式，在packagecloud网站下载安装包。</p>
<p><strong>1、安装Erlang</strong></p>
<p>下载对应版本的安装包，<a href="https://packagecloud.io/rabbitmq/erlang?page=1">packagecloud</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget --content-disposition https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-23.2.3-1.el7.x86_64.rpm/download.rpm<br></code></pre></td></tr></table></figure>

<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rpm -ivh erlang-23.2.3-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure>



<p><strong>2、安装socat</strong></p>
<p>除了Erlang环境，还需要安装socat：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum install socat logrotate -y<br></code></pre></td></tr></table></figure>



<p><strong>3、安装RabbitMQ</strong></p>
<p>下载对应版本的安装包，<a href="https://packagecloud.io/rabbitmq/rabbitmq-server?page=1">packagecloud</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget --content-disposition https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/8/rabbitmq-server-3.8.15-1.el8.noarch.rpm/download.rpm<br></code></pre></td></tr></table></figure>

<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rpm -ivh rabbitmq-server-3.8.15-1.el8.noarch.rpm<br></code></pre></td></tr></table></figure>

<p>安装完成后，启动rabbit服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl start rabbitmq-server.service<br></code></pre></td></tr></table></figure>

<p><strong>4、安装插件</strong></p>
<p>可以通过以下命令开启web管理插件，需要先停止rabbitmq服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure>

<p>插件开启成功后就可以在浏览器中访问，默认端口号为<code>15672</code>（记得关闭防火墙或者开放端口）。</p>
<p>管理界面需要账号密码登陆，默认的账号和密码都是<code>guest</code>。</p>
<p>查看当前所有用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmqctl list_users<br></code></pre></td></tr></table></figure>



<p>添加新用户<code>admin</code>，密码也为<code>admin</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmqctl add_user admin admin<br></code></pre></td></tr></table></figure>



<p>设置用户角色（标签），将<code>admin</code>设置为<code>administrator</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmqctl set_user_tags admin administrator<br></code></pre></td></tr></table></figure>



<p>设置用户权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmqctl set_permissions -p <span class="hljs-string">&quot;/&quot;</span> admin <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span><br></code></pre></td></tr></table></figure>





<h3 id="1-2-3-原理和工作模式"><a href="#1-2-3-原理和工作模式" class="headerlink" title="1.2.3 原理和工作模式"></a>1.2.3 原理和工作模式</h3><p><strong>工作原理</strong></p>
<p>RabbitMQ的工作原理如图所示：</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211015214425680.png" alt="image-20211015214425680"></p>
<p>生产者将消息通过Channel发送到Exchange，Exchange决定将消息分发到哪个队列，然后由消费者从队列中接收消息。</p>
<p>其中的核心概念：</p>
<ul>
<li><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是Message Broker</li>
<li><strong>Virtual host</strong>：虚拟的分组，当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange/queue等。</li>
<li><strong>Connection</strong>：publisher/consumer和broker之间的TCP连接。</li>
<li><strong>Channel</strong>：Channel是在connection内部建立的逻辑连接，多线程情况下通常每个线程创建单独的channel进行通讯。AMQP method包含了channel id帮助客户端和broker识别channel，<strong>channel是完全隔离的</strong>。<strong>Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。</strong></li>
<li><strong>Exchange</strong>：交换机。消息到达broker中会首先到达Exchange，Exchange根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct（point-to-point）、topic（publish-subscribe）、fanout（multicast）。</li>
<li><strong>Queue</strong>：消息被送到Queue中，然后被消费者取走。</li>
<li><strong>Binding</strong>：<strong>exchange</strong>和<strong>queue</strong>之间的虚拟连接。binding中可以包含Routing key，binding信息被保存到exchange中的查询表中，用于message的分发依据。声明binding关系的时候，可以声明RoutingKey参数</li>
</ul>
<p><strong>工作模式</strong></p>
<p>RabbitMQ一共有7种工作模式，参考<a href="https://www.rabbitmq.com/getstarted.html">Get Started</a>：</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211015222337420.png" alt="image-20211015222337420"></p>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html">Hello World</a>模式是RabbitMQ最简单的一个模式。下图中的P表示生产者，C是消费者，中间框是一个队列，是RabbitMQ代表消费者保存的消息缓冲区。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211015222548402.png" alt="Hello World模式"></p>
<h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h2><p><strong>1、在IDEA中创建Maven项目，然后引入依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>2、编写生产者的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;    <span class="hljs-comment">// 队列名称    public static final String QUEUE_NAME = &quot;hello&quot;;    //发消息    public static void main(String[] args) throws IOException, TimeoutException &#123;        //创建一个连接工厂        ConnectionFactory factory = new ConnectionFactory();        //设置工厂的ip，连接队列        factory.setHost(&quot;192.168.198.198&quot;); //RabbitMQ服务主机的ip        //设置用户名和密码        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;admin&quot;);        //创建连接，每个连接有多个channel，channel是用来发消息的。        Connection connection = factory.newConnection();        //获取channel        Channel channel = connection.createChannel();        //生成一个队列用于通信，简单起见，使用默认的交换机        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //发消息        String message = &quot;hello, world&quot;;        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());        System.out.println(&quot;消息发送完毕！&quot;);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>其中关键方法的说明：</p>
<ul>
<li><code>queueDeclare()</code>，用于声明一个队列，其中的各个参数依次解释如下：<ul>
<li>队列名。</li>
<li>队列的消息是否持久化，默认情况下消息存储在内存中(不持久化）。</li>
<li>该队列是否进行消费共享，true表示允许多个消费者消费。</li>
<li>是否自动删除 最后一个消费者端开连接以后，该队列是否自动删除。</li>
<li>其他参数。</li>
</ul>
</li>
<li><code>basicPublish()</code>，用于发布消息：<ul>
<li>交换机名称，用于指定发送到哪个交换机。</li>
<li>routingKey，路由的key值。这里使用的是channel名字作为routingKey</li>
<li>其他参数信息。</li>
<li>发送消息的消息体。</li>
</ul>
</li>
</ul>
<p><strong>3、编写消费者的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-comment">// 队列名称    public static final String QUEUE_NAME = &quot;hello&quot;;        //接收消息    public static void main(String[] args) throws IOException, TimeoutException &#123;        //创建连接工厂        ConnectionFactory factory = new ConnectionFactory();        //设置ip        factory.setHost(&quot;192.168.198.198&quot;);        //设置用户名和密码        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;admin&quot;);        //创建连接        Connection connection = factory.newConnection();        //创建信道        Channel channel = connection.createChannel();        //消费者接收消息（消费消息）        //接收消息的回调函数        DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123;            System.out.println(new String(message.getBody()));        &#125;;        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;            System.out.println(&quot;消息消费被中断&quot;);        &#125;;        channel.basicConsume(QUEUE_NAME,true, deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<p><code>basicConsume()</code>的参数说明：</p>
<ul>
<li>指定消费的队列名，即从哪个队列中取消息。</li>
<li>消费成功之后是否自动应答。</li>
<li>消费者接收的回调函数。</li>
<li>消费者取消消费的回调函数。</li>
</ul>
<blockquote>
<p>如果需要修改现有的exchange和queue，需要删除现有的队列，重新创建。</p>
</blockquote>
<p><strong>4、运行</strong></p>
<p>启动生产者程序，会创建Channel并发送消息，然后启动消费者程序，会收到来自生产者的消息。</p>
<h1 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h1><p><a href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html">Work Queues</a>模式的主要思想是避免因立即执行资源密集型任务而不得不等待它完成。在这个模式中，我们将任务封装为消息，并将其发送到队列。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211016200456597.png" alt="Work Queues"></p>
<h2 id="3-1-轮询分发消息"><a href="#3-1-轮询分发消息" class="headerlink" title="3.1 轮询分发消息"></a>3.1 轮询分发消息</h2><p>Work Queues模式下使用的轮询分发的机制，对于多个消费者线程，会轮流分发任务。</p>
<p>下面我们以一个生产者，两个消费者线程来模拟。</p>
<p><strong>抽取工具类</strong></p>
<p>创建channel之前的代码是相同的，因此可以单独抽取出来，作为工具类：</p>
<p><code>RabbitMqUtils.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqUtils</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title">getChannel</span><span class="hljs-params">()</span></span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">&quot;192.168.198.198&quot;</span>);        factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);        factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);        Connection connection = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = factory.newConnection();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;            e.printStackTrace();        &#125;        Channel channel = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            channel = connection.createChannel();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> channel;    &#125;&#125;<br></code></pre></td></tr></table></figure>

<p><strong>生产者</strong></p>
<p>启动发送线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task01</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        channel.queueDeclare(QUEUE_NAME,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);        <span class="hljs-comment">//从控制台接收信息发送到消费者        Scanner scanner = new Scanner(System.in);        while(scanner.hasNext())&#123;            String message = scanner.next();            channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());            System.out.println(message+&quot;发送完成！&quot;);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>启动两个工作线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker01</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">//消息的接收        DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123;            System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody()));        &#125;;        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;            System.out.println(consumerTag+&quot;消息被取消接受&quot;);        &#125;;        System.out.println(&quot;Consumer 1------&quot;);        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>使用IDEA设置并行运行，<code>Edit Configurations</code>-&gt;<code>Allow multiple instances</code>，这样可以同时启动两个消费者线程。</p>
<p><strong>运行</strong></p>
<p>生产者发送消息，消费者1和消费者2会轮流处理消息。</p>
<p>比如生产者发送1、2、3、4、5、6，消费者1接收到1、3、5，消费者2接收到2、4、6。</p>
<h2 id="3-2-消息应答"><a href="#3-2-消息应答" class="headerlink" title="3.2 消息应答"></a>3.2 消息应答</h2><p><strong>概念</strong></p>
<p>消费者完成一个任务需要耗费一定的时间，RabbitMQ一旦向消费者发送消息后，会将此消息标记为删除，这种情况下，如果消费者处理任务的过程中出现故障，会导致任务丢失。<strong>为了保证消息不会丢失，RabbitMQ引入了消息应答机制</strong>。</p>
<p><strong>消息应答（Message acknowledgment）</strong>：消费者在接收到消息并且处理完该消息之后，告诉RabbitMQ此消息已经被处理，RabbitMQ可以将该消息删除。这样就保证当某一个消费者线程故障后，消息会被重新发送给其他消费者，确保消息不会丢失（前提是RabbitMQ无故障）。</p>
<p>消息应答包括<strong>自动应答</strong>和<strong>手动应答</strong>两种方式：</p>
<ul>
<li><strong>自动应答</strong>：消息发送后立即被认为已经传送成功。这种方式没有对传递的消息数量做限制，会导致消费者端消息积压，线程被系统杀死。这种模式仅适用于消费者可以高效并以某种速率能够处理这些消息的情况下使用。</li>
<li><strong>手动应答</strong>：默认是手动应答模式。如果一个消费者线程宕机，其消息可以被其他消费者线程消费，而不会出现消息丢失的情况。</li>
</ul>
<p>手动应答示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** * 消息在手动应答时不丢失、放回队列中重新消费 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker03</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TASK_QUEUE_NAME = <span class="hljs-string">&quot;ack_queue&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel(); <span class="hljs-comment">//获取channel        System.out.println(&quot;消费者1等待接收消息，处理时间较短------&quot;);        //手动应答        boolean autoAck = false;        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            //沉睡1s，模拟处理信息场景。            SleepUtils.sleep(1); //工具类SleepUtils用来睡眠线程。            System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));            //手动应答。参数1为消息的标记tag，参数2表示是否批量应答            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);        &#125;;        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;            System.out.println(consumerTag+&quot;消息被取消接受&quot;);        &#125;;        //设置为手动应答        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>手动应答主要是在接收消息的回调方法中调用<code>basicAck()</code>方法，已经在<code>basicConsume()</code>方法中设置自动应答方式为false。</p>
<p>其中<code>basicAck()</code>方法的第二个参数表示是否批量化应答。如果是**批量化应答(Multiple)**，则每次会应答一个批次的消息。</p>
<p><strong>手动应答的好处就是可以批量应答并且减少网络拥堵</strong>。</p>
<p><strong>消息重新入队</strong>：如果某个消费者由于某些原因失去连接（或发生故障），导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将其重新排队发送给其他消费者。这样，即使某个消费者偶尔死亡，也可以确保不丢失消息。</p>
<h2 id="3-3-RabbitMQ持久化"><a href="#3-3-RabbitMQ持久化" class="headerlink" title="3.3 RabbitMQ持久化"></a>3.3 RabbitMQ持久化</h2><p><strong>消息应答</strong>能够确保消费者线程故障后，消息不会丢失，如何保障当RabbitMQ服务停掉以后消息也不丢失？</p>
<p>这就<strong>需要将队列和消息都标记为持久化。</strong></p>
<p><strong>队列持久化</strong></p>
<p>在声明队列时将是否持久化的参数置为<code>true</code>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.queueDeclare(TASK_QUEUE_NAME,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure>

<p>第二个参数就表示是否持久化队列。</p>
<p>如果已经存在的队列需要持久化，需要将队列删除，重新创建。</p>
<p><strong>消息持久化</strong></p>
<p>仅将队列持久化不能保证消息不丢失，因为如果消费者线程宕机断开连接，仍然有可能出现消息丢失的情况。</p>
<p>设置消息持久化，需要在<code>channel</code>发布消息时设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>这种方式只是尽量保证持久化，如果绝对保证持久化，需要使用发布确认机制。</p>
<p><strong>预取值</strong></p>
<p><code>basicQos()</code>方法可以设置消费者线程的预取值。</p>
<p>预取值表示一个消费者线程对应的信道最大可以堆积的消息个数，即<strong>通道上允许的未确认消息的最大数量</strong>。</p>
<blockquote>
<p>类似于缓冲池，预取值最大值就是缓存池的最大值。最多只能存放预取值个数的未确认消息。</p>
</blockquote>
<p>如果不设置预取值，可能会有大量已传递但尚未处理的消息的数量堆积，导致消费者RAM消耗。</p>
<p><strong>不公平分发</strong></p>
<p>轮询方式是不管每个消费者的处理速度，给每个消费者线程轮流分发任务。</p>
<p>不公平分发是指<strong>根据每个消费者线程的处理能力，为每个消费者线程分配不同个数的消息</strong>。——能者多劳。</p>
<p>在<strong>消费者</strong>的信道上，设置Qos的值为1，就可以表示按处理能力分发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将Qos设置为1，就是不公平分发；默认为0，表示轮询分发channel.basicQos(1); </span><br></code></pre></td></tr></table></figure>

<p>Qos的值为1时，表示根据消费者线程的处理能力分发，最多堆积一个任务。</p>
<h1 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h1><p>如果想要确保消息一定不会丢失，除了上面提到的<strong>队列持久化</strong>和<strong>消息持久化</strong>，还需要使用<strong>发布确认（Publisher confirm）</strong>。这三种设置保证了消息不会丢失。</p>
<p>官方文档：<a href="https://www.rabbitmq.com/tutorials/tutorial-seven-java.html">Publisher Confirms</a></p>
<h2 id="4-1-发布确认原理"><a href="#4-1-发布确认原理" class="headerlink" title="4.1 发布确认原理"></a>4.1 发布确认原理</h2><p>生产者将channel设置为confirm模式，一旦channel进入<strong>confirm模式</strong>，<strong>所有在该channel上面发布的消息都会被指派一个唯一的ID（从1开始）</strong>。一旦消息被投递到所有匹配的队列之后，broker会发送一个确认给生产者。</p>
<p>生产者得知消息已经正确到达目的队列后，如果消息和队列是可持久化的，确认消息会在消息写入磁盘后发出。</p>
<blockquote>
<p>broker回传给生产者的确认消息中delivery-tag域中包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>发布确认（Publisher confirm）是broker给生产者发送的确认消息。</p>
<p>消息应答（Message acknowledgment）是消费者处理完消息发送给broker的ack确认。</p>
</blockquote>
<p><strong>confirm模式</strong>的好处在于它是异步的，发布一条消息后，生产者可以边等确认消息边发送下一条消息。消息得到确认或者丢失，生产者都会通过相应的回调方法进行处理。</p>
<h2 id="4-2-发布确认策略"><a href="#4-2-发布确认策略" class="headerlink" title="4.2 发布确认策略"></a>4.2 发布确认策略</h2><h3 id="4-2-1-开启发布确认"><a href="#4-2-1-开启发布确认" class="headerlink" title="4.2.1 开启发布确认"></a>4.2.1 开启发布确认</h3><p>生产者创建信道后，调用<code>confirmSelect()</code>方法即可开启发布确认模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.confirmSelect();<br></code></pre></td></tr></table></figure>

<p>发布确认可以有单个确认、批量确认、异步确认三种方式。</p>
<h3 id="4-2-2-单个确认发布"><a href="#4-2-2-单个确认发布" class="headerlink" title="4.2.2 单个确认发布"></a>4.2.2 单个确认发布</h3><p>单个确认发布，即对每一条消息进行同步确认，生产者发布一条消息后只有它被确认发布后，后续的消息才能继续发布。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishMessageIndividually</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    Channel channel = RabbitMqUtils.getChannel();    <span class="hljs-comment">//信道名字使用随机的UUID    String queueName = UUID.randomUUID().toString();    channel.queueDeclare(queueName,true,false,false,null);    //开启发布确认    channel.confirmSelect();    long start = System.currentTimeMillis();    //批量发消息    for(int i=0;i&lt;1000;i++)&#123;        String message = i+&quot;&quot;;        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes());        //单个消息马上确认        boolean flag = channel.waitForConfirms();        if(flag)&#123;            System.out.println(&quot;第&quot;+i+&quot;条消息发送成功&quot;);        &#125;    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布1000个单独确认消息，耗时&quot;+(end-start)+&quot;ms&quot;);&#125;</span><br></code></pre></td></tr></table></figure>

<p>单个确认发布的速度是最慢的，因为要每条消息都确认一次。</p>
<h3 id="4-2-3-批量确认发布"><a href="#4-2-3-批量确认发布" class="headerlink" title="4.2.3 批量确认发布"></a>4.2.3 批量确认发布</h3><p>批量确认发布是指根据批次大小确认发布，这种方式的缺点是当发生故障导致发布出现问题时，不知道哪个消息出问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//批量发布确认public static void publishMessageBatch() throws Exception&#123;    Channel channel = RabbitMqUtils.getChannel();    //信道名字使用随机的UUID    String queueName = UUID.randomUUID().toString();    channel.queueDeclare(queueName,true,false,false,null);    //开启发布确认    channel.confirmSelect();    long start = System.currentTimeMillis();    //批量发消息，并批量确认消息    int batchSize = 100; //每100条确认一次    for(int i=0;i&lt;1000;i++)&#123;        String message = i+&quot;&quot;;        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes());        if((i+1)%batchSize==0)&#123; //每100条消息确认一次            boolean flag = channel.waitForConfirms();            if(flag)&#123;                System.out.println(&quot;确认前&quot;+i+&quot;条数据&quot;);            &#125;        &#125;    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布1000个批量确认消息，耗时&quot;+(end-start)+&quot;ms&quot;);&#125;</span><br></code></pre></td></tr></table></figure>



<h3 id="4-2-4-异步确认发布"><a href="#4-2-4-异步确认发布" class="headerlink" title="4.2.4 异步确认发布"></a>4.2.4 异步确认发布</h3><p>异步确认发布是效率和可靠性最高的。对于已确认消息和未确认消息，异步确认方式都能够处理。</p>
<p>异步确认发布主要是通过<code>addConfirmListener</code>方法监听确认和未确认的消息，使用哈希表记录所有发布的消息，对于成功确认的消息从哈希表中删除，剩下的是未确认的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//异步批量确认public static void publishMessageAsync() throws Exception&#123;    Channel channel = RabbitMqUtils.getChannel();    //信道名字使用随机的UUID    String queueName = UUID.randomUUID().toString();    channel.queueDeclare(queueName,true,false,false,null);    //开启发布确认    channel.confirmSelect();    //使用哈希表记录所有消息，便于多个线程进行消息的添加和删除    /*线程安全的哈希表，适用于高并发的情况。    1.哈希表能够轻松的将序号和消息进行关联。    2.可以轻松地批量删除条目，只需要知道序号    3.支持高并发（多线程）    */    ConcurrentSkipListMap&lt;Long,String&gt; map = new ConcurrentSkipListMap&lt;&gt;();        long start = System.currentTimeMillis();    //创建消息的监听器，监听哪些消息成功了，哪些消息失败了。    //消息确认成功 回调函数    /*参数：1. 消息的标记（序号）2.是否为批量确认*/    ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt;&#123;        //2.删除掉已经确认的消息，剩下的就是未确认的消息        if(multiple)&#123; //默认multiple是true，即批量确认的            //如果是批量确认的，则找到所有小于当前序号的值，并清除。这样剩下的就是未确认的消息            //headMap方法就是返回所有小于指定序号的值的map，第二个参数表示是否找出等于序号的。            ConcurrentNavigableMap&lt;Long, String&gt; navigableMap = map.headMap(deliveryTag, true);            navigableMap.clear();        &#125;else&#123;//如果不是批量确认，则只删除当前已经确认的消息即可。            map.remove(deliveryTag);        &#125;        System.out.println(&quot;确认的消息：&quot;+deliveryTag);    &#125;;    //监听确认失败的消息    ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt;&#123;        //3.打印未确认的消息        System.out.println(&quot;未确认的消息：&quot;+deliveryTag);    &#125;;    /*参数：1.监听确认成功的消息 2. 监听确认失败的消息*/    channel.addConfirmListener(ackCallback,nackCallback);    //批量发消息，异步确认消息    int batchSize = 100; //每100条确认一次    for (int i = 0; i &lt; 1000; i++) &#123;        String message = &quot;消息&quot; + i;        //1.记录下所有要发送的消息        map.put(channel.getNextPublishSeqNo(),message);        //发布消息        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes());    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布&quot;+MESSAGE_COUNT+&quot;个异步确认消息，耗时&quot;+(end-start)+&quot;ms&quot;);&#125;</span><br></code></pre></td></tr></table></figure>



<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><h2 id="5-1-相关概念"><a href="#5-1-相关概念" class="headerlink" title="5.1 相关概念"></a>5.1 相关概念</h2><p>生产者生产的消息不会直接发送到队列，只能将消息发送到<strong>交换机（exchange）</strong>，然后由交换机发送到队列。</p>
<p><strong>交换机</strong>的功能：①接收来自生产者的消息。②将消息推入队列。</p>
<p>交换机主要的三个类型：</p>
<ul>
<li><strong>fanout</strong>：这种类型的交换机不分析Routing Key，将消息转发到所有和该交换机绑定的队列中。用于<a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html">Publish/Subscribe模式</a>。</li>
<li><strong>direct</strong>：这类交换机需要精准匹配Routing Key，只将消息转发到指定Routing Key的队列中。用于<a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html">Routing模式</a>。</li>
<li><strong>topic</strong>：这类交换机按照一定规则匹配Routing Key，将消息转发到匹配到的队列中，通常是一组相同主题的队列。用于<a href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html">Topics模式</a></li>
</ul>
<p><strong>临时队列</strong></p>
<p>创建一个随机名称的临时队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String queueName = channel.queueDeclare().getQueue();<br></code></pre></td></tr></table></figure>

<p><strong>绑定（bindings）</strong></p>
<p>binding是指exchange和queue之间的关系，将exchange和queue进行绑定。</p>
<p>其中一个交换机和一个队列之间可以有多个binding key</p>
<h2 id="5-2-Publish-Subscribe"><a href="#5-2-Publish-Subscribe" class="headerlink" title="5.2 Publish/Subscribe"></a>5.2 Publish/Subscribe</h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html">发布订阅模式</a>是使用的扇出（fanout）类型的交换机。</p>
<p>交换机会<strong>将消息推送至所有和他绑定的队列，不会匹配Routing Key</strong>。无论绑定的Routing Key是什么值，都会发送到所有和其绑定的队列中。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211019201626154.png" alt="Publish/Subscribe"></p>
<p><strong>实例</strong></p>
<p>如上图所示，一个交换机，两个队列。</p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmitLog</span> </span>&#123;    <span class="hljs-comment">//交换机名字为logs    public static final String EXCHANGE_NAME = &quot;logs&quot;;    public static void main(String[] args) throws IOException &#123;        Channel channel = RabbitMqUtils.getChannel();        //声明为fanout类型，可以用枚举类型或者字符串。        //channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;);        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);        Scanner scanner = new Scanner(System.in);        while(scanner.hasNext())&#123;            String message = scanner.next();            //绑定信息为空            channel.basicPublish(EXCHANGE_NAME,&quot;&quot;,null,message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产者发出消息：&quot;+message);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>消费者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReceiveLogs01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">/*声明临时队列        临时队列的队列名称是随机的        当消费者断开与队列的连接后，队列会被自动删除。         */</span>        String queueName = channel.queueDeclare().getQueue();        <span class="hljs-comment">/*        将队列和交换机绑定 binding，routingKey为空         */</span>        channel.queueBind(queueName,EXCHANGE_NAME,<span class="hljs-string">&quot;&quot;</span>);        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;消费者1控制台打印接收到的消息：&quot;</span>+<span class="hljs-keyword">new</span> String(message.getBody(),<span class="hljs-string">&quot;UTF-8&quot;</span>));        &#125;;        CancelCallback cancelCallback = consumerTag-&gt;&#123;&#125;;        channel.basicConsume(queueName,deliverCallback,cancelCallback);    &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>消费者2的代码和消费者1相同，会生成另一个随机名称的临时队列。</p>
<p>这样，当生产者每次发送一条消息，消费者1和消费者2都能接收到。</p>
<h2 id="5-3-Routing"><a href="#5-3-Routing" class="headerlink" title="5.3 Routing"></a>5.3 Routing</h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html">Routing模式</a>使用的是direct类型交换机，这种模式下，交换机需要精准匹配Routing Key，只将消息转发到指定Routing Key的队列中。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211019204129471.png" alt="Routing"></p>
<p>如图，交换机X绑定了Q1和Q2两个队列，其中和Q1之间的Binding Key为<code>orange</code>，和Q2的Binding Key包括<code>black</code>和<code>green</code>两个。</p>
<p>Routing Key为<code>orange</code>的消息会被推送到Q1队列。Routing Key为<code>black</code>和<code>green</code>的消息会被推送到Q2队列。</p>
<blockquote>
<p>多重绑定：允许不同队列和交换机之间的Binding Key是相同的，这种情况下效果和Publish/Subscribe模式相同。</p>
</blockquote>
<p><strong>实现</strong></p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectProducer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">&quot;X&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">//声明交换机,类型为direct        channel.exchangeDeclare(EXCHANGE_NAME,&quot;direct&quot;);                Scanner scanner = new Scanner(System.in);        while(scanner.hasNext())&#123;            String message = scanner.next();            //当Bingding Key取不同值时，会根据情况发送的相应的队列。            channel.basicPublish(EXCHANGE_NAME,&quot;orange&quot;,null,message.getBytes(&quot;UTF-8&quot;));//            channel.basicPublish(EXCHANGE_NAME,&quot;black&quot;,null,message.getBytes(&quot;UTF-8&quot;));//            channel.basicPublish(EXCHANGE_NAME,&quot;green&quot;,null,message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;Direct类型，生产者发出消息：&quot;+message);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<p>消费者1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectConsumer01</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">&quot;X&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;Q1&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BINGDING_NAME = <span class="hljs-string">&quot;orange&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">//声明交换机,类型为direct        channel.exchangeDeclare(EXCHANGE_NAME,&quot;direct&quot;);        //声明名为Q1的队列        channel.queueDeclare(QUEUE_NAME,false,false,false,null);        //将队列和交换机绑定        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,BINGDING_NAME);        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            System.out.println(&quot;C1接收到消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));        &#125;;        CancelCallback cancelCallback = consumerTag-&gt;&#123;&#125;;        channel.basicConsume(QUEUE_NAME,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>消费者2和消费者1类似，不同的是有两个Bingding：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多重绑定，一个channel和交换机有两个绑定,两个不同的routing keychannel.queueBind(&quot;Q2&quot;,&quot;X&quot;,&quot;black&quot;);channel.queueBind(&quot;Q2&quot;,&quot;X&quot;,&quot;green&quot;);</span><br></code></pre></td></tr></table></figure>

<p>这样，当发送消息的Routing Key为<code>orange</code>时，消息会被推送到Q1，Routing Key为<code>black</code>或<code>green</code>时，消息被推送到Q2。</p>
<h2 id="5-4-Topics"><a href="#5-4-Topics" class="headerlink" title="5.4 Topics"></a>5.4 Topics</h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html">Topics</a>模式使用的是Topic类型的交换机，队列可以匹配一定规则的多个Routing Key。</p>
<p>Topic模式的Routing Key必须符合一定的要求：<strong>必须是一个单词列表，以<code>.</code>号分开</strong>，单词可以是任意的，比如<code>stock.usd.nyse</code>, <code>nyse.vmw</code>, <code>quick.orange.rabbit</code>等。单词列表最多为255个字节。</p>
<p><code>*</code>号可以代替一个单词。</p>
<p><code>#</code>号可以代替0个或多个单词。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211019213420569.png" alt="Topics"></p>
<p>如上图所示，交换机X和Q1的Binding Key为<code>*.orange.*</code>，X和Q2的Binding Key为<code>*.*.rabbit</code>和<code>lazy.#</code>。</p>
<p>一些案例：</p>
<p>①<code>quick.orange.rabbit</code>：Q1、Q2接收到消息。</p>
<p>②<code>quick.orange.rabbit</code> ： Q1、Q2接收到消息。</p>
<p>③<code>lazy.orange.elephant</code>：Q1、Q2 接收到消息。</p>
<p>④<code>quick.orange.fox</code>：Q1 接收到消息。</p>
<p>⑤<code>lazy.brown.fox</code>：Q2 接收到消息。</p>
<p>⑥<code>lazy.pink.rabbit</code> ：Q2 接收一次消息，虽然两种绑定都匹配，但只接收一次。</p>
<p>⑦<code>quick.brown.fox</code> ：不匹配任何绑定，被丢弃。</p>
<p>⑧<code>quick.orange.male.rabbit</code> ：是四个单词，不匹配任何绑定，被丢弃。</p>
<p>⑨<code>lazy.orange.male.rabbit</code> ：是四个单词，Q2接收到消息。</p>
<p><strong>实现</strong></p>
<p>声明交换机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>队列Q1绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.queueBind(<span class="hljs-string">&quot;Q1&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;*.orange.*&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>队列Q2绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.queueBind(<span class="hljs-string">&quot;Q1&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;*.*.rabbit&quot;</span>);channel.queueBind(<span class="hljs-string">&quot;Q1&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;lazy.#&quot;</span>);<br></code></pre></td></tr></table></figure>





<h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><p>关于死信队列的官方文档：<a href="https://www.rabbitmq.com/dlx.html">死信队列</a></p>
<p>队列中的消息如果发生以下情况就会变成<strong>死信（Dead Letter）</strong>：</p>
<ul>
<li>消息被拒绝（<code>basic.reject</code>或<code>basic.nack</code>），并且<code>requeue</code>参数为<code>false</code></li>
<li>消息TTL超时，即消息过期。</li>
<li>队列长度超过最大限制。</li>
</ul>
<blockquote>
<p>队列过期不会导致消息变为死信。</p>
</blockquote>
<p>死信交换机（Dead Letter eXchanges，DLXs）是正常的交换机，它可以将Dead Letter转发给死信队列，进一步处理。</p>
<p>如图，正常情况下，消息通过<code>normal_exchange</code>推送到<code>normal_queue</code>，然后被<code>C1</code>消费；如果消息变为死信，<code>normal_queue</code>会将死信转发给死信交换机<code>DLX</code>，<code>DLX</code>将死信推送给死信队列<code>dead_letter_queue</code>，然后被<code>C2</code>消费。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211019222750171.png" alt="死信队列"></p>
<p><strong>实现</strong></p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span>  </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_EXCHANGE=<span class="hljs-string">&quot;normal_exchange&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_ROUTING_KEY=<span class="hljs-string">&quot;normal_routing_key&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(NORMAL_EXCHANGE,<span class="hljs-string">&quot;direct&quot;</span>);        <span class="hljs-comment">//设置过期时间为10s        //AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();        //模拟发10条消息        for (int i = 0; i &lt; 10; i++) &#123;            String message = String.valueOf(i);            //超过ttl变为死信            //channel.basicPublish(NORMAL_EXCHANGE,NORMAL_BINDING,properties,message.getBytes(&quot;UTF-8&quot;));             //超过最大长度变为死信            //channel.basicPublish(NORMAL_EXCHANGE,NORMAL_BINDING,null,message.getBytes(&quot;UTF-8&quot;));             channel.basicPublish(NORMAL_EXCHANGE,NORMAL_ROUTING_KEY,null,message.getBytes(&quot;UTF-8&quot;)); //消息被拒绝变为死信            System.out.println(&quot;生产者发出消息：&quot;+message);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<p>消费者C1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer01</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_EXCHANGE=<span class="hljs-string">&quot;normal_exchange&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_EXCHANGE=<span class="hljs-string">&quot;dead_exchange&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_QUEUE=<span class="hljs-string">&quot;normal_queue&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_QUEUE=<span class="hljs-string">&quot;dead_queue&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_ROUTING_KEY=<span class="hljs-string">&quot;normal_routing_key&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_ROUTING_KEY=<span class="hljs-string">&quot;dead_routing_key&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">//声明普通交换机和死信交换机，类型均为direct        channel.exchangeDeclare(NORMAL_EXCHANGE,&quot;direct&quot;);        channel.exchangeDeclare(DEAD_EXCHANGE,&quot;direct&quot;);        //声明正常队列。正常队列需要将死信消息转发到死信交换机，需要用到map参数        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();        //过期时间,比如为10s；也可以在生产者发送消息的时候设置过期时间        //arguments.put(&quot;x-message-ttl&quot;,10000);        //指定队列的最大长度，一旦消息个数超出这个长度，就会成为死信        //arguments.put(&quot;x-max-length&quot;,6);        //设置死信交换机，即死信消息将要转发到的交换机        arguments.put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE);        //设置死信routingkey,死信消息通过此路由键发送到死信队列。        arguments.put(&quot;x-dead-letter-routing-key&quot;,DEAD_ROUTING_KEY);        channel.queueDeclare(NORMAL_QUEUE,false,false,false,arguments);        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,NORMAL_ROUTING_KEY); //绑定        //声明死信队列        channel.queueDeclare(DEAD_QUEUE,false,false,false,null);        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,DEAD_ROUTING_KEY); //绑定        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            //模拟拒绝消息            String msg = new String(message.getBody(),&quot;UTF-8&quot;);            if(Integer.parseInt(msg)%2==0)&#123;                System.out.println(msg+&quot;被拒绝&quot;);                //拒绝消息                channel.basicReject(message.getEnvelope().getDeliveryTag(),false);            &#125;else&#123;                System.out.println(&quot;C1打印接收到的消息：&quot;+msg);                //手动应答消息                channel.basicAck(message.getEnvelope().getDeliveryTag(),false);            &#125;        &#125;;        CancelCallback cancelCallback = consumerTag-&gt;&#123;&#125;;        //模拟拒绝消息时，要关闭自动应答。        channel.basicConsume(NORMAL_QUEUE,false,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>疑问：为什么要在正常队列中设置<code>x-dead-letter-routing-key</code>? 不设置会导致死信队列收不到消息，但是下文中也设置了死信队列和DLX和Routing Key，二者如果不一致也会导致死信队列收不到死信消息。</p>
</blockquote>
<p>消费者C2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//C2只需要从死信队列中接收消息即可public class Consumer02 &#123;    public static final String DEAD_QUEUE=&quot;dead_queue&quot;;    public static void main(String[] args) throws IOException &#123;        Channel channel = RabbitMqUtils.getChannel();        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            System.out.println(&quot;C2打印接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));        &#125;;        CancelCallback cancelCallback = consumerTag-&gt;&#123;&#125;;        channel.basicConsume(DEAD_QUEUE,true,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1>]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像制作</title>
    <url>/2021/12/25/%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>OpenStack+CloudBreak+Ambari</p>
<ul>
<li>OpenStack：镜像制作相关操作</li>
<li>Ambari：自定义服务，提供UI界面</li>
<li>Cloudbreak：集群管理，给Ambari提供服务</li>
</ul>
<span id="more"></span>



<h1 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h1><p>OpenStack+CloudBreak+Ambari</p>
<ul>
<li>OpenStack：镜像制作相关操作</li>
<li>Ambari：自定义服务，提供UI界面</li>
<li>Cloudbreak：集群管理，给Ambari提供服务</li>
</ul>
<h1 id="账号汇总"><a href="#账号汇总" class="headerlink" title="账号汇总"></a>账号汇总</h1><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.OpenStack镜像制作公共节点：<br><span class="hljs-number">10.6</span>.<span class="hljs-number">8.67</span>         <br><br><span class="hljs-number">2</span>.OpenStack网站：<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">10.6</span>.<span class="hljs-number">8.67</span><span class="hljs-regexp">/dashboard/</span>auth<span class="hljs-regexp">/login/</span>          <br><br><span class="hljs-number">3</span>.cloudbreak网址：<br><span class="hljs-number">10.6</span>.<span class="hljs-number">6.102</span>      <br><br><br><span class="hljs-number">4</span>.catalog创建目录：<br><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>catalog<br><br><span class="hljs-number">5</span>.Ambari服务修改目录：<br><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/3.1/</span>services<br><br></code></pre></td></tr></table></figure>

<h1 id="镜像制作流程"><a href="#镜像制作流程" class="headerlink" title="镜像制作流程"></a>镜像制作流程</h1><h2 id="1-镜像创建，并上传到OpenStack"><a href="#1-镜像创建，并上传到OpenStack" class="headerlink" title="1.镜像创建，并上传到OpenStack"></a>1.镜像创建，并上传到OpenStack</h2><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.登录到<span class="hljs-number">10.6.8.67</span><br><span class="hljs-attribute">ssh</span> root@<span class="hljs-number">10.6.8.67</span><br><br><span class="hljs-attribute">2</span>.服务admin权限<br><span class="hljs-attribute">source</span> keystonerc-admin<br><br><span class="hljs-attribute">3</span>.查看镜像列表<br><span class="hljs-attribute">glance</span> image-list<br><br><span class="hljs-attribute">4</span>.下载镜像<br><span class="hljs-attribute">glance</span> image-download --file /tmp/cv-sugon-data-governance-<span class="hljs-number">20210604</span>.qcow<span class="hljs-number">2</span>   <span class="hljs-number">2</span>c<span class="hljs-number">44</span>d<span class="hljs-number">9</span>ef-<span class="hljs-number">9</span>da<span class="hljs-number">1</span>-<span class="hljs-number">410</span>c-<span class="hljs-number">8483</span>-<span class="hljs-number">0466</span>ca<span class="hljs-number">1</span>c<span class="hljs-number">055</span>c<br><br><span class="hljs-attribute">5</span>.压缩镜像<br><span class="hljs-attribute">virt</span>-sparsify --compress cv-sugon-hadoop-analysis-<span class="hljs-number">20210607</span>.qcow<span class="hljs-number">2</span> cv-sugon-hadoop-analysis-<span class="hljs-number">20210607</span>-alpha.qcow<span class="hljs-number">2</span><br><br><span class="hljs-attribute">6</span>.上传镜像<br><span class="hljs-attribute">openstack</span> image create <span class="hljs-string">&quot;cv-xdata-31-20210604-sugon-alpha-test&quot;</span>   --file cb-xdata-<span class="hljs-number">31</span>-<span class="hljs-number">20210428</span>-sugon-alpha.qcow<span class="hljs-number">2</span> --disk-format qcow<span class="hljs-number">2</span> --container-format bare --property hypervisor_type=kvm --public<br><br><span class="hljs-attribute">7</span>.查看镜像信息<br><span class="hljs-attribute">qemu</span>-img info ***.qcow<span class="hljs-number">2</span><br><br><span class="hljs-attribute">8</span>.删除镜像<br><span class="hljs-attribute">openstack</span> image delete &#123;id&#125;<br><br><span class="hljs-attribute">9</span>.转换格式：<br><span class="hljs-attribute">qemu</span>-img convert -f qcow<span class="hljs-number">2</span> -O raw aa.qcow<span class="hljs-number">2</span> aa.raw -p<br></code></pre></td></tr></table></figure>

<p>删除文件时，要注意删除的文件是不是还有用</p>
<p>尽量用 rm</p>
<h2 id="2-登录UI界面，根据镜像创建实例"><a href="#2-登录UI界面，根据镜像创建实例" class="headerlink" title="2.登录UI界面，根据镜像创建实例"></a>2.登录UI界面，根据镜像创建实例</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.登录OpenStack网站：<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">10.6</span>.<span class="hljs-number">8.67</span><span class="hljs-regexp">/dashboard/</span>auth<span class="hljs-regexp">/login/</span>        <br><br><span class="hljs-number">2</span>.创建实例 <br>新卷（否）   ----wan     ----注意根目录与内存的大小<br><br><span class="hljs-number">3</span>.创建实例结束之后，会有一个IP地址<br></code></pre></td></tr></table></figure>

<h2 id="3-虚拟机配置文件修改"><a href="#3-虚拟机配置文件修改" class="headerlink" title="3.虚拟机配置文件修改"></a>3.虚拟机配置文件修改</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.<br><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>catalog<br>对其进行修改 镜像名，ID<br><br><span class="hljs-number">2</span>.可以登录cloudbreak上进行查看，image catalog。<br>例如：http:<span class="hljs-regexp">//</span><span class="hljs-number">10.6</span>.<span class="hljs-number">6.5</span>:<span class="hljs-number">9999</span><span class="hljs-regexp">/catalog/</span>cv-sugon-redis.json<br></code></pre></td></tr></table></figure>



<h2 id="4-Ambari自定义服务"><a href="#4-Ambari自定义服务" class="headerlink" title="4.Ambari自定义服务"></a>4.Ambari自定义服务</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.通过IP地址登录虚拟机<br>ssh root@ip<br><br><span class="hljs-number">2</span>.查看主机名<br>cat <span class="hljs-regexp">/etc/</span>hostname<br>修改主机名<br>hostname localhost.localdomain<br><br><span class="hljs-number">3</span>.修改自定义服务脚本<br>替换<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ambari-server/</span>resources<span class="hljs-regexp">/stacks/</span>HDP<span class="hljs-regexp">/3.1/</span>services中的脚本。<br><br></code></pre></td></tr></table></figure>



<h2 id="5-查看镜像、挂载"><a href="#5-查看镜像、挂载" class="headerlink" title="5.查看镜像、挂载"></a>5.查看镜像、挂载</h2><p>直接在当前虚拟机上对镜像进行修改，不需要创建实例再修改。</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">1</span>.查看镜像分区表信息<br><span class="hljs-string">virt-df</span> <span class="hljs-string">your</span>.<span class="hljs-string">qcow2</span><br><span class="hljs-string">qemu-img</span> <span class="hljs-string">info</span> <span class="hljs-string">your</span>.<span class="hljs-string">qcow2</span><br><br><span class="hljs-string">2</span>.挂载镜像，修改镜像中的文件<br><span class="hljs-string">guestfish</span> -<span class="hljs-string">a</span> <span class="hljs-string">your</span>.<span class="hljs-string">qcow2</span><br>&gt;&lt;<span class="hljs-string">fs</span>&gt; <span class="hljs-string">launch</span>                            //启动<br>&gt;&lt;<span class="hljs-string">fs</span>&gt; <span class="hljs-built_in">list-partitions</span>                   //查看分区列表<br>/<span class="hljs-string">dev</span>/<span class="hljs-string">sda1</span><br>&gt;&lt;<span class="hljs-string">fs</span>&gt; <span class="hljs-built_in">list-filesystems</span><br>/<span class="hljs-string">dev</span>/<span class="hljs-string">sda1</span>: <span class="hljs-string">xfs</span><br>&gt;&lt;<span class="hljs-string">fs</span>&gt;<span class="hljs-string">mount</span>  /<span class="hljs-string">dev</span>/<span class="hljs-string">sda1</span>  /               //修改当前目录成根目录<br>&gt; <span class="hljs-string">exit</span><br></code></pre></td></tr></table></figure>

<h2 id="6-修改镜像格式"><a href="#6-修改镜像格式" class="headerlink" title="6.修改镜像格式"></a>6.修改镜像格式</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>.转换格式：<br>qemu-<span class="hljs-selector-tag">img</span> convert -f qcow2 -O raw aa<span class="hljs-selector-class">.qcow2</span> aa<span class="hljs-selector-class">.raw</span> -<span class="hljs-selector-tag">p</span><br><br><span class="hljs-number">2</span>.查看镜像信息<br>qemu-<span class="hljs-selector-tag">img</span> info t<span class="hljs-selector-class">.raw</span><br><br><span class="hljs-number">3</span>.上传raw格式镜像：<br>openstack image create <span class="hljs-string">&quot;cv-sugon-data-governance-20210831-alpha&quot;</span> --file cv-sugon-data-governance-<span class="hljs-number">20210831</span>-alpha<span class="hljs-selector-class">.raw</span> --disk-format raw --container-format bare --property hypervisor_type=kvm --public<br></code></pre></td></tr></table></figure>

<h2 id="7-Cloudbreak创建集群"><a href="#7-Cloudbreak创建集群" class="headerlink" title="7.Cloudbreak创建集群"></a>7.Cloudbreak创建集群</h2>]]></content>
      <categories>
        <category>镜像制作</category>
      </categories>
      <tags>
        <tag>镜像制作</tag>
      </tags>
  </entry>
  <entry>
    <title>项目总结</title>
    <url>/2021/10/04/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结项目经验，介绍项目的亮点</p>
<span id="more"></span>

<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><h3 id="1-MyBatis"><a href="#1-MyBatis" class="headerlink" title="1.MyBatis"></a>1.MyBatis</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="2-mysql"><a href="#2-mysql" class="headerlink" title="2.mysql"></a>2.mysql</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="3-thymeleaf：前后端交互"><a href="#3-thymeleaf：前后端交互" class="headerlink" title="3.thymeleaf：前后端交互"></a>3.thymeleaf：前后端交互</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="4-邮件"><a href="#4-邮件" class="headerlink" title="4.邮件"></a>4.邮件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="5-redis"><a href="#5-redis" class="headerlink" title="5.redis"></a>5.redis</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="6-commons-lang3：字符串相关操作"><a href="#6-commons-lang3：字符串相关操作" class="headerlink" title="6.commons-lang3：字符串相关操作"></a>6.commons-lang3：字符串相关操作</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="7-kapcha"><a href="#7-kapcha" class="headerlink" title="7.kapcha"></a>7.kapcha</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">生成随机的验证码<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.penggle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kaptcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="8-json"><a href="#8-json" class="headerlink" title="8.json"></a>8.json</h3><p>json前后端交互</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.78<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="9-面向切面编程"><a href="#9-面向切面编程" class="headerlink" title="9.面向切面编程"></a>9.面向切面编程</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="10-swagger"><a href="#10-swagger" class="headerlink" title="10.swagger"></a>10.swagger</h3><p>接口管理文档</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>在项目中使用MD5对密码进行加密。</p>
<p>md5加密算法是对称加密算法，即相同的字符串加密之后的结果是相同的。因此，为了保证加密结果的安全性，我们使用 “md5（密码+长度为5的随机字符串）”的形式进行加密。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>生成随机字符串与MD5加密</strong>的代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommunityUtil</span> </span>&#123;<br>    <span class="hljs-comment">//生成随机字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">generateUUID</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//s随机生成的字符串是由字母和‘-’生成的，我们不想要‘-’，使用空字符串进行替换</span><br>        <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//MD5加密</span><br>    <span class="hljs-comment">//只能加密，但是不能解密</span><br>    <span class="hljs-comment">//MD5对称加密是，加密之后的结果是一样的，我们通过使用在 原字符串后+随机字符串 的方式进行加密。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(key))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//加密成16位的字符串。输入要求是byte。</span><br>        <span class="hljs-keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes(StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>字符串拼接成功后，进行md5加密：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CommunityUtil.generateUUID().substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);   <span class="hljs-comment">//设置一个长度为5的随机字符串</span><br>CommunityUtil.md5(user.getPassword()+user.getSalt());   <span class="hljs-comment">//加密</span><br></code></pre></td></tr></table></figure>

<h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><h3 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>用户点击注册之后，用户的账号处于一个未激活的状态。此时会给用户发送一封邮件，邮件中包含了一个激活链接，只有用户点击激活链接，用户账号正式激活。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>注入实现发送邮件的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h4 id="1-service层"><a href="#1-service层" class="headerlink" title="1.service层"></a>1.service层</h4><p>配置发送邮件的信息：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># MailProperties 发送邮件控制</span><br><span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.sina.com</span><br><span class="hljs-meta">spring.mail.port</span>=<span class="hljs-string">465</span><br><span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">wenk207@sina.com</span><br><span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">1de57d8716fc8e2e</span><br><span class="hljs-meta">spring.mail.protocol</span>=<span class="hljs-string">smtps</span><br><span class="hljs-meta">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>

<p>自动注入要实现的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MailClient mailClient;       <span class="hljs-comment">//邮箱客户端</span><br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> TemplateEngine templateEngine;      <span class="hljs-comment">//模板引擎</span><br><br><span class="hljs-comment">//    @Autowired</span><br><span class="hljs-comment">//    private LoginTicketDao loginTicketDao;     //登陆凭证</span><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;springboot_newCoder.path.domain&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String domain;           <span class="hljs-comment">//项目地址 http://localhost:8080</span><br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String contextPath;          <span class="hljs-comment">//默认路径/community</span><br></code></pre></td></tr></table></figure>

<p>激活邮件，context是thymeleaf中的一个类，类似于容器的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//激活邮件</span><br>Context context = <span class="hljs-keyword">new</span> Context();<br>context.setVariable(<span class="hljs-string">&quot;email&quot;</span>,user.getEmail());<br><span class="hljs-comment">//拼接激活地址：http://localhost:8080/community/activation/101/code</span><br>String url = domain + contextPath + <span class="hljs-string">&quot;/activation/&quot;</span> +<br>        user.getId() + <span class="hljs-string">&quot;/&quot;</span> + user.getActivationCode();<br>context.setVariable(<span class="hljs-string">&quot;url&quot;</span>,url);<br>String content = templateEngine.process(<span class="hljs-string">&quot;/mail/activation&quot;</span>,context);<br>mailClient.sendMail(user.getEmail(),<span class="hljs-string">&quot;激活邮件&quot;</span>,content);<br></code></pre></td></tr></table></figure>

<p>通过邮箱中的激活链接进行激活</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过邮箱里面的激活链接点击激活</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">activation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId,String code)</span></span>&#123;<br>    User user = userDao.selectById(userId);<br>    <span class="hljs-keyword">if</span> (user.getStatus() == <span class="hljs-number">1</span>)&#123;     <span class="hljs-comment">//status初始化为0，等于1说明已经激活</span><br>        <span class="hljs-keyword">return</span> ACTIVATION_REPEAT;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user.getActivationCode().equals(code))&#123;     <span class="hljs-comment">//激活</span><br>        userDao.updateStatus(userId,<span class="hljs-number">1</span>);      <span class="hljs-comment">//更新用户的状态。</span><br>        clearCache(userId);<br>        <span class="hljs-keyword">return</span> ACTIVATION_SUCCESS;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> ACTIVATION_FAILURE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-controller层"><a href="#2-controller层" class="headerlink" title="2.controller层"></a>2.controller层</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 访问注册页面</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/register&quot;,method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">register</span><span class="hljs-params">(Model model, User user)</span></span>&#123;<br>    <span class="hljs-comment">//调用注册功能，返回的map中存放错误信息。</span><br>    Map&lt;String, Object&gt; map = userService.register(user);<br>    <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map.isEmpty())&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;注册成功，我们已经向您发送了一封激活邮件，请尽快激活！&quot;</span>);<br>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;/site/operate-result&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;usernameMsg&quot;</span>,map.get(<span class="hljs-string">&quot;usernameMsg&quot;</span>));<br>        model.addAttribute(<span class="hljs-string">&quot;emailMsg&quot;</span>,map.get(<span class="hljs-string">&quot;emailMsg&quot;</span>));<br>        model.addAttribute(<span class="hljs-string">&quot;passwordMsg&quot;</span>,map.get(<span class="hljs-string">&quot;passwordMsg&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/site/register&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 访问激活地址：http://localhost:8080/community/activation/101/code</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(path = &quot;activation/&#123;userId&#125;/&#123;code&#125;&quot;,method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">activation</span><span class="hljs-params">(Model model, <span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> <span class="hljs-keyword">int</span> userId,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-meta">@PathVariable(&quot;code&quot;)</span> String code)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> result = userService.activation(userId,code);<br>    <span class="hljs-keyword">if</span> (result == ACTIVATION_SUCCESS)&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;激活成功，您的账号已经可以正常使用了！&quot;</span>);<br>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/login&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result == ACTIVATION_REPEAT)&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;无效操作，该账号已经激活过了!&quot;</span>);<br>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;激活失败，提供的激活码不正确！&quot;</span>);<br>        model.addAttribute(<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;/index&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;/site/operate-result&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
</search>

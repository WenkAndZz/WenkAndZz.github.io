<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API接口文档管理工具：Swagger</title>
    <url>/2021/11/15/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9ASwagger/</url>
    <content><![CDATA[<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</p>
<span id="more"></span>

<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>分组开发工具，可以设置不同的组（Docket.groupname），每个组负责开发不同的功能模块。</p>
<p>前端可视化后端API接口（实时更新），可以对controller进行测试。</p>
<ul>
<li>号称世界上最流行的API框架；</li>
<li>RestFul API文档在线自动生成工具=》API文档域API自动更新。</li>
<li>直接运行，可以在线测试API接口。</li>
<li>支持多种语言。</li>
</ul>
<h2 id="一、在项目中使用Swagger"><a href="#一、在项目中使用Swagger" class="headerlink" title="一、在项目中使用Swagger"></a>一、在项目中使用Swagger</h2><p>需要springbox；</p>
<ul>
<li>swagger2</li>
<li>ui</li>
</ul>
<h2 id="二、在SpringBoot中集成swagger"><a href="#二、在SpringBoot中集成swagger" class="headerlink" title="二、在SpringBoot中集成swagger"></a>二、在SpringBoot中集成swagger</h2><h3 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h3><h3 id="2-导入依赖"><a href="#2-导入依赖" class="headerlink" title="2.导入依赖"></a>2.导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure>



<h3 id="3-编写hello工程。"><a href="#3-编写hello工程。" class="headerlink" title="3.编写hello工程。"></a>3.编写hello工程。</h3><h3 id="4-集成swagger-》config"><a href="#4-集成swagger-》config" class="headerlink" title="4.集成swagger==》config"></a>4.集成swagger==》config</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span>         <span class="hljs-comment">//开启swagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="5-访问网址："><a href="#5-访问网址：" class="headerlink" title="5.访问网址："></a>5.访问网址：</h3><p><a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018110821946.png" alt="image-20211018110821946"></p>
<h2 id="三、配置swagger"><a href="#三、配置swagger" class="headerlink" title="三、配置swagger"></a>三、配置swagger</h2><h3 id="swagger的bean实例Docket："><a href="#swagger的bean实例Docket：" class="headerlink" title="swagger的bean实例Docket："></a>swagger的bean实例Docket：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span>         <span class="hljs-comment">//开启swagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br>    <span class="hljs-comment">//配置swagger的Docket bean实例。</span><br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());<br>    &#125;<br>    <span class="hljs-comment">//配置swagger信息=apiInfo</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;<br>        Contact contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;李文凯&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;li17669498364@163.com&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(<span class="hljs-string">&quot;李文凯的swaggerAPI文档&quot;</span>,<br>                <span class="hljs-string">&quot;加油，冲刺&quot;</span>,<br>                <span class="hljs-string">&quot;1.0&quot;</span>,<br>                <span class="hljs-string">&quot;urn:tos&quot;</span>,<br>                contact,<br>                <span class="hljs-string">&quot;Apache 2.0&quot;</span>,<br>                <span class="hljs-string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,<br>                <span class="hljs-keyword">new</span> ArrayList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018112506760.png" alt="image-20211018112506760"></p>
<h3 id="Swagger配置扫描接口"><a href="#Swagger配置扫描接口" class="headerlink" title="Swagger配置扫描接口"></a>Swagger配置扫描接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).<br>            apiInfo(apiInfo())<br>            .select()<br>            <span class="hljs-comment">//配置要扫描接口的方式</span><br>            <span class="hljs-comment">//basePackage：指定要扫描的包。</span><br>            <span class="hljs-comment">//any()：扫描全部</span><br>            <span class="hljs-comment">//none（）：不扫描</span><br>            <span class="hljs-comment">//withClassAnnotation：扫描雷伤的注解，参数是一个注解的反射对象。</span><br>            <span class="hljs-comment">//withMethodAnnotation：扫描方法上的注解</span><br>            .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.kai.controller&quot;</span>))<br>            <span class="hljs-comment">//paths（）。过滤什么路径</span><br>            .paths(PathSelectors.ant(<span class="hljs-string">&quot;/kai/**&quot;</span>))<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018151937769.png" alt="image-20211018151937769"></p>
<h3 id="配置自动启动config"><a href="#配置自动启动config" class="headerlink" title="配置自动启动config"></a>配置自动启动config</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).<br>                apiInfo(apiInfo())<br>                <span class="hljs-comment">//swagger是否启动，如果为false，则swagger不能再浏览器中访问。</span><br>                .enable(<span class="hljs-keyword">false</span>)<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018152317499.png" alt="image-20211018152317499"></p>
<h3 id="需求：在生产环境有使用swagger自动启动，在运行环境中不使用。"><a href="#需求：在生产环境有使用swagger自动启动，在运行环境中不使用。" class="headerlink" title="需求：在生产环境有使用swagger自动启动，在运行环境中不使用。"></a>需求：在生产环境有使用swagger自动启动，在运行环境中不使用。</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span>         <span class="hljs-comment">//开启swagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br>    <span class="hljs-comment">//配置swagger的Docket bean实例。</span><br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">(Environment environment)</span></span>&#123;<br><br>        <span class="hljs-comment">//设置要显示的swagger环境。</span><br>        Profiles profiles = Profiles.of(<span class="hljs-string">&quot;dev&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-comment">//通过environment.acceptsProfiles判断是否处在自己设定的环境中。</span><br>        <span class="hljs-keyword">boolean</span> flag = environment.acceptsProfiles(profiles);<br>        System.out.println(flag);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).<br>                apiInfo(apiInfo())<br>                <span class="hljs-comment">//swagger是否启动，如果为false，则swagger不能再浏览器中访问。</span><br>                .enable(flag)<br>                .select()<br>                <span class="hljs-comment">//配置要扫描接口的方式</span><br>                <span class="hljs-comment">//basePackage：指定要扫描的包。</span><br>                <span class="hljs-comment">//any()：扫描全部</span><br>                <span class="hljs-comment">//none（）：不扫描</span><br>                <span class="hljs-comment">//withClassAnnotation：扫描雷伤的注解，参数是一个注解的反射对象。</span><br>                <span class="hljs-comment">//withMethodAnnotation：扫描方法上的注解</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.kai.controller&quot;</span>))<br>                <span class="hljs-comment">//paths（）。过滤什么路径</span><br><span class="hljs-comment">//                .paths(PathSelectors.ant(&quot;/kai/**&quot;))</span><br>                .build();<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="配置API文档分组"><a href="#配置API文档分组" class="headerlink" title="配置API文档分组"></a>配置API文档分组</h3><p>配置一个组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).<br>        apiInfo(apiInfo())<br>        .groupName(<span class="hljs-string">&quot;Liwenkai&quot;</span>)<br></code></pre></td></tr></table></figure>



<p>配置多个组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多个docket分组</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;A&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;B&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket3</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;C&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实体类配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiModel(&quot;用户实体类&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@ApiModelProperty(&quot;姓名&quot;)</span>    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@ApiModelProperty(&quot;年龄&quot;)</span>    <span class="hljs-keyword">public</span> Integer age;&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@ApiOperation(&quot;用户控制类&quot;)</span>     <span class="hljs-comment">//API 接口注释，放在方法上    @RequestMapping(path = &quot;/hello&quot;,method = RequestMethod.GET)    public String hello()&#123;        return &quot;hello&quot;;    &#125;    //只要调用的controller中存在user对象，他就会被扫描扫swagger中。    @PostMapping(&quot;/user&quot;)    public User user()&#123;        return new User();    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018161610774.png" alt="image-20211018161610774"></p>
<h2 id="四、swagger的作用"><a href="#四、swagger的作用" class="headerlink" title="四、swagger的作用"></a>四、swagger的作用</h2><p>模拟前端往后端传递数据的过程。可以从前端中测试后端中的API。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018170441331.png" alt="image-20211018170441331"></p>
<p>当出现错误时，可以在这个swagger UI界面中显示出来。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018170629978.png" alt="image-20211018170629978"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>通过swagger给一些比较难理解的属性和接口，增加注释信息。</li>
<li>接口文档可以实时更新。</li>
<li>可以在线测试。</li>
</ol>
<p>==<strong>注意点，在正式发布时，需要关闭swagger，处于安全考虑，并且节省内存。</strong>==</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据库连接：JDBC</title>
    <url>/2021/11/15/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%EF%BC%9AJDBC/</url>
    <content><![CDATA[<p>Java数据库连接，（Java Database Connectivity，简称JDBC）是<a href="https://baike.baidu.com/item/Java%E8%AF%AD%E8%A8%80">Java语言</a>中用来规范客户端程序如何来访问数据库的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/10418844">应用程序接口</a>，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的。</p>
<span id="more"></span>

<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210602153446084.png" alt="image-20210602153446084"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210602153529380.png" alt="image-20210602153529380"></p>
<h1 id="1-JDBC入门"><a href="#1-JDBC入门" class="headerlink" title="1.JDBC入门"></a>1.JDBC入门</h1><p>什么是JDBC:</p>
<ul>
<li>java数据库连接，</li>
<li>让java通过程序连接关系型数据库，</li>
<li>JDBC基于驱动程序实现与数据库的连接和操作</li>
</ul>
<p>JDBC驱动程序</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210602155933307.png" alt="image-20210602155933307"></p>
<p>JDBC提出了一个标准，相应的数据库程序提供实现。</p>
<p>优点：</p>
<ul>
<li>统一的API，提供一致的开发过程。</li>
<li>易于上手，容易上手，代码结构稳定</li>
<li>功能强大，执行效率高，可以处理海量数据。</li>
</ul>
<h1 id="2-JDBC开发流程"><a href="#2-JDBC开发流程" class="headerlink" title="2.JDBC开发流程"></a>2.JDBC开发流程</h1><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210602160414913.png" alt="image-20210602160414913"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210602173544564.png" alt="image-20210602173544564"></p>
<h1 id="3-JDBC代码实现"><a href="#3-JDBC代码实现" class="headerlink" title="3.JDBC代码实现"></a>3.JDBC代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        Statement stmt = <span class="hljs-keyword">null</span>;<br>        ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.加载注册驱动</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>            <span class="hljs-comment">// 2.创建数据库连接</span><br>            String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:3307/db_cy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimerzone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;</span>;<br>            conn = DriverManager.getConnection(url,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-comment">// 3.创建Statement对象</span><br>            stmt = conn.createStatement();<br>            <span class="hljs-comment">// 结果集</span><br>            rs = stmt.executeQuery(<span class="hljs-string">&quot;select * from counterdetail&quot;</span>);<br>            <span class="hljs-comment">// 4.遍历查询结果</span><br>            <span class="hljs-keyword">while</span> (rs.next())&#123;<br>                Integer id = rs.getInt(<span class="hljs-number">1</span>);         <span class="hljs-comment">// JDBC中字段的索引是从1开始的，不是0</span><br>                Integer ccounterid = rs.getInt(<span class="hljs-number">2</span>);<br>                String cfoodname = rs.getString(<span class="hljs-number">3</span>);<br>                String cnumber = rs.getString(<span class="hljs-number">4</span>);<br>                Integer cprive = rs.getInt(<span class="hljs-number">5</span>);<br>                System.out.println(id+<span class="hljs-string">&quot;-&quot;</span>+ccounterid+<span class="hljs-string">&quot;-&quot;</span>+cfoodname+<span class="hljs-string">&quot;-&quot;</span>+cnumber+<span class="hljs-string">&quot;-&quot;</span>+cprive);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 5.关闭连接，释放资源</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (rs!=<span class="hljs-keyword">null</span>)&#123;<br>                    rs.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (conn!=<span class="hljs-keyword">null</span>)&#123;<br>                    conn.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(stmt!=<span class="hljs-keyword">null</span>&amp;&amp;!conn.isClosed())&#123;<br>                    stmt.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br><br><br>        &#125;<br></code></pre></td></tr></table></figure>

<h1 id="4-JDBC的两种事务模型"><a href="#4-JDBC的两种事务模型" class="headerlink" title="4.JDBC的两种事务模型"></a>4.JDBC的两种事务模型</h1><ul>
<li><p>自动提交事务模式：默认模式，没执行一次写操作SQL，自动提交事务。</p>
<p>conn.setAutoCommit(true)。无法保证数据一致性。</p>
</li>
</ul>
<ul>
<li>手动提交事务模式：</li>
</ul>
<p>显示调用commit()he rollback()</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210607210239674.png" alt="image-20210607210239674"></p>
<h1 id="5-Date日期对象处理"><a href="#5-Date日期对象处理" class="headerlink" title="5.Date日期对象处理"></a>5.Date日期对象处理</h1><p>JDBC 中获取到的日期使用java.sql.Date，其继承自java.util.Date。所以二者可以兼容</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210608105317030.png" alt="image-20210608105317030"></p>
<h1 id="6-连接池和JDBC"><a href="#6-连接池和JDBC" class="headerlink" title="6.连接池和JDBC"></a>6.连接池和JDBC</h1><p>什么是连接池？</p>
<p>数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标.数据库连接池正式针对这个问题提出来的.数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个</p>
<p><img src="https://img-blog.csdnimg.cn/20190214093729228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTI4MzEx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>连接池产品：</p>
<p>阿里巴巴Druid连接池</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210608111547280.png" alt="image-20210608111547280"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">driverClassName = com.mysql.cj.jdbc.Driver<br>url = jdbc:mysql:<span class="hljs-comment">//localhost:3307/db_cy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT&amp;allowPublicKeyRetrieval=true</span><br>username = root<br>password = <span class="hljs-number">123456</span><br>initialSize = <span class="hljs-number">20</span><br>maxActive = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>

<p>把initialSize和maxActive设置为相等，目的就是一开始就给系统分配好资源，避免出现重新分配资源的情况。</p>
<p>c3p0连接池：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210608151633616.png" alt="image-20210608151633616"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>key-value型数据库：Redis</title>
    <url>/2021/11/15/key-value%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9ARedis/</url>
    <content><![CDATA[<p>Redis数据库是Key-Value型NoSQL数据库。Redis将数据存储在内存中，同时也能持久化到磁盘。Redis常用于缓存，利用内存的高效提高程序的处理速度。</p>
<span id="more"></span>

<h1 id="一、Redis介绍"><a href="#一、Redis介绍" class="headerlink" title="一、Redis介绍"></a>一、Redis介绍</h1><ul>
<li>Redis数据库是Key-Value型NoSQL数据库。</li>
<li>Redis将数据存储在内存中，同时也能持久化到磁盘。</li>
<li>Redis常用于缓存，利用内存的高效提高程序的处理速度。</li>
</ul>
<h1 id="二、Redis的特点"><a href="#二、Redis的特点" class="headerlink" title="二、Redis的特点"></a>二、Redis的特点</h1><ol>
<li>速度快。</li>
<li>广泛的语言支持。</li>
<li>持久化。</li>
<li>支持多种数据结构（数据类型）。</li>
<li>主从复制</li>
<li>分布式与高可用。</li>
</ol>
<h1 id="三、Redis通用命令"><a href="#三、Redis通用命令" class="headerlink" title="三、Redis通用命令"></a>三、Redis通用命令</h1><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210621185657687.png" alt="image-20210621185657687"></p>
<h1 id="四、Redis数据类型"><a href="#四、Redis数据类型" class="headerlink" title="四、Redis数据类型"></a>四、Redis数据类型</h1><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210621191245980.png" alt="image-20210621191245980"></p>
<h2 id="4-1字符串数据类型"><a href="#4-1字符串数据类型" class="headerlink" title="4.1字符串数据类型"></a>4.1字符串数据类型</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210621191223070.png" alt="image-20210621191223070"></p>
<h2 id="4-2-hash键值类型"><a href="#4-2-hash键值类型" class="headerlink" title="4.2 hash键值类型"></a>4.2 hash键值类型</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210621194713316.png" alt="image-20210621194713316"></p>
<h2 id="4-3-list列表类型"><a href="#4-3-list列表类型" class="headerlink" title="4.3 list列表类型"></a>4.3 list列表类型</h2><p>List列表就是一系列字符串的“数组”，按照插入顺序排序。</p>
<p>List列表最大长度是2的32次方-1，可以包含大约40亿个元素。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210621195522943.png" alt="image-20210621195522943"></p>
<h2 id="4-4-Set与Zset集合类型"><a href="#4-4-Set与Zset集合类型" class="headerlink" title="4.4 Set与Zset集合类型"></a>4.4 Set与Zset集合类型</h2><p>Set集合是字符串的无序集合，集合成员是唯一的。</p>
<p>Zset集合是字符串的有序集合，集合成员是唯一的。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>代码托管工具：Git</title>
    <url>/2021/11/15/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B7%A5%E5%85%B7%EF%BC%9AGit/</url>
    <content><![CDATA[<p><em>Git</em>（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。在团队协作开发中起到了十分重要的作用。</p>
<span id="more"></span>

<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111133705830.png" alt="image-20211111133705830"></p>
<h2 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1. 版本控制"></a>1. 版本控制</h2><h3 id="1-1-版本控制工具应该具备的功能"><a href="#1-1-版本控制工具应该具备的功能" class="headerlink" title="1.1 版本控制工具应该具备的功能"></a>1.1 版本控制工具应该具备的功能</h3><ul>
<li>协同修改：多个人并行的修改服务器的同一个文件。</li>
<li>数据备份：不仅保存目录和文件的当前状态，还能够保存每一个提交的历史状态。</li>
<li>版本控制：每次只保存修改的数据，不保存重复数据。Git采用文件系统快照的方式进行保存。</li>
<li>权限控制：对团队中的不同人员拥有不同的权限；对团队之外的开发者提供的代码进行审核。</li>
<li>历史记录。</li>
<li>分支管理：允许开发团队在工作工程中多分支同时进行工作。</li>
</ul>
<h3 id="1-2-版本控制介绍"><a href="#1-2-版本控制介绍" class="headerlink" title="1.2 版本控制介绍"></a>1.2 版本控制介绍</h3><p>版本控制工具：</p>
<ul>
<li>集中式版本控制工具：SVN。存在单点故障的问题。</li>
<li>分布式版本控制工具：Git。<strong>可以避免单点故障。</strong></li>
</ul>
<h2 id="2-Git简介"><a href="#2-Git简介" class="headerlink" title="2 .Git简介"></a>2 .Git简介</h2><h3 id="2-1-Git的优势"><a href="#2-1-Git的优势" class="headerlink" title="2.1 Git的优势"></a>2.1 Git的优势</h3><ul>
<li>大部分操作都在本地运行，不需要联网。</li>
<li>保证完整性（通过Hash值）。</li>
<li>尽可能的添加数据，而不是删除或修改数据。</li>
<li>分支操作非常快捷流畅（内部通过快照操作）。</li>
<li>与Linux命令全面兼容。</li>
</ul>
<h3 id="2-2-Git的结构"><a href="#2-2-Git的结构" class="headerlink" title="2.2 Git的结构"></a>2.2 Git的结构</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111140409757.png" alt="image-20211111140409757"></p>
<h3 id="2-3-Git和代码托管中心"><a href="#2-3-Git和代码托管中心" class="headerlink" title="2.3 Git和代码托管中心"></a>2.3 Git和代码托管中心</h3><p>远程托管代码，将代码保存到远程库中。</p>
<p>局域网：GitLab</p>
<p>外网环境：GitHub，码云</p>
<h3 id="2-4-本地库和远程库"><a href="#2-4-本地库和远程库" class="headerlink" title="2.4 本地库和远程库"></a>2.4 本地库和远程库</h3><p>团队内协作：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111141146749.png" alt="image-20211111141146749"></p>
<p>团队外协作：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111141435649.png" alt="image-20211111141435649"></p>
<h3 id="2-5-Git的基本操作"><a href="#2-5-Git的基本操作" class="headerlink" title="2.5 Git的基本操作"></a>2.5 Git的基本操作</h3><h4 id="2-5-1-本地库初始化："><a href="#2-5-1-本地库初始化：" class="headerlink" title="2.5.1.本地库初始化："></a>2.5.1.本地库初始化：</h4><ul>
<li>命令：git init</li>
<li>效果：</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111142745692.png" alt="image-20211111142745692"></p>
<ul>
<li>注意：.git/文件中存放的是本地库相关的子目录和文件，不要删除和修改。</li>
</ul>
<h4 id="2-5-2-设置签名"><a href="#2-5-2-设置签名" class="headerlink" title="2.5.2.设置签名"></a>2.5.2.设置签名</h4><ul>
<li><p>形式：</p>
<p>用户名：liwenkai</p>
<p>email地址：<a href="mailto:&#108;&#105;&#49;&#x37;&#54;&#54;&#x39;&#x34;&#x39;&#56;&#x33;&#54;&#x34;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;">&#108;&#105;&#49;&#x37;&#54;&#54;&#x39;&#x34;&#x39;&#56;&#x33;&#54;&#x34;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></p>
</li>
<li><p>作用：区分不同的开发人员的身份。</p>
</li>
</ul>
<p>辨析：这里设置的签名和代码托管中心的账号密码没有任何关系。 </p>
<ul>
<li><p>命令（优先级：就近原则，二者都有，采用项目级别）：</p>
<ul>
<li>项目级别：仅在当前本地库范围内有效。<ul>
<li> git config user.name liwenkai       </li>
<li>git config user.email   <a href="mailto:&#x6c;&#105;&#49;&#55;&#x36;&#54;&#57;&#x34;&#57;&#56;&#51;&#54;&#52;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#x6c;&#105;&#49;&#55;&#x36;&#54;&#57;&#x34;&#57;&#56;&#51;&#54;&#52;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a></li>
<li>项目保存的位置：./.git/config</li>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111150801163.png" alt="image-20211111150801163"></li>
</ul>
</li>
<li>系统用户级别：登录等钱操作系统的用户范围。git config –global<ul>
<li> git config <strong>–global</strong> user.name liwenkai       </li>
<li>git config <strong>–global</strong> user.email   <a href="mailto:&#x6c;&#105;&#x31;&#55;&#x36;&#x36;&#57;&#x34;&#57;&#56;&#x33;&#x36;&#x34;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;">&#x6c;&#105;&#x31;&#55;&#x36;&#x36;&#57;&#x34;&#57;&#56;&#x33;&#x36;&#x34;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;</a></li>
<li>信息保存的位置：~/.gitconfig文件下</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111151240376.png" alt="image-20211111151240376"></p>
</li>
</ul>
<h4 id="2-5-3-查看状态"><a href="#2-5-3-查看状态" class="headerlink" title="2.5.3.查看状态"></a>2.5.3.查看状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git status<br></code></pre></td></tr></table></figure>

<p>此时暂存区与本地库中都没有文件：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111164356213.png" alt="image-20211111164356213"></p>
<h4 id="2-5-4-提交文件到暂存区"><a href="#2-5-4-提交文件到暂存区" class="headerlink" title="2.5.4.提交文件到暂存区"></a>2.5.4.提交文件到暂存区</h4><p>创造了一个文件（vim good.txt）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">vim good.txt<br><br>:wq<br></code></pre></td></tr></table></figure>



<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111164720978.png" alt="image-20211111164720978"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git add good.txt<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111165023182.png" alt="image-20211111165023182"></p>
<p>提交完成后再查看状态：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111165150226.png" alt="image-20211111165150226"></p>
<p>从<strong>缓存区</strong>移除文件,工作区的文件不变：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git rm --cached good.txt<br></code></pre></td></tr></table></figure>



<h4 id="2-5-5-提交文件到本地库"><a href="#2-5-5-提交文件到本地库" class="headerlink" title="2.5.5.提交文件到本地库"></a>2.5.5.提交文件到本地库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git commit good.txt<br></code></pre></td></tr></table></figure>

<p>给本次提交添加注释（vim操作）：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111165723660.png" alt=":"></p>
<p>如果不行进入vim页面，可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git commit -m &quot;my second commit,nodify good.txt&quot;<br></code></pre></td></tr></table></figure>



<p>添加成功之后：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111170126999.png" alt="image-20211111170126999"></p>
<p>使用cat查看文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">cat good.txt<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111170315749.png" alt="image-20211111170315749"></p>
<p>查看状态：</p>
<p>暂存区为空，工作树也是干净的。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111170359958.png" alt="image-20211111170359958"></p>
<p>如果修改了good.txt文件，需要重新执行add和commit操作。</p>
<h4 id="2-5-6实现版本前进与后退"><a href="#2-5-6实现版本前进与后退" class="headerlink" title="2.5.6实现版本前进与后退"></a>2.5.6实现版本前进与后退</h4><p><strong>1.查看版本信息</strong></p>
<p>查看提交记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git log<br>多屏显示时的控制方法：<br>空格向上翻页，<br>b向下翻页<br>q退出<br></code></pre></td></tr></table></figure>

<p>HEAD表示指针，指向当前版本。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111171754150.png" alt="image-20211111171754150"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">以一行的形式显示：<br>git log --pretty=oneline<br>或者<br>git log --oneline<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111172348711.png" alt="image-20211111172348711"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">HEAD@&#123;移动到当前版本需要多少步&#125;<br>git reflog<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111172548154.png" alt="image-20211111172548154"></p>
<p><strong>2.基于索引值前进后退【推荐使用】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git reset --hard=索引值<br>需要提前知道前进版本的索引值，配合git reflog命令使用<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111202713257.png" alt="image-20211111202713257"></p>
<p><strong>3.使用^符号【只能后退】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git reset --hard HEAD^<br>一个^符号退一步，想要后退几步就在后面加几个^<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111203035570.png" alt="image-20211111203035570"></p>
<p>==显示文件的后n行==</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">显示文件后两行<br>$ tail -n 2 good.txt<br>全部显示文件<br>$ cat good.txt<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111203311151.png" alt="image-20211111203311151"></p>
<p><strong>4.使用~符号【只能后退】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">后退n步<br>git reset --hard HEAD~n<br></code></pre></td></tr></table></figure>



<h4 id="2-5-7-reset命令的三分参数比较"><a href="#2-5-7-reset命令的三分参数比较" class="headerlink" title="2.5.7 reset命令的三分参数比较"></a>2.5.7 reset命令的三分参数比较</h4><ul>
<li>–soft参数<ul>
<li>仅在本地库移动HEAD指针</li>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111204703204.png" alt="image-20211111204703204"></li>
</ul>
</li>
<li>–mixed参数<ul>
<li>在本地库移动HEAD指针</li>
<li>重置暂存区</li>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111204724633.png" alt="image-20211111204724633"></li>
</ul>
</li>
<li>–hard参数<ul>
<li>在本地库移动HEAD指针</li>
<li>重置暂存区</li>
<li>重置工作区</li>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111204741594.png" alt="image-20211111204741594"></li>
</ul>
</li>
</ul>
<h4 id="2-5-8-删除文件后找回"><a href="#2-5-8-删除文件后找回" class="headerlink" title="2.5.8 删除文件后找回"></a>2.5.8 删除文件后找回</h4><p>前提：删除前，文件存在时的状态提交到本地</p>
<p><strong>1.方式一：回退到之前的版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git reset --hard 索引值<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111210120060.png" alt="image-20211111210120060"></p>
<p><strong>2.方式二：将添加到暂存区的文件找回</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git reset --head HEAD<br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>删除操作已经提交到本地库：指针位置指向索引值</li>
<li>未提交到本地库：指针位置使用HEAD</li>
</ul>
<h4 id="2-5-9-比较文件"><a href="#2-5-9-比较文件" class="headerlink" title="2.5.9 比较文件"></a>2.5.9 比较文件</h4><p>比较文件是否发生了修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git diff apple.txt<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111211416299.png" alt="image-20211111211416299"></p>
<p>比较已经提交到暂存区的文件发生了那些修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git diff HEAD apple.txt<br></code></pre></td></tr></table></figure>



<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111211601887.png" alt="image-20211111211601887"></p>
<p>不指定文件名时，会比较工作区中的所有的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git diff HEAD<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111211859857.png" alt="image-20211111211859857"></p>
<h3 id="2-6-分支管理"><a href="#2-6-分支管理" class="headerlink" title="2.6 分支管理"></a>2.6 分支管理</h3><h4 id="2-6-1-什么是分支"><a href="#2-6-1-什么是分支" class="headerlink" title="2.6.1 什么是分支"></a>2.6.1 什么是分支</h4><p>在版本控制的过程中，使用多条线同时推进。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111212639622.png" alt="image-20211111212639622"></p>
<h4 id="2-6-2-分支的好处"><a href="#2-6-2-分支的好处" class="headerlink" title="2.6.2 分支的好处"></a>2.6.2 分支的好处</h4><ul>
<li>同时并行推进多个功能开发，提高工作效率。</li>
<li>各个分支在开发过程中，如果某一个分支开发失败了，不会对其他分支有任何的影响。失败的分支删除重新开始既可。</li>
</ul>
<h4 id="2-6-3-分支操作"><a href="#2-6-3-分支操作" class="headerlink" title="2.6.3 分支操作"></a>2.6.3 分支操作</h4><h5 id="1-查看拥有的所有分支"><a href="#1-查看拥有的所有分支" class="headerlink" title="1.查看拥有的所有分支"></a>1.查看拥有的所有分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git branch -v<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111213147745.png" alt="image-20211111213147745"></p>
<h5 id="2-创建分支"><a href="#2-创建分支" class="headerlink" title="2.创建分支"></a>2.创建分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">创建一个名字叫hot_fix的分支<br>$ git branch [分支名]<br></code></pre></td></tr></table></figure>



<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111213428937.png" alt="image-20211111213428937"></p>
<h5 id="3-切换分支"><a href="#3-切换分支" class="headerlink" title="3.切换分支"></a>3.切换分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git checkout [分支名]<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111213552432.png" alt="image-20211111213552432"></p>
<h5 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4.合并分支"></a>4.合并分支</h5><ul>
<li><p>第一步：切换到接收修改的分支上</p>
<ul>
<li><p>~~~git<br>$ git checkout [被合并分支名]</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><code class="hljs cos"><br>- 第二步：使用<span class="hljs-keyword">merge</span>命令进行合并<br><br>  - ~~~git<br>    $ git <span class="hljs-keyword">merge</span> [有新内容的分支]<br></code></pre></td></tr></table></figure></li>
<li><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111214630265.png" alt="image-20211111214630265"></p>
</li>
</ul>
</li>
</ul>
<h5 id="5-解决冲突"><a href="#5-解决冲突" class="headerlink" title="5 解决冲突"></a>5 解决冲突</h5><ul>
<li><p>冲突的表现：两个分支同时修改了同一个文件同一行中的数据。git不知道以哪一个为准。</p>
<ul>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111220459875.png" alt="image-20211111220459875"></li>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111220530944.png" alt="image-20211111220530944"></li>
</ul>
</li>
<li><p>冲突解决：</p>
<ul>
<li>第一步：编辑文件，删除特殊符号。</li>
<li>第二步：把文件修改到满意的程度，保存退出。</li>
<li><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211111220707665.png" alt="image-20211111220707665"></li>
<li>第三步：add，commit（此时commit一定不能带具体的文件名）</li>
</ul>
</li>
</ul>
<h2 id="3-Git原理"><a href="#3-Git原理" class="headerlink" title="3. Git原理"></a>3. Git原理</h2><h3 id="3-1-Hash"><a href="#3-1-Hash" class="headerlink" title="3.1 Hash"></a>3.1 Hash</h3><p>是一种加密算法。</p>
<p>Hash算法的特性：</p>
<ul>
<li>加密结果长度是一定的，都是16位。</li>
<li>Hash算法一致，输入一致，输出一定一样。</li>
<li>Hash算法一致，输入不一致，输出会发生很大的变化。</li>
<li>Hash算法是不可逆的。</li>
</ul>
<p>Git底层使用的是：SHA-1算法。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112100441920.png" alt="image-20211112100441920"></p>
<h3 id="3-2-Git保存版本的机制"><a href="#3-2-Git保存版本的机制" class="headerlink" title="3.2 Git保存版本的机制"></a>3.2 Git保存版本的机制</h3><p>SVN的保存机制：增量式版本控制</p>
<p>优点：节省空间</p>
<p>Git：快照流。没有修改的文件通过指针指向上个版本中的文件。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112112246132.png" alt="image-20211112112246132"></p>
<h3 id="3-3-Git分支管理机制"><a href="#3-3-Git分支管理机制" class="headerlink" title="3.3 Git分支管理机制"></a>3.3 Git分支管理机制</h3><p><strong>1.创建分支</strong></p>
<p>创建一个分支指向已有的版本。而不是把原来的复制一遍</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112112938429.png" alt="image-20211112112938429"></p>
<p><strong>2.分支切换</strong></p>
<p>HEAD指针指向testing指针。</p>
<p>通过简单地移动指针就可以切换分支。十分方便。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112113102856.png" alt="image-20211112113102856"></p>
<p><strong>3.修改数据</strong></p>
<p>当分支对文佳进行修改时，就会创造一个新的分支。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112113310025.png" alt="image-20211112113310025"></p>
<h2 id="4-GitHub相关"><a href="#4-GitHub相关" class="headerlink" title="4.GitHub相关"></a>4.GitHub相关</h2><p>账号注册：</p>
<ul>
<li>email：<a href="mailto:&#x33;&#50;&#57;&#49;&#50;&#x39;&#56;&#x36;&#54;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#x33;&#50;&#57;&#49;&#50;&#x39;&#56;&#x36;&#54;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;</a></li>
<li>用户名：WenkAndZz</li>
</ul>
<h3 id="4-1创建本地库与远程库"><a href="#4-1创建本地库与远程库" class="headerlink" title="4.1创建本地库与远程库"></a>4.1创建本地库与远程库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">创建本地库文件夹<br>mkdir [文件名]<br><br>进入本地库<br>cd [文件名]<br><br>初始化<br>git init<br><br>创建一个txt文件<br>vim [txt文件名].txt<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112120434326.png" alt="image-20211112120434326"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">创建远程库<br>在GitHub上，选择repository<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112161451631.png" alt="image-20211112161451631"></p>
<p>创建完成之后，有一个HTTPS的地址</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112161645184.png" alt="image-20211112161645184"></p>
<h3 id="4-2在本地创建远程仓库别名"><a href="#4-2在本地创建远程仓库别名" class="headerlink" title="4.2在本地创建远程仓库别名"></a>4.2在本地创建远程仓库别名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">创建别名，origin别名，后面是地址<br>$ git remote add origin https://github.com/WenkAndZz/huashan.git<br>查看历史数据<br>$ git remote -v<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112162053144.png" alt="image-20211112162053144"></p>
<h3 id="4-3-推送数据"><a href="#4-3-推送数据" class="headerlink" title="4.3 推送数据"></a>4.3 推送数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">推送数据<br>$ git push [远程仓库别名] [分支名]<br>$ git push origin master<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112170659548.png" alt="image-20211112170659548"></p>
<p>注：GitHub是一个国外网站，访问很慢。可以使用<strong>码云</strong>。</p>
<h3 id="4-4-克隆操作"><a href="#4-4-克隆操作" class="headerlink" title="4.4 克隆操作"></a>4.4 克隆操作</h3><p>更换目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ cd ..<br><br>$ mkdir huashan_linghuchong<br><br>$ cd huashan_linghuchong<br></code></pre></td></tr></table></figure>

<p><strong>执行克隆操作：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git clone https://gitee.com/wenkailllll/huashan.git<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112171321540.png" alt="image-20211112171321540"></p>
<p>克隆有三个效果：</p>
<ul>
<li>完整的把远程库下载到本地。</li>
<li>创建origin远程地址别名。</li>
<li>初始化本地库。</li>
</ul>
<h3 id="4-5-从远程库拉取"><a href="#4-5-从远程库拉取" class="headerlink" title="4.5 从远程库拉取"></a>4.5 从远程库拉取</h3><p><strong>方法一：fetch(拉取)+merge(合并)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">从远程库中拉取数据<br>$ git fetch origin master<br>此时本地库中的数据没有发生改变，远程库中的数据保存在origin/master中<br></code></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">将本地的master跟远程库下载下来的进行合并<br>$ git merge origin/master<br><br>合并之后master中的数据就与远程库一致了<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112173104034.png" alt="image-20211112173104034"></p>
<p><strong>方法二：pull=fetch(拉取)+merge(合并)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git pull origin master<br></code></pre></td></tr></table></figure>



<h3 id="4-6协同合作时冲突的解决"><a href="#4-6协同合作时冲突的解决" class="headerlink" title="4.6协同合作时冲突的解决"></a>4.6协同合作时冲突的解决</h3><ul>
<li>要点：<ul>
<li>如果不是基于GitHub远程库的最新版所做的修改，必须先拉取（pull）。</li>
<li>拉取下来之后按照”分支冲突解决“操作解决既可。</li>
</ul>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">1.先拉取，使当前变为最新版。<br>git pull [远程库] [分支名]<br>此时冲突文件会被合并。<br><br>2.vim到冲突文件中，对冲突文件进行修改。<br>vim [冲突文件]<br><br>3.修改后再添加到暂存区<br>git add [冲突文件]<br><br>4.提交到本地库中。<br>git commit [冲突文件]<br><br>5.推送到远程仓库中<br>git push [远程库] [分支名]<br><br></code></pre></td></tr></table></figure>

<h3 id="4-7跨团队协作"><a href="#4-7跨团队协作" class="headerlink" title="4.7跨团队协作"></a>4.7跨团队协作</h3><ol>
<li>Fork项目</li>
<li>克隆到本地 git clone</li>
<li>修改后提交 git push</li>
<li>在GitHub网页上有个push requests</li>
<li>本团队对这个request进行审核。审核成功就可以合并（merge）</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112214534482.png" alt="image-20211112214534482"></p>
<h3 id="4-8-SSH免密登录"><a href="#4-8-SSH免密登录" class="headerlink" title="4.8 SSH免密登录"></a>4.8 SSH免密登录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">1.切换到根目录下：<br>cd ~<br><br>2.删除.ssh文件<br>rm -r .shh/<br><br>3.给当前邮箱号设置一个ssh加密<br>$ ssh-keygen -t rsa -C 329129866@qq.com<br><br>4.去.ssh/文件下，赋值id_rsa.pub中的内容<br>$ cd .ssh/<br><br>5.打开GitHub，在设置中找到ssh秘钥，把复制的内容添加到这里。<br></code></pre></td></tr></table></figure>



<p>使用的时候，要使用ssh地址，才能免密登录。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211112220837890.png" alt="image-20211112220837890"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">1.给远程仓库的ssh地址设置一个别名<br>git remote add origin_ssh git@gitee.com:wenkailllll/huashan.git<br><br>2.使用ssh去push文件<br>git push origin_ssh master<br></code></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>关系型数据库：MySQL</title>
    <url>/2021/11/15/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySQL/</url>
    <content><![CDATA[<p>MySQL是一个<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/696511">关系型数据库管理系统</a>，由瑞典[MySQL AB](<a href="https://baike.baidu.com/item/MySQL">https://baike.baidu.com/item/MySQL</a> AB/2620844) 公司开发，属于 <a href="https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品。MySQL 是最流行的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/696511">关系型数据库管理系统</a>之一，在 <a href="https://baike.baidu.com/item/WEB/150564">WEB</a> 应用方面，MySQL是最好的 <a href="https://baike.baidu.com/item/RDBMS/1048260">RDBMS</a> (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<span id="more"></span>

<h1 id="一、数据库概述"><a href="#一、数据库概述" class="headerlink" title="一、数据库概述"></a>一、数据库概述</h1><h2 id="1、使用数据库的优势"><a href="#1、使用数据库的优势" class="headerlink" title="1、使用数据库的优势"></a>1、使用数据库的优势</h2><p>使用数据库有两个优势：</p>
<ul>
<li>持久化数据到本地。</li>
<li>可以实现结构化查询，方便管理。</li>
</ul>
<h2 id="2、数据库相关概念"><a href="#2、数据库相关概念" class="headerlink" title="2、数据库相关概念"></a>2、数据库相关概念</h2><p>**DB(Database)**：数据库，保存一组有组织的数据的容器。</p>
<p>**DBMS(Database Management System)**：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据。</p>
<p>**SQL(Structured Query Language)**：结构化查询语言，用于和DBMS通信的语言，包括数据插入、查询、更新、删除，数据库模式创建和修改，以及数据访问控制。</p>
<h2 id="3、SQL的语言分类"><a href="#3、SQL的语言分类" class="headerlink" title="3、SQL的语言分类"></a>3、SQL的语言分类</h2><p><strong>DDL(Data Definition Language)<strong>：数据定义语言。允许用户</strong>定义</strong>数据，包括创建（create）、删除（drop）、修改（alter）这些操作。通常，DDL由数据库管理员执行。</p>
<p><strong>DML(Data Manipulation Language</strong>)：数据操作语言。DML为用户提供添加（insert）、删除（delete）、更新数据（update）的能力，这些是应用程序对数据库的日常操作。</p>
<p>**DQL(Data Query Language)**：数据查询语言，执行查询（select）操作。<br>**TCL(Transaction Control Language)**：事务控制语言，执行commit、rollback等操作。</p>
<h1 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h1><h2 id="1、什么是关系型数据库"><a href="#1、什么是关系型数据库" class="headerlink" title="1、什么是关系型数据库"></a>1、什么是关系型数据库</h2><p>**RDBMS(Relational Database Management System)**：关系型数据库管理系统，即基于关系模型的数据库。</p>
<p><strong>关系模型</strong>把数据看作是一个二维表格，任何数据都可以通过行号和列号来唯一确定，它的数据模型看起来就是一个Excel表。</p>
<h2 id="2、RDBMS存储数据的特点"><a href="#2、RDBMS存储数据的特点" class="headerlink" title="2、RDBMS存储数据的特点"></a>2、RDBMS存储数据的特点</h2><p>RDBMS存储数据的特点：</p>
<ul>
<li>数据以表格的形式出现，每个表都有唯一的名字，用于标识自己。</li>
<li>若干的表格组成数据库。</li>
<li>表本身具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>表中的<strong>列</strong>也称为<strong>字段（Column）</strong>。列类似于java 中的”属性”。</li>
<li>表中的<strong>行</strong>称为<strong>记录（Record）</strong>，每一行是一组相关的数据。行类似于java中的“对象”。</li>
</ul>
<h2 id="3、常见的关系型数据库"><a href="#3、常见的关系型数据库" class="headerlink" title="3、常见的关系型数据库"></a>3、常见的关系型数据库</h2><ul>
<li>商用数据库，例如：<a href="https://www.oracle.com/">Oracle</a>，<a href="https://www.microsoft.com/sql-server/">SQL Server</a>，<a href="https://www.ibm.com/db2/">DB2</a>等；</li>
<li>开源数据库，例如：<a href="https://www.mysql.com/">MySQL</a>，<a href="https://www.postgresql.org/">PostgreSQL</a>等；</li>
<li>桌面数据库，以微软<a href="https://products.office.com/access">Access</a>为代表，适合桌面应用程序使用；</li>
<li>嵌入式数据库，以<a href="https://sqlite.org/">Sqlite</a>为代表，适合手机应用和桌面程序。</li>
</ul>
<h2 id="4、NoSQL"><a href="#4、NoSQL" class="headerlink" title="4、NoSQL"></a>4、NoSQL</h2><p>NoSQL数据库，也就是非SQL的数据库，包括MongoDB、Cassandra、Dynamo等等，它们都不是关系数据库。SQL数据库从始至终从未被取代过，NoSQL的发展历程：</p>
<ul>
<li>1970: NoSQL = We have no SQL</li>
<li>1980: NoSQL = Know SQL</li>
<li>2000: NoSQL = No SQL!</li>
<li>2005: NoSQL = Not only SQL</li>
<li>2013: NoSQL = No, SQL!</li>
</ul>
<p>今天，SQL数据库仍然承担了各种应用程序的核心数据存储，而NoSQL数据库作为SQL数据库的补充，两者不再是二选一的问题，而是主从关系。</p>
<h1 id="三、MySQL"><a href="#三、MySQL" class="headerlink" title="三、MySQL"></a>三、MySQL</h1><h2 id="1、MySQL介绍"><a href="#1、MySQL介绍" class="headerlink" title="1、MySQL介绍"></a>1、MySQL介绍</h2><p>MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。</p>
<p>MySQL优势：</p>
<ul>
<li>开源、免费、成本低</li>
<li>性能高、移植性好</li>
<li>体积小，便于安装</li>
</ul>
<h2 id="2、MySQL安装"><a href="#2、MySQL安装" class="headerlink" title="2、MySQL安装"></a>2、MySQL安装</h2><p>MySQL属于c/s架构的软件，一般来讲只安装服务端。以下案例以 MySQL5.7 为例</p>
<p>下载<a href="https://dev.mysql.com/downloads/mysql/">链接</a></p>
<h2 id="3、MySQL服务的启动和停止"><a href="#3、MySQL服务的启动和停止" class="headerlink" title="3、MySQL服务的启动和停止"></a>3、MySQL服务的启动和停止</h2><p>Windows下，MySQL启动和停止有两种方式：</p>
<ul>
<li>计算机—右击管理—服务，启动MySQL服务</li>
<li>通过管理员身份运行cmd：<ul>
<li>net start 服务名（启动服务），例<code>net start mysql57</code></li>
<li>net stop 服务名（停止服务），例<code>net stop mysql57</code></li>
</ul>
</li>
</ul>
<h2 id="4、MySQL服务的登录和退出"><a href="#4、MySQL服务的登录和退出" class="headerlink" title="4、MySQL服务的登录和退出"></a>4、MySQL服务的登录和退出</h2><p> 方式一：通过mysql自带的客户端（MySQL Line Client），只限于root用户</p>
<p> 方式二：通过windows的命令提示符，以管理员身份打开</p>
<ul>
<li><p>登录：<code>mysql [-h 主机名 -P 端口号] -u 用户名 -p密码</code>，<code>[]</code>里的内容表示可以省略</p>
<blockquote>
<p>其中<code>p</code>参数和密码直接不能有空格，其他参数和值之间空格可有可无，比如<code>-uroot</code>，表示root用户。</p>
<p>密码可以不添加值，直接回车，然后输入密码，不会显示出明文。</p>
<p>如果是本机，并且端口是3306，可以省略<code>-h</code>和<code>-P</code>参数，直接输入用户名和密码即可。</p>
</blockquote>
</li>
<li><p>退出：<code>exit</code></p>
</li>
</ul>
<p>如下图：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_1.png"><img src="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_1.png" alt="img"></a></p>
<h2 id="5、MySQL的常见命令"><a href="#5、MySQL的常见命令" class="headerlink" title="5、MySQL的常见命令"></a>5、MySQL的常见命令</h2><p>查看当前所有的数据库:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">show databases<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>打开指定的库:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">use 库名<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>查看当前库的所有表:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br></code></pre></td></tr></table></figure>

<p>查看其它库的所有表：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span> <span class="hljs-keyword">from</span> 库名;<br></code></pre></td></tr></table></figure>

<p>查看表结构：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">desc 表名<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>查看表的列属性：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></table></figure>

<p>查看表的索引：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></table></figure>

<p>查看xx状态：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 查看指定表的状态信息</span><br>show table status from 表名/数据库;<br><br><span class="hljs-comment"># 查看主从复制中的主机状态</span><br>show <span class="hljs-keyword">master</span> <span class="hljs-title">status</span>;<br><br><span class="hljs-comment"># 查看主从复制中从机状态</span><br>show <span class="hljs-literal">slave</span> status;<br></code></pre></td></tr></table></figure>

<p>查看服务器的版本：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 方式一，在mysql服务端查看：</span><br>select <span class="hljs-built_in">version</span>();<br><span class="hljs-comment"># 方式二，在cmd窗口查看：</span><br>mysql <span class="hljs-comment">--version</span><br>或<br>mysql <span class="hljs-comment">--V</span><br></code></pre></td></tr></table></figure>

<p>用户管理指令：</p>
<p><strong>添加用户的两种方式</strong></p>
<p>1、使用insert指令，在mysql.user表中添加用户：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 比如想添加用户：<span class="hljs-keyword">user</span>，密码：<span class="hljs-number">123456</span>，并授予<span class="hljs-keyword">select</span>权限<br># 只需要在<span class="hljs-keyword">user</span>表的指定列添加内容即可。<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> mysql.<span class="hljs-keyword">user</span>(host,<span class="hljs-keyword">user</span>,<span class="hljs-keyword">password</span>，select_priv)<br>	<span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-keyword">password</span>(<span class="hljs-string">&#x27;123456&#x27;</span>),<span class="hljs-string">&#x27;Y&#x27;</span>);<br>flush <span class="hljs-keyword">privileges</span>;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">其中host列表示限制登陆的主机，localhost表示只能当前主机登陆，</span><br><span class="hljs-comment">可以指定ip，使用%表示任意主机。</span><br><span class="hljs-comment">MySQL5.7以后，password改名为authentication_string。</span><br><span class="hljs-comment">密码需要使用password()函数进行加密，MySQL8.0.11移除了这个函数，可以使用MD5()代替。</span><br><span class="hljs-comment">可以根据需求授予其他权限，只需要相应列赋值为&#x27;Y&#x27;即可。</span><br><span class="hljs-comment">添加完后，使用flush privileges语句刷新授权表，使之立即生效，</span><br><span class="hljs-comment">否则需要重启MySQL服务才生效。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>2、使用grant命令</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 比如给指定数据库比如student库，添加用户user，密码123,授予select权限</span><br><span class="hljs-attribute">grant</span> <span class="hljs-literal">select</span>   <span class="hljs-comment"># 指定授予的权限</span><br><span class="hljs-literal">on</span> <span class="hljs-regexp">student.*</span>   <span class="hljs-comment"># 指定数据库和表，*表示所有，这里表示student库所有表</span><br>to <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>  <span class="hljs-comment"># 指定用户名和登陆主机，localhost根据需求填写</span><br>indentified by <span class="hljs-string">&#x27;123&#x27;</span>;   <span class="hljs-comment"># 指定登录密码。</span><br></code></pre></td></tr></table></figure>

<p>grant指令更多内容，参考<a href="https://dev.mysql.com/doc/refman/8.0/en/grant.html#grant-overview">GRANT Statement</a></p>
<h2 id="6、MySQL的语法规范"><a href="#6、MySQL的语法规范" class="headerlink" title="6、MySQL的语法规范"></a>6、MySQL的语法规范</h2><p>MySQL中的命令有以下规范：</p>
<ul>
<li><strong>不区分大小写</strong>，建议关键字大写，表名和列名小写</li>
<li>每条命令以<code>;</code>或<code>\g</code>结尾</li>
<li>每条命令根据需要，可以进行缩进或换行。关键字不能缩写或分行。</li>
<li>注释<ul>
<li>单行注释：<code>#注释文字</code></li>
<li>单行注释：<code>-- 注释文字</code>,(注意<code>--</code>后面有空格)</li>
<li>多行注释：<code>/* 注释文字 */</code></li>
</ul>
</li>
</ul>
<p>字符（建议加，有时必须加）和日期型要加引号，数值不需要加。<strong>表的别名不需要加引号</strong></p>
<h1 id="四、MySQL数据类型"><a href="#四、MySQL数据类型" class="headerlink" title="四、MySQL数据类型"></a>四、MySQL数据类型</h1><p>MySQL支持所有标准SQL数值数据类型（SQL数据类型参考<a href="https://www.runoob.com/sql/sql-datatypes-general.html">链接</a>）。作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。详细参考<a href="https://www.runoob.com/mysql/mysql-data-types.html">MySQL数据类型</a></p>
<p><strong>MySQL中的TRUE和FALSE，也可以分别用1和0表示。</strong></p>
<p>MySQL中的数据类型包括<strong>数值型</strong>、<strong>字符型</strong>、<strong>日期型</strong>等。</p>
<p><strong>数值型</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>类型</strong></th>
<th><strong>字节</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>整型</td>
<td>Tinyint</td>
<td>1</td>
<td>有符号：-128<del>127 无符号：0</del>255</td>
</tr>
<tr>
<td>Smallint</td>
<td>2</td>
<td>有符号：-32768<del>32767 无符号：0</del>65535</td>
<td></td>
</tr>
<tr>
<td>Mediumint</td>
<td>3</td>
<td>有符号：-8,388,608<del>8,388,607 无符号：0</del>16,777,215</td>
<td></td>
</tr>
<tr>
<td>Int/Integer</td>
<td>4</td>
<td>有符号：-2,147,483,648<del>2,147,483,647 无符号：0</del>4,294,967,296</td>
<td></td>
</tr>
<tr>
<td>Bigint</td>
<td>8</td>
<td>有符号：-2^63<del>2^63-1 无符号：0</del>2^64</td>
<td></td>
</tr>
<tr>
<td>浮点型小数</td>
<td>float(M,D)</td>
<td>4</td>
<td>±1.75494351E-38 ~ ±3.402823466E+38</td>
</tr>
<tr>
<td>double(M,D)</td>
<td>8</td>
<td>±2.2250738585072014E-308 ~ ±1.7976931348623157E+308</td>
<td></td>
</tr>
<tr>
<td>定点型小数</td>
<td>DEC(M,D) DECIMAL(M,D)</td>
<td>M+2</td>
<td>最大取值范围与double相同， 给定decimal的有效取值范围由M和D决定</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li>如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要在类型后面添加<code>unsigned</code>关键字</li>
<li>如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值</li>
<li>如果不设置长度，会有默认的长度。长度不决定范围，长度代表了显示的最大宽度。可以选择在长度不够时，用0在左边填充，需要在类型后面添加<code>zerofill</code>。zerofill只支持正数（无符号）</li>
<li>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</li>
<li>M表示整数部位个数+小数部位个数的总长度。D表示小数部位长度。如果插入的数值超过范围，会报out of range异常，并插入临界值。</li>
<li>M和D都可以省略。如果是decimal，则M默认为10，D默认为0。</li>
<li>float和double，会根据插入的数值的精度来决定精度。</li>
</ul>
<p><strong>字符型</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>最多字符数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>char(M)</td>
<td>M</td>
<td>M为0~255之间的整数，固定长度的字符，比较耗费空间，效率高</td>
</tr>
<tr>
<td>varchar(M)</td>
<td>M</td>
<td>M为0~65535之间的整数，可变长度的字符，比较节省空间，效率低</td>
</tr>
</tbody></table>
<p>M表示最大的字符个数，而不是存储空间。</p>
<p>M</p>
<p>其他字符型类型：</p>
<ul>
<li><code>binary</code>和<code>varbinary</code>用于保存较短的二进制</li>
<li><code>enum</code>用于保存枚举类型，要求插入的值必须属于列表中指定的值之一。如果列表成员为<code>1~255</code>，则需要1个字节存储。如果列表成员为<code>255~65535</code>，则需要2个字节存储，最多为65535个成员。</li>
<li><code>set</code>用于保存集合。里面可以保存0~64个成员。一次可以选取多个成员。根据成员个数不同，存储所占的字节从1-8变化。</li>
<li><code>text</code>用于存放较长的文本</li>
<li><code>blob</code>用于存放较大的二进制</li>
</ul>
<p><strong>日期型</strong></p>
<table>
<thead>
<tr>
<th>日期和时间类型</th>
<th>字节</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td><code>date</code></td>
<td>4</td>
<td>1000-01-01</td>
<td>9999-12-31</td>
</tr>
<tr>
<td><code>datetime</code></td>
<td>8</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>4</td>
<td>1970-01-01 00:00:00</td>
<td>2038-1-19某一时刻</td>
</tr>
<tr>
<td><code>time</code></td>
<td>3</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td><code>year</code></td>
<td>1</td>
<td>1901</td>
<td>2155</td>
</tr>
</tbody></table>
<p>其中字符型和日期型的常量值必须要用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>包起来。数值型不需要。</p>
<p><strong>datetime和timestamp的对比</strong></p>
<ul>
<li>二者都是保存日期和时间。</li>
<li>datetime占用8字节，范围是1000-9999，不受时区的影响。</li>
<li>timestamp占用4字节，范围为1970-2038，受时区的影响，其值会根据时区的变化而变化。即插入数据以后，如果修改时区，表中的时间戳也会改变为对应时区的值。</li>
</ul>
<h1 id="五、DQL语言"><a href="#五、DQL语言" class="headerlink" title="五、DQL语言"></a>五、DQL语言</h1><p>DQL为数据查询语言，执行查询（select）操作。</p>
<p>DQL的完整查询语句结构：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> 字段,...				<span class="hljs-meta"># 7</span><br><span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> [别名]				<span class="hljs-meta"># 1</span><br>[<span class="hljs-meta">连接类型 join 表2</span>]...			<span class="hljs-meta"># 2</span><br>[<span class="hljs-meta">on 连接条件</span>]				<span class="hljs-meta"># 3</span><br>[<span class="hljs-meta">where 筛选条件</span>]			<span class="hljs-meta"># 4</span><br>[<span class="hljs-meta">group by 分组字段</span>]			<span class="hljs-meta"># 5</span><br>[<span class="hljs-meta">having 分组后的筛选条件</span>]		<span class="hljs-meta"># 6</span><br>[<span class="hljs-meta">order by 排序的字段或表达式</span>]		<span class="hljs-meta"># 8</span><br>[<span class="hljs-meta">limit 偏移量(起始条目索引),条数</span>]; 	<span class="hljs-meta"># 9</span><br></code></pre></td></tr></table></figure>

<p>以上各部分的执行顺序：<br><code>from</code>→<code>join</code>→<code>on</code>→<code>where</code>→<code>group by</code>(开始使用select中的别名，后面的语句都可以使用)-</p>
<p>→<code>AVG/SUM/MAX/MIN等分组函数</code>→<code>having</code>→<code>select</code>→<code>distinct</code>→<code>order by</code>→<code>limit</code></p>
<p>以下案例使用的数据库：<code>myemployees</code>，其中有<code>departments</code>、<code>employees</code>、<code>job_grades</code>、<code>jobs</code>、<code>locations</code>共五张表。各自的包含的字段如下：</p>
<p><code>departments</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_3.png"><img src="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_3.png" alt="img"></a></p>
<p><code>employees</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_2.png"><img src="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_2.png" alt="img"></a></p>
<p><code>job_grades</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_4.png"><img src="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_4.png" alt="img"></a></p>
<p><code>jobs</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_5.png"><img src="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_5.png" alt="img"></a></p>
<p><code>locations</code>表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_6.png"><img src="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_6.png" alt="img"></a></p>
<h2 id="1、基础查询"><a href="#1、基础查询" class="headerlink" title="1、基础查询"></a>1、基础查询</h2><p>语法：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> 查询内容 [<span class="hljs-keyword">FROM</span> 表名];<br></code></pre></td></tr></table></figure>

<blockquote>
<p>类似于Java中的System.out.println(要打印的东西);</p>
<p>查询的结果是一个虚拟的表，不会改变原来的表格。</p>
</blockquote>
<p>特点：<br>①通过select查询出的结果 ，是一个虚拟的表格，不是真实存在</p>
<p>②查询内容可以是<strong>常量值</strong>、<strong>表达式</strong>、<strong>字段</strong>、<strong>函数</strong></p>
<p>示例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#1.查询单个字段<br><span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">FROM</span> employees;<br><br>#2.查询多个字段<br><span class="hljs-keyword">SELECT</span> last_name,salary,email <span class="hljs-keyword">FROM</span> employees;<br><br>#3.查询所有字段<br><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-symbol">`employee_id`</span>,<br>    <span class="hljs-symbol">`first_name`</span>,<br>    <span class="hljs-symbol">`last_name`</span>,<br>    <span class="hljs-symbol">`phone_number`</span>,<br>    <span class="hljs-symbol">`last_name`</span>,<br>    <span class="hljs-symbol">`job_id`</span>,<br>    <span class="hljs-symbol">`phone_number`</span>,<br>    <span class="hljs-symbol">`job_id`</span>,<br>    <span class="hljs-symbol">`salary`</span>,<br>    <span class="hljs-symbol">`commission_pct`</span>,<br>    <span class="hljs-symbol">`manager_id`</span>,<br>    <span class="hljs-symbol">`department_id`</span>,<br>    <span class="hljs-symbol">`hiredate`</span> <br><span class="hljs-keyword">FROM</span><br>    employees ;<br>#方式二，*号表示所有字段：  <br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees;<br><br>#4.查询常量<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span>;<br><br>#5.查询函数<br><span class="hljs-keyword">SELECT</span> VERSION();<br><br>#6.查询表达式<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span>%<span class="hljs-number">98</span>;<br></code></pre></td></tr></table></figure>

<p><strong>别名</strong>：如果要查询的字段有重名的情况，可以使用别名区分；同样，表也可以起别名。</p>
<p>定义别名有两种方式：</p>
<ul>
<li><p>使用<code>as</code>:</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">SELECT 100%98 AS 结果;<br><span class="hljs-section">/*运行结果为：</span><br><span class="hljs-section">+------+</span><br><span class="hljs-section">| 结果 |</span><br><span class="hljs-section">+------+</span><br><span class="hljs-section">|    2 |</span><br><span class="hljs-section">+------+</span><br>*/<br>SELECT last_name AS 姓,first_name AS 名 FROM employees;<br></code></pre></td></tr></table></figure></li>
<li><p>使用空格，将<code>as</code>替换为空格即可：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> last_name 姓,first_name 名 <span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>去重</strong>：使用<code>distinct</code>对结果去重</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例：查询员工表中涉及到的所有的部门编号<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id <span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure>

<p><strong>+号在MySQL中的作用</strong>：</p>
<p>MySQL中的<code>+</code>号只有运算符的作用，其运算规则如下：</p>
<ul>
<li>如果两个操作值都是数值型，做加法运算</li>
<li>如果一方为字符型，则尝试进行转换，转换成功就做加法运算，如果转换失败，则将字符值当作0</li>
<li>任何数和<code>null</code>做加法运算，结果都是<code>null</code></li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">select</span> <span class="hljs-number">100</span>+<span class="hljs-number">90</span>;  # 结果为<span class="hljs-number">190</span>select &#x27;<span class="hljs-number">123</span>&#x27;+<span class="hljs-number">90</span>; # 结果为<span class="hljs-number">213</span>select &#x27;john&#x27;+<span class="hljs-number">90</span>; # 结果为<span class="hljs-number">90</span>select null+<span class="hljs-number">10</span>;  # 结果为null<br></code></pre></td></tr></table></figure>

<h2 id="2、条件查询"><a href="#2、条件查询" class="headerlink" title="2、条件查询"></a>2、条件查询</h2><p>语法：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> 要查询的字段|表达式|常量值|函数<span class="hljs-keyword">from</span> 表<span class="hljs-keyword">where</span> 筛选条件;  <span class="hljs-meta"># where后面加筛选条件</span><br></code></pre></td></tr></table></figure>

<p>根据筛选条件的不同，可以分为以下几种：</p>
<p>① <strong>条件表达式</strong></p>
<p>使用以下条件运算符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>=</code></td>
<td align="left">等于，也可以作为赋值符号，为了便于区分，变量赋值尽量用<code>:=</code>符号。 不能用于判断<code>null</code>值</td>
</tr>
<tr>
<td align="center"><code>&gt;</code></td>
<td align="left">大于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="left">小于</td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="center"><code>&lt;&gt;</code>或<code>!=</code></td>
<td align="left">不等于，两种写法均可，不能用于判断<code>null</code>值</td>
</tr>
</tbody></table>
<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询工资&gt;12000的员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> salary&gt;<span class="hljs-number">12000</span>;#案例2：查询部门编号不等于90号的员工名和部门编号<span class="hljs-keyword">SELECT</span> 	last_name,	department_idFROM employeesWHERE department_id&lt;&gt;<span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure>

<p>②<strong>逻辑表达式</strong></p>
<p>使用以下逻辑运算符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>and</code>或<code>&amp;&amp;</code></td>
<td>与</td>
</tr>
<tr>
<td><code>or</code>或</td>
<td>或</td>
</tr>
<tr>
<td><code>not</code>或<code>!</code></td>
<td>非</td>
</tr>
</tbody></table>
<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金<span class="hljs-keyword">SELECT</span>	last_name,	salary,	commission_pctFROM employeesWHERE salary&gt;=<span class="hljs-number">10000</span> <span class="hljs-keyword">AND</span> salary&lt;=<span class="hljs-number">20000</span>;#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE <span class="hljs-keyword">NOT</span>(department_id&gt;=<span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> department_id&lt;=<span class="hljs-number">110</span>) <span class="hljs-keyword">OR</span> salary&gt;<span class="hljs-number">15000</span>;<br></code></pre></td></tr></table></figure>

<p>③<strong>其他</strong></p>
<p>包括以下几种：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>like</code></td>
<td align="left">模糊查询，<code>%</code>用于匹配<strong>任意个</strong>字符，包括0个，<code>_</code>用于匹配<strong>任意一个</strong>字符</td>
</tr>
<tr>
<td><code>between ... and ...</code></td>
<td align="left">判断是否在范围之间，相当于<code>&gt;=</code>和<code>&lt;=</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td align="left">使用<code>=</code>号判断</td>
</tr>
<tr>
<td><code>is null</code>，<code>is not null</code></td>
<td align="left">用于判断是否为<code>null</code></td>
</tr>
</tbody></table>
<p><code>like</code> 一般用于字符型数据，也可以查询数值型数据。使用通配符查询，默认<code>\</code>为转义字符，也可以使用<code>escape</code>自定义转移字符。</p>
<p>案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#查询员工名中包含字符a的员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span>;#查询员工名中第二个字符为_的员工名<span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">FROM</span> employeesWHERE last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_#_%&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;#&#x27;</span>; # 自定义#作为转义字符<br></code></pre></td></tr></table></figure>

<p><code>between and</code>语句包含两个临界值，且要求是合法的范围：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#查询员工编号在100到120之间的员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE employee_id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">120</span>;#等价于：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE employee_id &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> employee_id&lt;=<span class="hljs-number">120</span>;<br></code></pre></td></tr></table></figure>

<p><code>in</code>用于判断某字段的值是否属于<strong>in列表</strong>中的某一项，使用<code>=</code>号判断</p>
<ul>
<li>in列表的值类型必须一致或兼容</li>
<li>in列表中不支持通配符</li>
</ul>
<p>案例：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">#查询工种编号是IT_PROG、AD_VP、AD_PRES中其中一个的所有员工的姓名和工种编号<span class="hljs-meta">SELECT</span> last_name, job_id <span class="hljs-meta">FROM</span> employeesWHERE job_id <span class="hljs-meta">IN(</span> <span class="hljs-string">&#x27;IT_PROT&#x27;</span> ,<span class="hljs-string">&#x27;AD_VP&#x27;</span>,<span class="hljs-string">&#x27;AD_PRES&#x27;</span>);#等价于<span class="hljs-meta">SELECT</span> last_name, job_id <span class="hljs-meta">FROM</span> employeesWHERE job_id = <span class="hljs-string">&#x27;IT_PROT&#x27;</span> <span class="hljs-meta">OR</span> job_id = <span class="hljs-string">&#x27;AD_VP&#x27;</span> <span class="hljs-meta">OR</span> JOB_ID =<span class="hljs-string">&#x27;AD_PRES&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><code>is null</code>和<code>is not null</code>用于判断字段是否为<code>null</code>，且只能用于判断是否为<code>null</code>，不能用于判断是否等于某个数值：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#查询没有奖金的员工名和奖金率<span class="hljs-keyword">SELECT</span> last_name,commission_pct <span class="hljs-keyword">FROM</span> employeesWHERE commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p><code>&lt;=&gt;</code>既可以判断是否等于某个数值，也能用于判断是否为<code>null</code>：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询没有奖金的员工名和奖金率<span class="hljs-keyword">SELECT</span> last_name, commission_pctFROM employeesWHERE commission_pct &lt;=&gt;<span class="hljs-literal">NULL</span>;#案例2：查询工资为12000的员工名和工资<span class="hljs-keyword">SELECT</span> last_name, salaryFROM employeesWHERE salary &lt;=&gt; <span class="hljs-number">12000</span>;<br></code></pre></td></tr></table></figure>

<h2 id="3、排序查询"><a href="#3、排序查询" class="headerlink" title="3、排序查询"></a>3、排序查询</h2><p>语法：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表名[<span class="hljs-keyword">where</span> 筛选条件]<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序的字段|表达式|函数|别名 [<span class="hljs-keyword">asc</span>|<span class="hljs-keyword">desc</span>];  # 使用<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>排序<br></code></pre></td></tr></table></figure>

<blockquote>
<p>默认asc，表示升序。也可以使用desc指定为降序</p>
<p>order by的位置一般放在最后面（除limit外)</p>
</blockquote>
<p>案例：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-string">#1</span>、按单个字段排序<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>;<span class="hljs-string">#2</span>、添加筛选条件再排序#查询部门编号&gt;=<span class="hljs-number">90</span>的员工信息，并按员工编号降序<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id&gt;=<span class="hljs-number">90</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> employee_id <span class="hljs-keyword">DESC</span>;<span class="hljs-string">#3</span>、按表达式排序#查询员工信息 按年薪降序<span class="hljs-keyword">SELECT</span> *,salary*<span class="hljs-number">12</span>*(<span class="hljs-number">1</span>+IFNULL(commission_pct,<span class="hljs-number">0</span>)) <span class="hljs-keyword">FROM</span> employeesORDER <span class="hljs-keyword">BY</span> salary*<span class="hljs-number">12</span>*(<span class="hljs-number">1</span>+IFNULL(commission_pct,<span class="hljs-number">0</span>)) <span class="hljs-keyword">DESC</span>;<span class="hljs-string">#4</span>、按别名排序#查询员工信息 按年薪升序<span class="hljs-keyword">SELECT</span> *,salary*<span class="hljs-number">12</span>*(<span class="hljs-number">1</span>+IFNULL(commission_pct,<span class="hljs-number">0</span>)) 年薪<span class="hljs-keyword">FROM</span> employeesORDER <span class="hljs-keyword">BY</span> 年薪 <span class="hljs-keyword">ASC</span>;<span class="hljs-string">#5</span>、按函数排序#查询员工名，并且按名字的长度降序<span class="hljs-keyword">SELECT</span> LENGTH(last_name),last_name <span class="hljs-keyword">FROM</span> employeesORDER <span class="hljs-keyword">BY</span> LENGTH(last_name) <span class="hljs-keyword">DESC</span>;<span class="hljs-string">#6</span>、按多个字段排序#案例：查询员工信息，要求先按工资降序，再按employee_id升序<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesORDER <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>,employee_id <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure>

<h2 id="4、常见函数"><a href="#4、常见函数" class="headerlink" title="4、常见函数"></a>4、常见函数</h2><p>MySQL中的函数类似于java中的方法，将一组逻辑语句封装在方法体中，对外暴露方法名。</p>
<p>优势：提高代码重用性，隐藏了实现细节。</p>
<p>调用函数的语法：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> 函数名(实参列表) [<span class="hljs-keyword">from</span> 表名...]<br></code></pre></td></tr></table></figure>

<p>函数根据作用对象的个数不同，可以分为<strong>单行函数</strong>和<strong>分组函数</strong>。</p>
<p><strong>单行函数</strong></p>
<ul>
<li><p>字符函数</p>
<ul>
<li><code>length</code>：求参数的字节个数，比如一个汉字三个字节</li>
<li><code>concat</code>：字符拼接，只要有一个为null，则结果为null</li>
<li><code>substr</code>：截取子串。sql中的索引是从1开始的</li>
<li><code>instr</code>：返回子串第一次出现的索引</li>
<li><code>trim</code>：去除首尾指定的空格和字符</li>
<li><code>upper</code>：转换成大写</li>
<li><code>lower</code>：转换成小写</li>
<li><code>lpad</code>：左填充</li>
<li><code>rpad</code>：右填充</li>
<li><code>replace(str,a,b)</code>：将str中的a替换成b</li>
</ul>
<p>案例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#截取从指定索引处指定字符长度的字符(不是字节长度)</span><br><span class="hljs-function">SELECT <span class="hljs-title">SUBSTR</span>(<span class="hljs-params"><span class="hljs-string">&#x27;你好，MySQL&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span></span>) out_put</span>;   <span class="hljs-meta"># 你好</span><br><br><span class="hljs-function">SELECT <span class="hljs-title">LENGTH</span>(<span class="hljs-params">TRIM(<span class="hljs-string">&#x27;    张 翠 山    &#x27;</span></span>)) AS out_put</span>; <span class="hljs-meta"># 11</span><br><span class="hljs-meta"># trim只能去除首尾的空格，length求得是字节的个数</span><br></code></pre></td></tr></table></figure></li>
<li><p>数学函数</p>
<ul>
<li><code>round</code>：四舍五入</li>
<li><code>rand</code>：返回一个[0,1)之间的随机数</li>
<li><code>ceil</code>：向上取整，返回&gt;=该参数的最小整数</li>
<li><code>floor</code>：向下取整，返回&lt;=该参数的最大整数</li>
<li><code>truncate</code>：截断（直接截断，不会四舍五入），保留小数点后的n位</li>
<li><code>mod</code>：取余</li>
</ul>
<p>案例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> ROUND(-<span class="hljs-number">1</span>.<span class="hljs-number">55</span>); #-<span class="hljs-number">2</span><br><span class="hljs-attribute">SELECT</span> CEIL(-<span class="hljs-number">1</span>.<span class="hljs-number">02</span>);  #-<span class="hljs-number">1</span><br><span class="hljs-attribute">SELECT</span> FLOOR(-<span class="hljs-number">9</span>.<span class="hljs-number">99</span>);  #-<span class="hljs-number">10</span><br><span class="hljs-attribute">SELECT</span> TRUNCATE(<span class="hljs-number">1</span>.<span class="hljs-number">69999</span>,<span class="hljs-number">1</span>); # <span class="hljs-number">1</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li>
<li><p>日期函数</p>
<ul>
<li><code>now</code>：返回当前系统日期+时间</li>
<li><code>curdate</code>：返回当前系统日期，不包含时间</li>
<li><code>curtime</code>：返回当前时间，不包含日期</li>
<li><code>year</code>：获取指定日期的年份</li>
<li><code>month</code>：获取指定日期的月份</li>
<li><code>monthname</code>：获取指定日期月份的英文</li>
<li><code>day</code>：获取指定日期的日</li>
<li><code>hour</code>：获取指定日期的小时</li>
<li><code>minute</code>：获取指定日期的分钟</li>
<li><code>second</code>：获取指定日期的秒</li>
<li><code>str_to_date</code>：将字符通过指定的格式转换成日期</li>
<li><code>date_format</code>：将日期转换成字符</li>
<li><code>datediff</code>：返回两个日期相差的天数</li>
</ul>
<p>案例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> YEAR(&#x27;<span class="hljs-number">1998</span>-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&#x27;) 年;  # <span class="hljs-number">1998</span>SELECT DATE_FORMAT(NOW(),&#x27;%y年%m月%d日&#x27;) AS out_put;  # <span class="hljs-number">21</span>年<span class="hljs-number">04</span>月<span class="hljs-number">25</span>日<br></code></pre></td></tr></table></figure></li>
<li><p>流程控制函数，包括<code>if</code>和<code>case</code>函数。这里作为函数，可以用在任何地方，包括begin end里面和外面，注意和后面的<code>if</code>结构和<code>case</code>结构区分。</p>
<ul>
<li><code>if</code>函数：<code>if(条件，值1，值2)</code>，如果条件成立，返回值1，否则返回值2</li>
<li><code>case</code>函数：作为函数，其有两种用法，格式如下：</li>
</ul>
</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment">#用法1：</span><br><span class="hljs-keyword">case</span> 要判断的字段或表达式<br><span class="hljs-keyword">when</span> 常量<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">1</span><br><span class="hljs-keyword">when</span> 常量<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">2</span><br>...<br><span class="hljs-keyword">else</span> 值n<br>endl;<br>    <br><span class="hljs-comment">#用法2：</span><br><span class="hljs-keyword">case</span> <br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">1</span><br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 值<span class="hljs-number">2</span><br>...<br><span class="hljs-keyword">else</span> 值n<br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>if/case结构作为函数时，可以应用在begin end结构中或外面，其返回结果必须是值；语句中不用加分号，最后结束才加分号。</p>
<p>if/case作为流程控制结构时，只能用于begin end结构中，其返回的是执行语句，中间需要加分号，且end后面要加if/case。作为流程控制结构的语法参考最后一章流程控制。</p>
</blockquote>
<p>案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-keyword">if</span><br># 例一<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">IF</span>(<span class="hljs-number">10</span>&lt;<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;大&#x27;</span>,<span class="hljs-string">&#x27;小&#x27;</span>);<br><br># 例<span class="hljs-number">2</span><br><span class="hljs-keyword">SELECT</span> <br>	last_name,<br>	commission_pct,<br>	<span class="hljs-keyword">IF</span>(commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;没奖金&#x27;</span>,<span class="hljs-string">&#x27;有奖金&#x27;</span>) 备注<br><span class="hljs-keyword">FROM</span> employees;<br><br># <span class="hljs-keyword">case</span><br># 例<span class="hljs-number">1</span><br><span class="hljs-keyword">SELECT</span> salary 原始工资,department_id,<br><span class="hljs-keyword">CASE</span> department_id<br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">30</span> <span class="hljs-keyword">THEN</span> salary*<span class="hljs-number">1.1</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">40</span> <span class="hljs-keyword">THEN</span> salary*<span class="hljs-number">1.2</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">50</span> <span class="hljs-keyword">THEN</span> salary*<span class="hljs-number">1.3</span><br><span class="hljs-keyword">ELSE</span> salary<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> 新工资<br><span class="hljs-keyword">FROM</span> employees;<br><br># 例<span class="hljs-number">2</span><br><span class="hljs-keyword">SELECT</span> salary,<br><span class="hljs-keyword">CASE</span> <br><span class="hljs-keyword">WHEN</span> salary&gt;<span class="hljs-number">20000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-keyword">WHEN</span> salary&gt;<span class="hljs-number">15000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-keyword">WHEN</span> salary&gt;<span class="hljs-number">10000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;C&#x27;</span><br><span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;D&#x27;</span><br><span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> 工资级别<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>其他</p>
<ul>
<li><code>version</code>：获取MySQL当前版本</li>
<li><code>database</code>：获取当前数据库</li>
<li><code>user</code>：获取当前用户</li>
<li><code>if null(参数,指定值)</code>：如果参数值为<code>null</code>，则返回指定值，否则返回参数的值</li>
<li><code>is null(参数)</code>：判断字段或表达式是否为<code>null</code>，如果是，返回1，否则返回0</li>
<li><code>password(&quot;str&quot;)</code>：返回str的密码形式</li>
<li><code>md5(&quot;str&quot;)</code>：返回str的MD5形式</li>
</ul>
<p>案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> VERSION();<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DATABASE</span>();<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">USER</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>分组函数</strong></p>
<ul>
<li><code>sum</code>：求和。一般用于处理数值</li>
<li><code>max</code> ：最大值</li>
<li><code>min</code>： 最小值</li>
<li><code>avg</code>：平均值。一般用于处理数值</li>
<li><code>count</code>：计数。参数可以是<code>字段</code>、<code>*</code>、<code>常量值（一般用1）</code>，<code>*</code>表示所有字段同时考虑，一般用来统计行数。常量值也能用来统计行数。</li>
</ul>
<blockquote>
<p>1.、以上五个分组函数都忽略<code>null</code>值，除了<code>count(*)</code>，因为主键一定不为空<br>2、max、min、count可以处理任何数据类型。<br>3、都可以搭配distinct使用，用于统计去重后的结果</p>
<p>4、MYISAM存储引擎下 ，<code>COUNT(*)</code>的效率高；INNODB存储引擎下，<code>COUNT(*)</code>和<code>COUNT(1)</code>的效率差不多，比COUNT(字段)要高一些。</p>
</blockquote>
<p>和分组函数同时查询的字段，必须是group by后的字段，不然会出现错误结果。</p>
<p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(salary) <span class="hljs-keyword">FROM</span> employees;<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees;# 与<span class="hljs-keyword">distinct</span>搭配使用<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> salary),<span class="hljs-built_in">COUNT</span>(salary) <span class="hljs-keyword">FROM</span> employees;  # <span class="hljs-number">57</span>,<span class="hljs-number">107</span># 和分组函数一同查询的字段有限制# 下面这种，employee_id是无意义的，只有<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>后的字段才能和分组函数一起查询<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary),employee_id  <span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure>

<h2 id="5、分组查询"><a href="#5、分组查询" class="headerlink" title="5、分组查询"></a>5、分组查询</h2><p>语法：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表[<span class="hljs-keyword">where</span> 筛选条件]<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组的字段  # 使用<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>进行分组[<span class="hljs-keyword">having</span> 条件语句];<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>1、和分组函数一同查询的字段必须是group by后出现的字段，确保意义正确</p>
<p>2、筛选分为两类：分组前筛选(where)和分组后(having)筛选。having后面一般跟的分组函数，表示对初步筛选后的结果再进行筛选。</p>
<p>3、分组可以按单个字段也可以按多个字段。</p>
<p>4、可以搭配排序使用。</p>
<p>5、having 和group by后，mysql支持别名，Oracle不支持。一般也不使用。</p>
<p>6、having后面的条件一般是分组函数，如果是一般的字段，必须是select中的字段（自己实验得出）。规范来说，having必须是在使用group by语句之后才能使用，如果不是在group by后面，having的作用和where的作用相同，但是不建议这么做，最好按照规范来做。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">MySQL 5.7版本，出现以下结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> salary&gt;<span class="hljs-number">15000</span>; # 输出正确结果<br><br><span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary&gt;<span class="hljs-number">15000</span>; # 输出正确结果<br>#－－－－－－－－－－－－－－－－－－<br><span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">HAVING</span> salary&gt;<span class="hljs-number">15000</span>; # 输出正确结果<br><br>#如果<span class="hljs-keyword">having</span>后的字段，没在<span class="hljs-keyword">select</span>中，会报错<br><span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">HAVING</span> salary&gt;<span class="hljs-number">15000</span>; # 显示语法错误，原因是‘<span class="hljs-keyword">having</span> clause’中没有salary列<br></code></pre></td></tr></table></figure>

<p><strong><code>where</code>和<code>having</code>的区别：</strong></p>
<ul>
<li>where是分组前进行筛选，是对原始表筛选；having是在分组后筛选，是对分组后的结果再进行筛选，一般的筛选条件是分组函数。可以根据代码执行顺序进行推断。</li>
<li>在语句格式上，where写在group by 前面，having写在group by后面。</li>
</ul>
<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询每个工种的员工平均工资<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary),job_id  #和分组函数同时查询的字段，是用于分组的字段<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id;<br><br>#案例2：查询邮箱中包含a字符的每个部门的最高工资<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary),department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br><br>#案例3：查询哪个部门的员工个数&gt;5<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*),department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id  # 先查询每个部门员工个数<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(*)&gt;<span class="hljs-number">5</span>;  # 然后选出个数&gt;5的<br><br>#案例4：查询每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序<br><span class="hljs-keyword">SELECT</span> job_id,<span class="hljs-built_in">MAX</span>(salary) m<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<br><span class="hljs-keyword">HAVING</span> m&gt;<span class="hljs-number">6000</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> m;<br><br>#按多个字段分组<br>#案例5：查询每个查询每个工种每个部门的平均工资<br><span class="hljs-keyword">SELECT</span> department_id, job_id,<span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id,job_id; # 顺序可以颠倒<br># 这两种写法等价，每个A，每个B和每个B，每个A结果相同。<br><span class="hljs-keyword">SELECT</span> department_id, job_id,<span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id,department_id;<br></code></pre></td></tr></table></figure>

<h2 id="6、多表连接查询"><a href="#6、多表连接查询" class="headerlink" title="6、多表连接查询"></a>6、多表连接查询</h2><p>当查询的字段来自多个表时，就需要使用连接查询。</p>
<p>如果不使用连接条件，或者连接条件无效，则多个表会按照笛卡儿乘积的形式连接，即查询的结果为m*n的表。</p>
<p>解决这种现象就需要添加有效的连接条件。</p>
<p>连接方式按照功能分类：</p>
<ul>
<li>内连接<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
<li>外连接。<ul>
<li>左外连接，left join左边是主表</li>
<li>右外连接，right join右边是主表</li>
<li>全外连接</li>
</ul>
</li>
<li>交叉连接</li>
</ul>
<p>其中，SQL 92标准仅支持内连接，ORACLE和SQL Server支持一部分外连接（mysql不支持），SQL 99标准支持内连接+外连接+交叉连接(mysql不支持全外连接)。</p>
<p>下面以两个表连接为例，说明连接查询的语法格式。</p>
<p><strong>内连接</strong></p>
<p>等值连接</p>
<p>等值内连接的结果是多表的交集。n表连接，至少需要n-1个连接条件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">SQL</span> <span class="hljs-number">92</span>语法<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名，表<span class="hljs-number">2</span> 别名<span class="hljs-keyword">where</span> 表<span class="hljs-number">1.</span>字段<span class="hljs-operator">=</span> 表<span class="hljs-number">2.</span>字段   # 连接条件 [<span class="hljs-keyword">and</span> 筛选条件]其他结构...# <span class="hljs-keyword">SQL</span> <span class="hljs-number">99</span>语法<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名[<span class="hljs-keyword">inner</span>] <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名<span class="hljs-keyword">on</span> 连接条件其他结构...# <span class="hljs-keyword">SQL</span> <span class="hljs-number">99</span>语法将筛选条件和连接条件分离，便于阅读<br></code></pre></td></tr></table></figure>

<p>非等值连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">SQL</span> <span class="hljs-number">92</span><span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名，表<span class="hljs-number">2</span>, 别名...<span class="hljs-keyword">where</span> 非等值连接条件[<span class="hljs-keyword">and</span> 筛选条件]其他结构...# <span class="hljs-keyword">SQL</span> <span class="hljs-number">99</span><span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名[<span class="hljs-keyword">inner</span>] <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名<span class="hljs-keyword">on</span> 非等值连接条件其他结构...<br></code></pre></td></tr></table></figure>

<p>自连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 自连接是指同一张表自己和自己连接。#将同一张表看作两个表，起两个别名。# <span class="hljs-keyword">SQL</span> <span class="hljs-number">92</span><span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表 别名<span class="hljs-number">1</span>,表 别名<span class="hljs-number">2</span><span class="hljs-keyword">where</span> 连接条件[<span class="hljs-keyword">and</span> 筛选条件]其他结构...# <span class="hljs-keyword">SQL</span> <span class="hljs-number">99</span>语法<span class="hljs-keyword">select</span> 查询列表<span class="hljs-keyword">from</span> 表 别名<span class="hljs-number">1</span>[<span class="hljs-keyword">inner</span>] <span class="hljs-keyword">join</span> 表 别名<span class="hljs-number">2</span><span class="hljs-keyword">on</span> 连接条件其他结构...<br></code></pre></td></tr></table></figure>

<p>总结：对于内连接，SQL 92和SQL 99标准只有在连接表的方式和连接条件的位置不同，其余用法相同。SQL 99语法将连接条件写在<code>on</code>语句后面，与筛选条件分离，提高了易读性。</p>
<p>内连接案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询有奖金的每个部门的部门名、部门的领导编号，以及该部门的最低工资# SQL 92，等值连接<span class="hljs-keyword">SELECT</span> department_name,d.<span class="hljs-symbol">`manager_id`</span>,<span class="hljs-built_in">MIN</span>(salary)<span class="hljs-keyword">FROM</span> departments d,employees eWHERE d.<span class="hljs-symbol">`department_id`</span>=<span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span><span class="hljs-keyword">AND</span> commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> NULLGROUP <span class="hljs-keyword">BY</span> department_name,d.<span class="hljs-symbol">`manager_id`</span>;# SQL 99，等值连接<span class="hljs-keyword">SELECT</span> d.department_name,d.manager_id,<span class="hljs-built_in">MIN</span>(salary)<span class="hljs-keyword">FROM</span> employees <span class="hljs-built_in">e</span> <span class="hljs-keyword">JOIN</span> departments dON <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span> = d.<span class="hljs-symbol">`department_id`</span><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`commission_pct`</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> NULLGROUP <span class="hljs-keyword">BY</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span>;#案例2：查询员工的工资和工资级别# SQL 92，非等值连接<span class="hljs-keyword">SELECT</span> salary,grade_levelFROM employees <span class="hljs-built_in">e</span>,job_grades gWHERE salary <span class="hljs-keyword">BETWEEN</span> g.<span class="hljs-symbol">`lowest_sal`</span> <span class="hljs-keyword">AND</span> g.<span class="hljs-symbol">`highest_sal`</span>;# SQL 99，非等值连接<span class="hljs-keyword">SELECT</span> salary,grade_levelFROM employees eJOIN job_grades g <span class="hljs-keyword">ON</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`salary`</span> <span class="hljs-keyword">BETWEEN</span> g.<span class="hljs-symbol">`lowest_sal`</span> <span class="hljs-keyword">AND</span> g.<span class="hljs-symbol">`highest_sal`</span>;#案例3：查询员工名和上级的名称# SQL 92，自连接<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">e</span>.last_name,m.last_nameFROM employees <span class="hljs-built_in">e</span>,employees mWHERE <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`manager_id`</span>=m.<span class="hljs-symbol">`employee_id`</span>;# SQL 99，自连接<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">e</span>.last_name,m.last_nameFROM employees eJOIN employees mON <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`manager_id`</span>= m.<span class="hljs-symbol">`employee_id`</span>;<br></code></pre></td></tr></table></figure>

<p><strong>外连接</strong></p>
<p>外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的，则显示匹配的值，如果从表中没有和它匹配的，则从表的结果显示<code>null</code>。外连接查询结果=内连接结果+主表中有，从表没有的记录。</p>
<p>外连接的特性决定了其应用场景为一般<strong>用于查询两个表交集以外的部分</strong>。即用于查询一个表中有，另一个表没有的记录。</p>
<p>左外连接和右外连接交换两个表的顺序，可以实现同样的效果 。</p>
<p>全外连接=内连接的结果+表1有，表2没有+表2有，表1没有。</p>
<p>交叉连接可以省略连接条件，其结果是笛卡尔积。</p>
<p>MySQL中只有SQL 99支持外连接（但不支持全外连接），只介绍SQL 99，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 语法：<span class="hljs-keyword">select</span> 查询内容<span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span><span class="hljs-keyword">left</span> [<span class="hljs-keyword">outer</span>]<span class="hljs-operator">|</span><span class="hljs-keyword">right</span> [<span class="hljs-keyword">outer</span>]<span class="hljs-operator">|</span><span class="hljs-keyword">full</span> [<span class="hljs-keyword">outer</span>]<span class="hljs-operator">|</span><span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">on</span> 连接条件其他结构...;#<span class="hljs-keyword">outer</span>可以省略<br></code></pre></td></tr></table></figure>

<p>外连接案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询哪个部门没有员工#左外<span class="hljs-keyword">SELECT</span> d.*,<span class="hljs-built_in">e</span>.employee_idFROM departments dLEFT <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> employees eON d.<span class="hljs-symbol">`department_id`</span> = <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`employee_id`</span> <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>; #右外,调换两个表的顺序后使用右外连接，和上面写法等价 <span class="hljs-keyword">SELECT</span> d.*,<span class="hljs-built_in">e</span>.employee_idFROM employees eRIGHT <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> departments dON d.<span class="hljs-symbol">`department_id`</span> = <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`employee_id`</span> <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>以集合关系来理解内连接和外连接：</p>
<p><a href="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_7.png"><img src="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/mysql-basis_7.png" alt="img"></a></p>
<h2 id="7、子查询"><a href="#7、子查询" class="headerlink" title="7、子查询"></a>7、子查询</h2><p>嵌套在其他语句内部的select语句称为<strong>子查询</strong>或<strong>内查询</strong>。外面的语句可以是insert、update、delete、select等，一般为select语句较多。</p>
<p>如果外面的语句是select语句，则称其为<strong>主查询</strong>或<strong>外查询</strong>。</p>
<p>子查询根据位置的不同和结果集的不同可以有以下分类。</p>
<p><strong>按子查询出现的位置分类</strong>：</p>
<ul>
<li><code>select</code>后面：仅支持标量子查询</li>
<li><code>from</code>后面：表子查询</li>
<li><code>where</code>或<code>having</code>后面(常用)：标量子查询、列子查询、行子查询</li>
<li><code>exists</code>后面（相关子查询）：均可。<code>exists</code>返回结果0或1，可以用<code>in</code>代替</li>
</ul>
<p><strong>按结果集的行列数不同分类</strong>：</p>
<ul>
<li>标量子查询（结果集只有一行一列）</li>
<li>列子查询（结果集只有一列多行）</li>
<li>行子查询（结果集一行多列）</li>
<li>表子查询（又称嵌套子查询。结果集一般为多行多列,一或多都可）</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>子查询放在小括号内。</li>
<li>子查询一般放在条件的右侧。</li>
<li>子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果。</li>
<li>标量、单行子查询，一般搭配着<strong>单行操作符</strong>使用：<code>&lt;</code>，<code>&gt;</code>，<code>=</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>&lt;&gt;</code></li>
<li>多行子查询，一般搭配着<strong>多行操作符</strong>使用：<code>in/not in</code>、<code>any|some</code>、<code>all</code></li>
</ul>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">in/<span class="hljs-literal">not</span> in`表示等于/不等于列表中的**任意一个**，例：`xxx in ()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><code>any|some</code>表示和子查询返回的<strong>某一个值</strong>进行比较（只要有一个满足即可），例：<code>xxx &gt;any();</code>。大于<code>any|some</code>等价于大于最小值，小于<code>any|some</code>等价于小于最大值。<code>any|some</code>一般很少使用。</p>
<p><code>all</code>表示和子查询返回的<strong>所有值</strong>进行比较。</p>
<p><strong>相关子查询和嵌套子查询对比</strong></p>
<p><strong>嵌套子查询</strong>的执行<strong>不依赖于外部的查询</strong>。其执行过程为：</p>
<ul>
<li>执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。</li>
<li>执行外部查询，并显示整个结果。</li>
</ul>
<p><strong>相关子查询</strong>的执行<strong>依赖于外部查询</strong>。多数情况下是子查询的WHERE子句中引用了外部查询的表。其执行过程为：</p>
<ul>
<li>从外层查询中取出一个元组，将元组相关列的值传给内层查询。</li>
<li>执行内层查询，得到子查询操作的值。</li>
<li>外查询根据子查询返回的结果或结果集得到满足条件的行。</li>
<li>然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。</li>
</ul>
<p>比如下面的例子：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># 嵌套子查询# 查询工资大于平均工资的员工信息<span class="hljs-comment">/*平均工资是子查询，其不依赖于外查询*/</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employeesWHERE salary&gt;( 	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees);# 相关子查询# 查询每个部门的员工数量和部门信息<span class="hljs-comment">/*可以使用子查询的方式，也可以使用外连接+分组查询的方式。查询员工数量时，需要将子查询和父查询根据部门id关联起来，先统计一个部门的数量，然后继续统计下一个部门数量,子查询和父查询二者交替执行*/</span><span class="hljs-keyword">SELECT</span> d.*,(	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">FROM</span> employees <span class="hljs-built_in">e</span>	<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span>=d.<span class="hljs-symbol">`department_id`</span>	) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;NUMBER&#x27;</span><span class="hljs-keyword">FROM</span> departments d;# exist也是相关子查询。能用exist的，也能使用in代替# 查询有员工的部门名<span class="hljs-keyword">SELECT</span> department_nameFROM departments dWHERE <span class="hljs-keyword">EXISTS</span>(	<span class="hljs-keyword">SELECT</span> *   	<span class="hljs-keyword">FROM</span> employees <span class="hljs-built_in">e</span>	<span class="hljs-keyword">WHERE</span> d.<span class="hljs-symbol">`department_id`</span>=<span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span>);<br></code></pre></td></tr></table></figure>

<p>子查询案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># -------------用在where和having后使用子查询------------#案例1：查询最低工资大于50号部门最低工资的 部门id 和 其最低工资<span class="hljs-comment">/*思路：1.先查出50号部门的最低工资2.然后查出每个部门的最低工资，3.根据前两步的结果筛选出最低工资大于50号部门最低工资的部门信息*/</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary),department_idFROM employeesGROUP <span class="hljs-keyword">BY</span> department_idHAVING <span class="hljs-built_in">MIN</span>(salary)&gt;(	<span class="hljs-keyword">SELECT</span>  <span class="hljs-built_in">MIN</span>(salary)	<span class="hljs-keyword">FROM</span> employees	<span class="hljs-keyword">WHERE</span> department_id = <span class="hljs-number">50</span>);#案例2：查询其它工种中，比‘IT_PROG’工种任一工资低的员工的 员工号、工种和薪资<span class="hljs-comment">/*思路：1.查询‘IT_PROG’部门的任一工资2.查询员工信息，salary&lt;1的结果*/</span><span class="hljs-keyword">SELECT</span> employee_id,job_id,salaryFROM employeesWHERE salary&lt;<span class="hljs-keyword">ANY</span>(	<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> salary	<span class="hljs-keyword">FROM</span> employees	<span class="hljs-keyword">WHERE</span> job_id = <span class="hljs-string">&#x27;IT_PROG&#x27;</span>) <span class="hljs-keyword">AND</span> job_id&lt;&gt;<span class="hljs-string">&#x27;IT_PROG&#x27;</span>;# 小于any，只要比最大值小就可以，因此可以不用anySELECT employee_id,job_id,salaryFROM employeesWHERE salary&lt;(	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) 	<span class="hljs-keyword">FROM</span> employees	<span class="hljs-keyword">WHERE</span> job_id = <span class="hljs-string">&#x27;IT_PROG&#x27;</span>) <span class="hljs-keyword">AND</span> job_id&lt;&gt;<span class="hljs-string">&#x27;IT_PROG&#x27;</span>;# -------------用在<span class="hljs-keyword">select</span>后使用子查询------------#案例：查询每个部门的员工个数和部门信息<span class="hljs-keyword">SELECT</span> d.*,(	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*)	<span class="hljs-keyword">FROM</span> employees <span class="hljs-built_in">e</span>	<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.department_id = d.<span class="hljs-symbol">`department_id`</span> ) 个数 <span class="hljs-keyword">FROM</span> departments d; # -------------用在from后使用子查询------------# from后面的子查询结果作为一张表，必须起别名# 案例：查询每个部门的平均工资的工资等级<span class="hljs-comment">/*思路：1.使用子查询，查询每个部门的平均工资2.根据平均工资查找工资等级*/</span><span class="hljs-keyword">SELECT</span>  ag_dep.*,g.<span class="hljs-symbol">`grade_level`</span><span class="hljs-keyword">FROM</span> (	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) ag,department_id	<span class="hljs-keyword">FROM</span> employees	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id) ag_depINNER <span class="hljs-keyword">JOIN</span> job_grades gON ag_dep.ag <span class="hljs-keyword">BETWEEN</span> lowest_sal <span class="hljs-keyword">AND</span> highest_sal;# -------------用在exists后使用子查询------------# 查询有员工的部门名# 使用 inSELECT department_nameFROM departments dWHERE d.`department_id` IN(	<span class="hljs-keyword">SELECT</span> department_id	<span class="hljs-keyword">FROM</span> employees);# 使用外连接<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_nameFROM departments dINNER <span class="hljs-keyword">JOIN</span> employees eON d.<span class="hljs-symbol">`department_id`</span>=<span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`employee_id`</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;# 使用existsSELECT department_nameFROM departments dWHERE EXISTS(	<span class="hljs-keyword">SELECT</span> *	<span class="hljs-keyword">FROM</span> employees <span class="hljs-built_in">e</span>	<span class="hljs-keyword">WHERE</span> d.<span class="hljs-symbol">`department_id`</span>=<span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span>);<br></code></pre></td></tr></table></figure>

<h2 id="8、分页查询"><a href="#8、分页查询" class="headerlink" title="8、分页查询"></a>8、分页查询</h2><p>如果想要显示查询结果中的一部分，就需要使用分页查询，使用<code>limit</code>限制返回的结果开始位置和条数。</p>
<p>分页查询通常用于实际web项目中，根据用户需求提交对应页数的查询结果。</p>
<p>语法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> 查询内容<span class="hljs-keyword">from</span> 表[<span class="hljs-keyword">where</span> 条件][<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段][<span class="hljs-keyword">having</span> 条件][<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段]<span class="hljs-keyword">limit</span> [偏移量,] 条目数;  # 使用<span class="hljs-keyword">limit</span>语句进行分页<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>偏移量从0开始，可以省略，默认为0，理解为索引-1。偏移量为0表示从第一条开始</li>
<li><code>limit</code>子句放在查询语句的最后。</li>
</ul>
<p>如果每页显示条目数为<code>sizePage</code>，当前页数为<code>page</code>，则查询语句为：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表<span class="hljs-keyword">limit</span> (page<span class="hljs-number">-1</span>)*sizePage,sizePage;<br></code></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">#案例1：查询第11条到第25条信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span>  employees <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>,<span class="hljs-number">15</span>;#案例2：查询有奖金的员工中，工资较高的前10名员工信息<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p><strong>子查询经典案例，使用排序和分页组合求最值</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># 1.查询工资最低的员工姓名和工资<span class="hljs-keyword">SELECT</span> last_name,salaryFROM employeesWHERE salary = ( # 先使用子查询查找最低工资	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-keyword">FROM</span> employees);# 2.查询平均工资最低的部门信息<span class="hljs-comment">/*思路：1.先查询每个部门的平均工资2.筛选出平均工资中最低的部门3.根据上一步的结果，查询出部门信息*/</span># 方式一：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> departments d # d.根据id，查询部门信息<span class="hljs-keyword">WHERE</span> d.<span class="hljs-symbol">`department_id`</span> = (	<span class="hljs-keyword">SELECT</span> department_id # c.找出平均工资为最低平均工资的部门id	<span class="hljs-keyword">FROM</span> employees	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id	<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary)=    ( 		<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(ag.a_s) # b.找出最低的平均工资		<span class="hljs-keyword">FROM</span>( # a.查询出每个部门的平均工资和id			<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) a_s,department_id             <span class="hljs-keyword">FROM</span> employees			<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id			) <span class="hljs-keyword">AS</span> ag	));# 方式二，使用limit，求出平均工资以后进行排序，就可以直接选出部门idSELECT * FROM departments dWHERE d.`department_id`= (	<span class="hljs-keyword">SELECT</span> department_id 	<span class="hljs-keyword">FROM</span> employees	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id	<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">AVG</span>(salary)	<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>   # 递增排序中的第一条就是要查询的部门);# 3.各个部门中 最高工资最低的部门的最低工资是多少<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-keyword">FROM</span> employeesWHERE department_id = ( # 子查询将排序和分页组合找出最值	<span class="hljs-keyword">SELECT</span> department_id     <span class="hljs-keyword">FROM</span> employees	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id	<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">MAX</span>(salary) 	<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>);# 4.查询平均工资最高的部门的manager信息<span class="hljs-keyword">SELECT</span> last_name,department_id,email,salaryFROM employeesWHERE employee_id=( # b,根据部门id找出管理者id	<span class="hljs-keyword">SELECT</span> manager_id <span class="hljs-keyword">FROM</span> departments	<span class="hljs-keyword">WHERE</span> department_id =     (  # a,找出平均工资最高的部门id		<span class="hljs-keyword">SELECT</span> department_id <span class="hljs-keyword">FROM</span> employees		<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id		<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">DESC</span>		<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>	));<br></code></pre></td></tr></table></figure>

<h2 id="9、联合查询"><a href="#9、联合查询" class="headerlink" title="9、联合查询"></a>9、联合查询</h2><p>如果要查询的结果<strong>来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</strong>，可以使用<strong>联合查询</strong>。联合查询使用<code>union</code>将多次的查询结果合并成一个结果。</p>
<p>语法：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q"># 使用<span class="hljs-built_in">union</span>将多个查询语句合并<span class="hljs-keyword">select</span> xxxunion [<span class="hljs-built_in">all</span>]<span class="hljs-keyword">select</span> xxxunion [<span class="hljs-built_in">all</span>].....<span class="hljs-keyword">select</span> xxx<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>要求多条查询语句的查询的<strong>列数必须一致</strong></li>
<li>多条查询语句的查询的列的类型和含义尽量相同</li>
<li><code>union</code>默认去重，<code>union all</code>代表不去重</li>
</ul>
<p><strong><code>join</code>和<code>union</code>的区别</strong></p>
<ul>
<li><code>join</code>用于外连接，是根据一定的<strong>连接条件</strong>将两张表连接，并生成连接后的结果表，连接条件是<code>on</code>后面的条件。连接包括左外连接、右外连接、全连接和交叉连接。</li>
<li><code>union</code>表示联合查询，是将两个查询结果合并在一起，不需要进行表的连接。<code>union</code>连接的查询语句查询的字段个数必须一致。<code>union</code>默认去重，可以使用<code>all</code>保留全部结果。</li>
</ul>
<h1 id="六、DML语言"><a href="#六、DML语言" class="headerlink" title="六、DML语言"></a>六、DML语言</h1><p>DML指数据操作语言。</p>
<p>主要是对表格的添加（insert）、删除（delete）、修改（update）操作。</p>
<h2 id="1、insert"><a href="#1、insert" class="headerlink" title="1、insert"></a>1、insert</h2><p>向表格中插入数据有两种方式：</p>
<p><strong>方式一</strong>：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">insert</span> into 表名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>,...) values(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...);<br></code></pre></td></tr></table></figure>

<p>要求：</p>
<ul>
<li>字段类型和值类型必须一致或兼容，字段和值的顺序可以和表中不一致，但是字段和值必须一一对应。</li>
<li>可以为空的字段，如果要插入<code>null</code>值，有两种方式：①字段和值都省略，此时值默认为<code>null</code>；②字段和值都写，值为<code>null</code>。</li>
<li>不可以为空的字段，必须插入值。</li>
<li>字段个数和值的个数必须一致。</li>
<li>字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致。</li>
</ul>
<p><strong>方式二</strong>：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">insert into 表名<span class="hljs-builtin-name">set</span> 列名<span class="hljs-attribute">1</span>=值,列名2=值,...;<br></code></pre></td></tr></table></figure>

<p>两种方式的对比：</p>
<ul>
<li><p>方式一支持插入多行，方式二不支持：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(employee_id,last_name,salary)<span class="hljs-keyword">values</span>(<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;john&#x27;</span>,<span class="hljs-string">&#x27;15000&#x27;</span>),<span class="hljs-keyword">values</span>(<span class="hljs-number">124</span>,<span class="hljs-string">&#x27;jerry&#x27;</span>,<span class="hljs-string">&#x27;12000&#x27;</span>),<span class="hljs-keyword">values</span>(<span class="hljs-number">125</span>,<span class="hljs-string">&#x27;mickey&#x27;</span>,<span class="hljs-string">&#x27;11000&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>方式一支持子查询，方式二不支持：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 查询标量<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(employee_id,last_name,salary)<span class="hljs-keyword">SELECT</span> <span class="hljs-number">123</span>,<span class="hljs-string">&#x27;john&#x27;</span>,<span class="hljs-string">&#x27;15000&#x27;</span>;# 从表<span class="hljs-number">2</span>中查询到的结果插入表<span class="hljs-number">1</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(employee_id,last_name,salary)<span class="hljs-keyword">SELECT</span> id,name,salaryFROM employees <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">3</span>; <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、update"><a href="#2、update" class="headerlink" title="2、update"></a>2、update</h2><p><strong>修改单表的记录</strong>：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q"><span class="hljs-keyword">update</span> 表名 <span class="hljs-built_in">set</span> 字段=新值,字段=新值...[<span class="hljs-built_in">where</span> 条件];# 案例# 将<span class="hljs-number">90</span>号部门的员工工资修改为<span class="hljs-number">15000</span><span class="hljs-keyword">update</span> employeesset salary=<span class="hljs-number">15000</span><span class="hljs-built_in">where</span> department_id90;<br></code></pre></td></tr></table></figure>

<p><strong>修改多表记录</strong>：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># SQL 92语法<br><span class="hljs-keyword">update</span> 表<span class="hljs-number">1</span> 别名<span class="hljs-number">1</span>,表<span class="hljs-number">2</span> 别名<span class="hljs-number">2</span><br><span class="hljs-keyword">set</span> 字段=新值，字段=新值...<br><span class="hljs-keyword">where</span> 连接条件<br>[<span class="hljs-keyword">and</span> 筛选条件];<br><br># SQL 99语法，唯一不同的就是连接表的方式不同。其余相同<br><span class="hljs-keyword">update</span> 表<span class="hljs-number">1</span> 别名<br>[<span class="hljs-keyword">inner</span>]|<span class="hljs-keyword">left</span> [<span class="hljs-keyword">outer</span>]|<span class="hljs-keyword">right</span> [<span class="hljs-keyword">outer</span>] <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名<br><span class="hljs-keyword">on</span> 连接条件<br><span class="hljs-keyword">set</span> 列=值,...<br>[<span class="hljs-keyword">where</span> 筛选条件];<br></code></pre></td></tr></table></figure>

<h2 id="3、delete"><a href="#3、delete" class="headerlink" title="3、delete"></a>3、delete</h2><p>delete表示删除表中的一条或多条记录（一行或多行），有两种方式</p>
<p><strong>方式1，使用delete</strong></p>
<p>单表的删除：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <br>[<span class="hljs-keyword">where</span> 筛选条件]<br>[<span class="hljs-keyword">limit</span> 条目数]<br></code></pre></td></tr></table></figure>

<p>一般会使用<code>where</code>筛选特定的记录删除，如果没有筛选条件，会删除所有的记录。</p>
<p>可以使用<code>limit</code>限定删除的条数，只能用一个参数，表示删除查询结果的前几条。</p>
<p>多表的删除（级联删除）：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 同样地，也分为两种标准的语句，仅仅是连接表的时候不同，其余语句完全相同。</span><br><span class="hljs-comment"># 以SQL 92为例</span><br><span class="hljs-attribute">delete</span> 别名<span class="hljs-number">1</span>，别名<span class="hljs-number">2</span><br><span class="hljs-attribute">from</span> 表<span class="hljs-number">1</span> 别名<span class="hljs-number">1</span>，表<span class="hljs-number">2</span> 别名<span class="hljs-number">2</span><br><span class="hljs-attribute">where</span> 连接条件<span class="hljs-meta"></span><br><span class="hljs-meta">[and 筛选条件];</span><br></code></pre></td></tr></table></figure>

<p><strong>方式2，使用truncate</strong>：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名;<br></code></pre></td></tr></table></figure>

<p><code>delete</code>和<code>truncate</code>两种方式删除记录的区别（详细对比可以参考<a href="https://kangshitao.github.io/2021/04/26/mysql-basis/#refer1">下文</a>）：</p>
<ul>
<li><code>truncate</code>不能加<code>where</code>条件，而<code>delete</code>可以加<code>where</code>条件，意味着<code>truncate</code>会删除表中的所有记录。</li>
<li><code>truncate</code>的效率稍高。</li>
<li><code>truncate</code> 删除带自增长的列的表后，如果再插入数据，数据从1开始，<code>delete</code> 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始</li>
<li><code>truncate</code>删除没有返回值，<code>delete</code>删除有返回值</li>
<li><code>truncate</code>属于DDL语言，删除不能回滚，<code>delete</code>是DML语言，支持事务，可以回滚</li>
</ul>
<h1 id="七、DDL语句"><a href="#七、DDL语句" class="headerlink" title="七、DDL语句"></a>七、DDL语句</h1><p>DDL为数据定义语言。允许用户<strong>定义</strong>数据，包括创建（create）、删除（drop）、修改（alter）表和数据库，操作对象是<strong>表和数据库</strong>。通常，DDL由数据库管理员执行。</p>
<h2 id="1、create"><a href="#1、create" class="headerlink" title="1、create"></a>1、create</h2><p><strong>创建数据库</strong>：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>] 库名;<br></code></pre></td></tr></table></figure>

<p><strong>创建表</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 语法：<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> [if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>] 表名(	列名 列的类型[(长度) 约束],	列名 列的类型[(长度) 约束],	列名 列的类型[(长度) 约束],	...	列名 列的类型[(长度) 约束]);# 例：创建名为stuinfo的表，包含的列和类型如下：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> stuinfo(	stuId <span class="hljs-type">INT</span>,	stuName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),  # <span class="hljs-type">varchar</span>类型必须有长度	gender <span class="hljs-type">CHAR</span>,	bornDate DATETIME);<br></code></pre></td></tr></table></figure>

<p>创建库/表的时候，可以使用<code>if not exists</code>进行判断，如果要创建的库/表不存在，则创建，否则不会创建。不能创建名字相同的两个库/表。</p>
<p><strong>表的复制</strong></p>
<p>将<code>create</code>和<code>select</code>语句结合，可以实现表的复制：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 仅复制表的结构<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表名 <span class="hljs-keyword">like</span> 旧表<br><br># 复制表的字段和数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表名<br><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 旧表 [<span class="hljs-keyword">where</span> 筛选条件];<br><br>#仅仅复制某些字段<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表名<br><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 旧表 <span class="hljs-keyword">where</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<h2 id="2、alter"><a href="#2、alter" class="headerlink" title="2、alter"></a>2、alter</h2><p>修改库/表使用<code>alter</code>语句</p>
<p>修改数据库，一般很少对现有数据库进行修改：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#已废弃.现在需要去文件路径中重命名<br><span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">DATABASE</span> books <span class="hljs-keyword">TO</span> 新库名; <br># 更数据库字符集<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> books <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> gbk;<br></code></pre></td></tr></table></figure>

<p>修改表：</p>
<p>修改表中的字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 添加新的列，必须指定类型<br># 新列默认在表中的位置为最后，可以使用<span class="hljs-keyword">first</span>或after参数指定位置<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> 列名 类型 [约束] [<span class="hljs-keyword">first</span><span class="hljs-operator">|</span>after 列名];<br><br># 删除某列（无法使用if exist进行判断）<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 列名;<br><br># 修改列名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 change <span class="hljs-keyword">column</span> 旧列名 新列名 类型;<br><br># 修改列的类型或约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 类型 [约束];<br></code></pre></td></tr></table></figure>

<p>修改表名：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 格式：<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">rename</span> [<span class="hljs-keyword">to</span>] 新表名;<br># 案例：<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> author <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> book_author;<br></code></pre></td></tr></table></figure>

<h2 id="3、drop"><a href="#3、drop" class="headerlink" title="3、drop"></a>3、drop</h2><p>删除数据库：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>] 库名;<br></code></pre></td></tr></table></figure>

<p>删除表：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>] 表名;<br></code></pre></td></tr></table></figure>

<p>同样地，删除数据库/表的时候，可以使用<code>if exists</code>判断是否存在，避免报错。</p>
<h1 id="八、约束和标识列"><a href="#八、约束和标识列" class="headerlink" title="八、约束和标识列"></a>八、约束和标识列</h1><h2 id="1、约束"><a href="#1、约束" class="headerlink" title="1、约束"></a>1、约束</h2><p>约束指的是一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性。</p>
<p>主要有以下六大约束：</p>
<ul>
<li><code>NOT NULL</code>：非空，用于保证该字段的值不能为空。比如姓名、学号等</li>
<li><code>DEFAULT</code>：默认，用于保证该字段有默认值。比如性别</li>
<li><code>CHECK</code>：检查约束[mysql中不支持]。比如年龄、性别，检查年龄是否在某个区间内、性别是否是男或女。</li>
<li><code>PRIMARY KEY</code>：主键，用于保证该字段的值具有唯一性，并且非空。比如学号、员工编号等</li>
<li><code>UNIQUE</code>：唯一，用于保证该字段的值具有唯一性，可以为空（<code>unique key</code>可以插入多个<code>null</code>值，空值并不受唯一性约束）。比如座位号。</li>
<li><code>FOREIGN KEY</code>：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值在从表添加外键约束，用于引用主表中某列的值。比如学生表的专业编号（学生表为从表，专业表为主表），员工表的部门编号，员工表的工种编号。</li>
</ul>
<p>其中主键、外键、唯一键都是<code>key</code>，会默认生成索引。</p>
<blockquote>
<p><strong>关于key</strong></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html">MySQL文档</a>：key是索引的近义词，可以将key理解为索引。</p>
<p><a href="https://sqlrelease.com/sql-server-tutorial/types-of-keys">参考1</a>：key是表中的字段，它们参与RDBMS系统中的以下活动<br>a.表与表中数据之间的依赖关系由key建立<br>b.标识数据的唯一性。<br>c.使表的约束有效果, 进而能够保证数据都是有效的。<br>d.有可能会提升数据库表的查询效率。</p>
<p>key 包含两层意义和作用：<br>一是约束（偏重于约束和规范数据库的结构完整性）；<br>二是索引（辅助查询用）包括primary key (主键)、unique key(唯一键)、foreign key(外键) 等</p>
</blockquote>
<p>约束可以在<strong>创建表</strong>和**修改表(添加数据前)**时添加。</p>
<p>添加约束有两类：</p>
<ul>
<li>列级约束：六大约束语法上都支持，但外键约束没有效果。不可以起约束名。</li>
<li>表级约束：除了非空、默认，其他的都支持。可以起约束名（约束名对于主键没有效果，一直是primary）</li>
</ul>
<p><strong>主键和唯一键对比</strong>：</p>
<ul>
<li>主键的值是唯一的，非空，一个表中最多只能有一个主键，允许多个字段组合在一起作为主键，但不推荐。</li>
<li>唯一键的值是唯一的，但是允许值为空，一个表中可以有多个唯一键，同样允许多个字段组合在一起作为唯一键，但不推荐。</li>
</ul>
<p><strong>外键</strong>：</p>
<ul>
<li>要求在从表设置外键关系</li>
<li>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</li>
<li>主表的关联列必须是一个key（一般是主键或唯一）</li>
<li>插入数据时，先插入主表，再插入从表。删除数据时，先删除从表，再删除主表：</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#方式一：级联删除，删除主表数据时，将从表中相关的记录(整行)也删除#添加外键时，在最后添加 <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">cascade</span>。例如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stuinfo_major <span class="hljs-keyword">FOREIGN KEY</span>(majorid) <span class="hljs-keyword">REFERENCES</span> major(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span>; # 方式二：级联置空，删除主表数据时，将从表中相关的记录中对应的字段置为<span class="hljs-keyword">null</span>#添加外键时，在最后添加 <span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">null</span>。例如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stuinfo_major <span class="hljs-keyword">FOREIGN KEY</span>(majorid) <span class="hljs-keyword">REFERENCES</span> major(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>; <br></code></pre></td></tr></table></figure>

<p><strong>添加约束</strong></p>
<p>列级约束，直接在类型后添加约束名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 例如。<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(    字段名 字段类型 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,  # 非空    字段名 字段类型 <span class="hljs-keyword">primary</span> key,  # 主键    字段名 字段类型 <span class="hljs-keyword">unique</span>,  # 唯一键    字段名 字段类型 <span class="hljs-keyword">default</span>,  # 默认    ...);<br></code></pre></td></tr></table></figure>

<p>表级约束，在字段都定义完后，再为指定的列添加约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 语法：[<span class="hljs-keyword">constraint</span> 约束别名] 约束(字段名);# 例如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> stuinfo(	id <span class="hljs-type">INT</span>,	stuname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),	gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),	seat <span class="hljs-type">INT</span>,	age <span class="hljs-type">INT</span>,	majorid <span class="hljs-type">INT</span>,    	<span class="hljs-keyword">CONSTRAINT</span> pk <span class="hljs-keyword">PRIMARY</span> KEY(id),#主键	<span class="hljs-keyword">CONSTRAINT</span> uq <span class="hljs-keyword">UNIQUE</span>(seat),#唯一键	<span class="hljs-keyword">CONSTRAINT</span> ck <span class="hljs-keyword">CHECK</span>(gender <span class="hljs-operator">=</span><span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">OR</span> gender  <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>),#检查（MySQL不支持）	<span class="hljs-keyword">CONSTRAINT</span> fk_stuinfo_major <span class="hljs-keyword">FOREIGN</span> KEY(majorid) <span class="hljs-keyword">REFERENCES</span> major(id)#外键);<br></code></pre></td></tr></table></figure>

<p>如果多个字段组合作为主键或唯一键，将这几个字段都写在表级约束的括号中，逗号隔开。</p>
<p>表级约束和列级约束可以一起使用，定义外键时使用表级约束，其他约束使用列级约束即可。</p>
<p>查看表中的所有索引（主键、外键、唯一键）：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure>

<p>除了在定义表时添加约束，也可以在修改表的时候添加约束：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#<span class="hljs-number">1</span>、添加列级约束<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 字段名 字段类型 新约束;#<span class="hljs-number">2</span>、添加表级约束<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> [<span class="hljs-keyword">constraint</span> 约束名] 约束类型(字段名) [外键相关];<br></code></pre></td></tr></table></figure>

<p><strong>删除约束</strong></p>
<p>在修改表的语句中，也可以删除约束，一般的约束在类型后面不加约束就代表删除，对于<code>key</code>，则需要使用<code>drop</code>显式删除，具体如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#<span class="hljs-number">1.</span>删除非空约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> stuname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span>;#<span class="hljs-number">2.</span>删除默认约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">INT</span>;#<span class="hljs-number">3.</span>删除主键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;#<span class="hljs-number">4.</span>删除唯一键，使用删除索引的语法<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> INDEX seat;#<span class="hljs-number">5.</span>删除外键，需要先将对应的索引删除<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> INDEX fk_stuinfo_major;<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY fk_stuinfo_major;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>MySQL中直接删除外键以后，外键依然存在，需要先将同名索引删除，然后再删除外键，这样查询时就不会显示外键了。</p>
<p>删除外键的时候，同名索引如果没被删，MYSQL认为外键仍然存在，MYSQL会在show keys命令里继续显示外键，当drop table时，MYSQL会提示Can’t DROP ‘xxx’; check that column/key exists”<br>如果再次想删除外键的时候，会报1091错误，提示外键名错误，因为实际上外键已经不存在了。因此MySQL中需要先将对应的索引删除，再删除外键。</p>
</blockquote>
<h2 id="2、标识列"><a href="#2、标识列" class="headerlink" title="2、标识列"></a>2、标识列</h2><p><strong>标识列</strong>又称为<strong>自增长列</strong>，可以不用手动的插入值，系统提供默认的序列值，默认从1开始。</p>
<p><strong>格式</strong>：在key的约束后面加上<code>auto_increment</code>即可。</p>
<p><strong>用法</strong>：添加数据时，标识列可以填<code>null</code>，或者不赋值，系统都会自动在已有的基础上+1。也可以手动指定值。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>标识列不是必须和主键搭配，但要求是一个key。</li>
<li>一个表最多只能有一个标识列。</li>
<li>标识列的类型只能是数值型，一般是int型。如果是非int型，自动赋值时是整数，可以手动插入小数。</li>
<li>可以通过<code>SHOW VARIABLES LIKE &#39;%auto_increment%&#39;;</code> 查看标识列的步长和默认起始值.</li>
<li>标识列可以通过<code>SET auto_increment_increment=n</code>设置步长。mysql不支持设置起始值，但可以通过手动插入值，设置起始值。</li>
</ul>
<p><strong>使用</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 创建表时设置标识列<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tab_identity(	id <span class="hljs-type">INT</span>,	NAME <span class="hljs-type">FLOAT</span> <span class="hljs-keyword">UNIQUE</span> AUTO_INCREMENT,	seat <span class="hljs-type">INT</span> );# 修改表时设置标识列<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tab_identity MODIFY <span class="hljs-keyword">COLUMN</span> id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT;#三、修改表时删除标识列<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tab_identity MODIFY <span class="hljs-keyword">COLUMN</span> id <span class="hljs-type">INT</span>;<br></code></pre></td></tr></table></figure>

<h1 id="九、数据库事务"><a href="#九、数据库事务" class="headerlink" title="九、数据库事务"></a>九、数据库事务</h1><p><strong>TCL（Transaction Control Language）</strong>： 事务控制语言</p>
<h2 id="1、事务概述"><a href="#1、事务概述" class="headerlink" title="1、事务概述"></a>1、事务概述</h2><p><strong>事务</strong>：一个或一组SQL语句（一般是DML语句）组成的一个<strong>执行单元</strong>，这个执行单元要么全部执行，要么全部不执行。</p>
<p>DDL语句不支持事务，可以认为DDL语句执行完自动提交，因此也无法回滚。</p>
<p><strong>事务的四大特性（ACID）</strong>：</p>
<ul>
<li><strong>原子性</strong>（<strong>A</strong>tomic）：组成事务的SQL语句要么都执行，要么都不执行（回滚）。</li>
<li><strong>一致性</strong>（<strong>C</strong>onsistent）：事务完成前后，所有数据的状态都是一致的。比如A账户只要减去了100，B账户则必定加上了100。</li>
<li><strong>隔离性</strong>（<strong>I</strong>solation）：多个事务同时操作相同数据库的同一个数据时，即多个事务并发执行，每个事务作出的修改必须与其他事务隔离。</li>
<li><strong>持久性</strong>（<strong>D</strong>uration）：事务一旦提交，对数据库数据的修改被持久化到本地存储。</li>
</ul>
<p><strong>事务分类</strong>：</p>
<ul>
<li><strong>隐式事务</strong>：没有明显的开启和结束的标记，本身就是一个事务。对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。<strong>隐式事务系统会自动提交</strong>。</li>
<li><strong>显式事务</strong>：具有明显的开启和结束的标记，即手动开启事务。显式事务必须保证系统的自动提交功能被禁用，实际上，MySQL中显示开启事务时，自动提交是无效的，不需要手动设置。</li>
</ul>
<h2 id="2、事务的开启"><a href="#2、事务的开启" class="headerlink" title="2、事务的开启"></a>2、事务的开启</h2><p>一个完整的事务包括以下执行流程：开启事务→执行事务语句→提交或回滚。</p>
<p>事务的执行结果要么是提交，要么是回滚。</p>
<p><strong>步骤一：开启事务</strong></p>
<p>开启事务有两种方式，一种是关闭自动提交模式，隐式开启事务；另一种是显式开启事务，有两种显式开启事务的语法，具体如下：</p>
<p>方式一：<strong>关闭自动提交模式</strong>，之后遇到需要开启事务的sql时，会自动开启事务，相当于隐式开启事务:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">autocommit</span>=0; # 将自动提交模式关闭<br>执行语句<br></code></pre></td></tr></table></figure>

<p>方式二：<strong>显式开启事务</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 方式一：</span><br><span class="hljs-built_in">start</span> transaction;<br><br><span class="hljs-comment">#方式二：</span><br><span class="hljs-keyword">begin</span>;<br></code></pre></td></tr></table></figure>

<p><strong>步骤二：执行语句</strong></p>
<p>在这一步，可以编写执行语句，包括insert、update、delete等语句。</p>
<p>DDL语言（create、drop、truncate等）是非事务的，可以理解为事务中的DDL语言执行完后会自动提交（禁用自动提交也没用），无法回滚，影响事务其他DML操作。</p>
<p>如果事务中掺杂了DDL语句，执行完DDL语句后会自动提交，导致之前的执行语句被提交，无法回滚，因此为了安全起见，尽量将DDL和DML完全分开，便于回滚。</p>
<p><strong>步骤三：结束事务</strong></p>
<p>事务的结束有两种情况：</p>
<ul>
<li><code>commit [work]</code>：提交，表示事务的执行单元都执行了。</li>
<li><code>rollback [work]</code> ：回滚，表示事务的执行单元都没执行。</li>
</ul>
<blockquote>
<p>事务相关的其他关键字：</p>
<p><code>savepoint identifier</code>：设置一个名为identifier的保存点</p>
<p><code>release savepoint identifier</code>：删除一个事务的名为identifier的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</p>
<p><code>rollback to identifier</code> ：把事务回滚到保存点。不算真正地结束事务，仍可以使用rollback将整个事务的修改撤销，因此执行了此语句后，也需要显式运行commit或rollback命令结束事务。</p>
</blockquote>
<p>事务的使用案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#开启事务，三种均可#<span class="hljs-keyword">SET</span> autocommit=<span class="hljs-number">0</span>;#<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<span class="hljs-keyword">begin</span>;#事务执行语句<span class="hljs-keyword">UPDATE</span> employees <span class="hljs-keyword">SET</span> salary = <span class="hljs-number">17200</span> <span class="hljs-keyword">WHERE</span> username=<span class="hljs-string">&#x27;K_ing&#x27;</span>;<span class="hljs-keyword">UPDATE</span> employees <span class="hljs-keyword">SET</span> salary = <span class="hljs-number">10000</span> <span class="hljs-keyword">WHERE</span> username=<span class="hljs-string">&#x27;Marry&#x27;</span>;#结束事务，要么提交，要么回滚<span class="hljs-keyword">ROLLBACK</span>;#<span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure>

<p><strong>drop、delete、truncate三者的区别</strong>：</p>
<ul>
<li>drop用于删除整个表。</li>
<li>delete可以使用筛选条件，删除表中的一行或多行记录。并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</li>
<li>truncate table则一次性地从表中删除所有的数据，即所有行，不能使用筛选条件。并不把单独的删除操作记录记入日志保存，操作不能恢复。</li>
<li>delete是DML语言，支持事务，delete操作可以会滚；而truncate和drop是ddl语言，不支持事务，因此无法回滚。</li>
<li>truncate和delete只删除数据，drop则删除整个表，包括结构和数据。</li>
<li>delete可以激活触发器。truncate不能激活触发器。</li>
<li>当表被truncate后，这个表和索引所占用的空间会<strong>恢复到初始大小</strong>，并且标识列也从1重新开始计数；delete操作不会减少表或索引所占用的空间，标识列还是从断点处计数。drop语句将表所占用的空间全释放掉。</li>
<li>速度上：drop&gt;truncate&gt;delete</li>
</ul>
<h2 id="3、事务的隔离级别"><a href="#3、事务的隔离级别" class="headerlink" title="3、事务的隔离级别"></a>3、事务的隔离级别</h2><p>当多个事务同时操作同一个数据库的相同数据时，容易导致并发问题，包括以下问题：</p>
<p><strong>脏写（丢失修改）</strong>：一个事务修改了其他事务还没有提交的数据，如果其他事务回滚，导致当前事务的修改丢失。事务B去修改了事务A修改过的值，但是此时事务A还没提交，所以事务A随时会回滚，导致事务B修改的值也没了。<br><strong>脏读</strong>：一个事务读取到了其他事务未提交（一般指<strong>数据修改</strong>）的数据。事务B去查询了事务A修改过的数据，但是此时事务A还没提交，所以事务A随时会回滚，导致事务B再次查询就读不到刚才事务A修改的数据了。</p>
<blockquote>
<p>脏读和脏写都是因为一个事务去更新或者查询了另外一个还没提交的事务更新过的数据。因为另外一个事务还没提交，所以它随时可能会回滚，那么必然导致你更新的数据就没了，或者你之前查询到的数据就没了，这就是脏写和脏读两种场景。</p>
</blockquote>
<p><strong>不可重复读</strong>：同一个事务中，多次读取到的数据不一致，即中间有其他事务提交了修改（一般指<strong>数据修改</strong>）。事务A读取一个字段后，事务B更新了该字段并提交了，导致A再次读取的时候和之前不一致了，即无法重复读取到相同的某个值。</p>
<p><strong>幻读</strong>：一个事务多次读取数据时，中间有其他事务提交了更新操作（一般指<strong>插入或删除</strong>）的数据。比如同样的查询语句，第一次查询出n条，然后别的事务进行了插入或删除，第二次查询出m条，同样的查询语句得到的结果不一样，就像出现了幻觉。</p>
<p>可以通过设置<strong>隔离级别</strong>避免事务的并发问题，主要有以下四种隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted</td>
<td>未解决</td>
<td>未解决</td>
<td>未解决</td>
<td>允许事务读取未被其他事务提交的更改</td>
</tr>
<tr>
<td>read committed</td>
<td>解决</td>
<td>未解决</td>
<td>未解决</td>
<td>只允许事务读取已经被其它事务提交的更改。<strong>Oracle的默认隔离级别</strong></td>
</tr>
<tr>
<td>repeatable read</td>
<td>解决</td>
<td>解决</td>
<td>未解决</td>
<td>确保事务可以多次从一个字段中读取相同的值，事务持续期间，禁止其他事务对这个字段更新。<strong>MySQL的默认隔离级别</strong></td>
</tr>
<tr>
<td>serializable</td>
<td>解决</td>
<td>解决</td>
<td>解决</td>
<td>确保事务可以多次从一个表中读取相同的行，事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。可以避免所有并发问题，性能最差。</td>
</tr>
</tbody></table>
<p>上述四种隔离级别，MySQL全部支持，Oracle只支持<code>read committed</code>和<code>serializable</code>。</p>
<h2 id="4、设置隔离级别"><a href="#4、设置隔离级别" class="headerlink" title="4、设置隔离级别"></a>4、设置隔离级别</h2><p>事务的隔离级别包括<strong>全局级别</strong>和<strong>会话级别</strong>：</p>
<ul>
<li>全局级别：对后续新的所有会话连接有效，对已经存在的会话连接无效。</li>
<li>会话级别：对数据库会话连接的<strong>后续新发起或当前未提交</strong>的事务有效。如果没有session关键字的话，只对当前数据库会话连接的<strong>后续新发起</strong>的事务有效，当前未提交的事务，还是继续使用之前的事务隔离级别。</li>
</ul>
<p>设置隔离级别的语法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 设置全局隔离级别<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> 隔离级别名;# 设置当前会话连接的隔离级别<span class="hljs-keyword">set</span> [<span class="hljs-keyword">session</span>] <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> 隔离级别名;<br></code></pre></td></tr></table></figure>

<p>查看隔离级别：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#查看当前会话隔离级别</span><br><span class="hljs-keyword">select</span> @<span class="hljs-symbol">@tx_isolation</span><span class="hljs-comment">;</span><br><span class="hljs-meta">#查看全局隔离级别</span><br><span class="hljs-keyword">select</span> @<span class="hljs-symbol">@global</span>.tx_isolation<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h2 id="5、MyISAM引擎和InnoDB引擎对比"><a href="#5、MyISAM引擎和InnoDB引擎对比" class="headerlink" title="5、MyISAM引擎和InnoDB引擎对比"></a>5、MyISAM引擎和InnoDB引擎对比</h2><p>InnoDB引擎是MySQL5.5开始引入的。InnoDB和MyISAM引擎的对比：</p>
<ul>
<li><strong>是否支持行级锁</strong>。MyISAM只支持表锁，而InnoDB支持表锁和行锁，且默认为行锁。</li>
<li><strong>是否支持事务</strong>。MyISAM不支持事务，InnoDB支持事务，具有提交和回滚事务的能力。</li>
<li><strong>是否支持外键</strong>。MyISAM不支持外键，InnoDB支持外键。</li>
<li><strong>是否支持数据库异常崩溃后的安全恢复</strong>。MyISAM不支持，InnoDB支持。InnoDB引擎能够保证，在数据库异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，恢复的过程依赖于<code>redo log</code></li>
</ul>
<p>扩展：InnoDB是如何保证ACID特性的？</p>
<p>1、InnoDB引擎使用<strong>redo log(重做日志)<strong>保证事务的</strong>持久性</strong></p>
<p>2、InnoDB引擎使用<strong>undo log(回滚日志)<strong>保证事务的</strong>原子性</strong></p>
<p>3、InnoDB引擎使用<strong>锁机制</strong>、<strong>MVCC</strong>等手段保证事务的<strong>隔离性</strong></p>
<p>4、保证了上述三个特性后，<strong>一致性</strong>才得以保障。</p>
<h1 id="十、视图"><a href="#十、视图" class="headerlink" title="十、视图"></a>十、视图</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>视图是MySQL 5.1的新特性。视图是一张<strong>虚拟的表</strong>，它的数据来自于表，通过执行时动态生成。视图的用法和表相同。视图只保存了SQL逻辑，没有保存查询结果，因此其几乎不占用物理空间，视图一般仅用于查询，仅仅少数情况下才能修改数据。</p>
<p>视图的优势：</p>
<ul>
<li>提高SQL语句的重用性，简化了复杂的SQL操作，提高了效率</li>
<li>和表实现了分离，提高了安全性</li>
</ul>
<h2 id="2、创建视图"><a href="#2、创建视图" class="headerlink" title="2、创建视图"></a>2、创建视图</h2><p>创建视图：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or replace</span>] <span class="hljs-keyword">view</span> 视图名 <span class="hljs-keyword">as</span> 查询语句;# 使用<span class="hljs-keyword">or replace</span>还可以用于视图的修改<br></code></pre></td></tr></table></figure>

<p>使用案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># 使用视图，查询各部门的平均工资级别# 1.创建视图查看每个部门的平均工资<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> myview ASSELECT <span class="hljs-built_in">AVG</span>(salary) ag,department_idFROM employeesGROUP <span class="hljs-keyword">BY</span> department_id;# 2.使用创建的视图查询<span class="hljs-keyword">SELECT</span> myview.<span class="hljs-symbol">`ag`</span>,g.grade_levelFROM myviewJOIN job_grades gON myview.<span class="hljs-symbol">`ag`</span> <span class="hljs-keyword">BETWEEN</span> g.<span class="hljs-symbol">`lowest_sal`</span> <span class="hljs-keyword">AND</span> g.<span class="hljs-symbol">`highest_sal`</span>;<br></code></pre></td></tr></table></figure>

<h2 id="3、删除视图"><a href="#3、删除视图" class="headerlink" title="3、删除视图"></a>3、删除视图</h2><p>删除视图：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">drop</span> view 视图名,视图名,...;  # 可以一次删除多个视图#案例：删除myv<span class="hljs-number">1</span>，myv<span class="hljs-number">2</span>，myv<span class="hljs-number">3</span>三个视图DROP VIEW myv<span class="hljs-number">1</span>,myv<span class="hljs-number">2</span>,myv<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<h2 id="4、查看视图"><a href="#4、查看视图" class="headerlink" title="4、查看视图"></a>4、查看视图</h2><p>查看视图有两种方式：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#方式一：</span><br>DESC 视图名;<br><br><span class="hljs-meta">#方式二：</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-built_in">VIEW</span> 视图名;<br></code></pre></td></tr></table></figure>

<h2 id="5、更新视图"><a href="#5、更新视图" class="headerlink" title="5、更新视图"></a>5、更新视图</h2><p>和修改表相似，更新视图包括修改视图本身，和修改视图中的内容两部分。</p>
<p><strong>修改视图本身</strong>：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#方式一：可用于修改和创建视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or replace</span> <span class="hljs-keyword">view</span>  视图名<br><span class="hljs-keyword">as</span> 查询语句;<br><br># 方式二：<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">view</span> 视图名<br><span class="hljs-keyword">as</span> 查询语句;<br></code></pre></td></tr></table></figure>

<p><strong>修改视图的内容</strong></p>
<p>一般的视图只用来查询，对视图进行插入、删除、修改数据，如果能操作成功，则会对源表中的数据也会进行修改。但是绝大多数情况下无法对视图进行修改，而且也不建议对视图进行修改。</p>
<p>以下情况的视图无法更新：</p>
<ul>
<li>SQL语句包含<code>分组函数</code>、<code>distinct</code>、<code>group by</code>、<code>having</code>、<code>union</code>或者<code>union all</code>的视图</li>
<li>常量视图</li>
<li><code>select</code>中包含子查询的视图</li>
<li>包含<code>join</code>的视图</li>
<li><code>from</code>一个不能更新的视图</li>
<li><code>where</code>子句的子查询引用了<code>from</code>子句中的表</li>
</ul>
<h1 id="十一、变量"><a href="#十一、变量" class="headerlink" title="十一、变量"></a>十一、变量</h1><p>变量包括：</p>
<ul>
<li>系统变量<ul>
<li>全局变量</li>
<li>会话变量</li>
</ul>
</li>
<li>自定义变量<ul>
<li>用户变量</li>
<li>局部变量</li>
</ul>
</li>
</ul>
<h2 id="1、系统变量"><a href="#1、系统变量" class="headerlink" title="1、系统变量"></a>1、系统变量</h2><p><strong>系统变量</strong>：变量由系统定义，不是用户定义，属于服务器层面。必须拥有super权限才能修改系统变量。</p>
<p>系统变量分为<strong>全局变量</strong>和<strong>会话变量</strong>。全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认为会话级别。</p>
<p><strong>全局变量</strong></p>
<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有会话（连接）有效，但不能跨重启。</p>
<p>查看全局变量：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 查看所有全局变量</span><br>SHOW <span class="hljs-keyword">GLOBAL</span> VARIABLES<span class="hljs-comment">;</span><br><br><span class="hljs-meta"># 查看满足条件的部分系统变量</span><br>SHOW <span class="hljs-keyword">GLOBAL</span> VARIABLES LIKE <span class="hljs-string">&#x27;xxx&#x27;</span><span class="hljs-comment">;</span><br><br><span class="hljs-meta"># 查看指定的系统变量的值，</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-symbol">@global</span>.变量名<br></code></pre></td></tr></table></figure>

<p>设置全局变量：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 以autocommit为例</span><br><span class="hljs-comment"># 方式一：</span><br><span class="hljs-builtin-name">SET</span> @@global.变量名=值;<br><span class="hljs-comment"># 方式二：</span><br><span class="hljs-builtin-name">SET</span> GLOBAL 变量名=值;<br></code></pre></td></tr></table></figure>

<p><strong>会话变量</strong></p>
<p>作用域：针对于当前会话（连接）有效</p>
<p>查看会话变量：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 查看所有会话变量</span><br><span class="hljs-keyword">SHOW</span> [SESSION] VARIABLES;<br><br><span class="hljs-meta"># 查看满足条件的部分会话变量</span><br><span class="hljs-keyword">SHOW</span> [SESSION] VARIABLES LIKE &#x27;xxx&#x27;;<br><br><span class="hljs-meta"># 查看指定的会话变量的值</span><br><span class="hljs-meta">#SELECT <span class="hljs-comment">@@</span>[session.]变量名;</span><br><span class="hljs-meta"># 例：</span><br><span class="hljs-built_in">SELECT</span> <span class="hljs-comment">@@</span>autocommit;<br><span class="hljs-meta"># 或写成</span><br><span class="hljs-built_in">SELECT</span> <span class="hljs-comment">@@</span>session.autocommit;<br></code></pre></td></tr></table></figure>

<p>设置会话变量：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> @@<span class="hljs-keyword">session</span>.变量名=值;<span class="hljs-keyword">SET</span> [<span class="hljs-keyword">SESSION</span>] 变量名=值;<br></code></pre></td></tr></table></figure>

<h2 id="2、自定义变量"><a href="#2、自定义变量" class="headerlink" title="2、自定义变量"></a>2、自定义变量</h2><p><strong>自定义变量</strong>是由用户自定义，而不是系统提供的。其分为<strong>用户变量</strong>和<strong>局部变量</strong>。</p>
<p>自定义变量的使用一般都有<strong>声明、赋值、使用</strong>（查看、比较、运算等）三个步骤。</p>
<p><strong>用户变量</strong></p>
<p>作用域：和会话变量的作用域相同，对于当前会话（连接）有效。在<code>begin end</code>里面和外面都可以使用。</p>
<p>声明用户变量，要求声明时必须初始化值。有两种赋值操作符：<code>=</code>和<code>:=</code></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#方式一</span><br><span class="hljs-builtin-name">SET</span> @变量名=值;<br><br><span class="hljs-comment">#方式二</span><br><span class="hljs-builtin-name">SET</span> @变量名:=值;<br><br><span class="hljs-comment">#方式三</span><br>SELECT @变量名:=值;<br></code></pre></td></tr></table></figure>

<p>为用户变量赋值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 方式一，和初始化时相同：</span><br><span class="hljs-builtin-name">SET</span> @变量名=值;<br><span class="hljs-builtin-name">SET</span> @变量名:=值;<br>SELECT @变量名:=值;<br><br><span class="hljs-comment"># 方式二：</span><br>SELECT 字段 INTO @变量名 <span class="hljs-keyword">FROM</span> 表;<br></code></pre></td></tr></table></figure>

<p>查看用户变量：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">SELECT</span> @变量名;<br></code></pre></td></tr></table></figure>

<p><strong>局部变量</strong></p>
<p>作用域：仅在定义它的<code>begin end</code>块中有效。</p>
<p>声明局部变量必须在<code>begin end</code>块中的最前面部分。</p>
<p>局部变量一般不用加<code>@</code>符号，但是声明时需要指定类型，用户变量不需要指定类型。</p>
<p>声明局部变量：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DECLARE</span> 变量名 类型 [<span class="hljs-keyword">DEFAULT</span> 值];<br></code></pre></td></tr></table></figure>

<p>为局部变量赋值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#方式一，同样是三种：</span><br><span class="hljs-builtin-name">SET</span> 局部变量名=值;<br><span class="hljs-builtin-name">SET</span> 局部变量名:=值;<br>SELECT @局部变量名:=值;<br><br><span class="hljs-comment">#方式二：</span><br>SELECT 字段 INTO 局部变量名 <span class="hljs-keyword">FROM</span> 表;<br></code></pre></td></tr></table></figure>

<p>查看局部变量的值：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">SELECT 局部变量名<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h1 id="十二、存储过程和函数"><a href="#十二、存储过程和函数" class="headerlink" title="十二、存储过程和函数"></a>十二、存储过程和函数</h1><p>存储过程和函数都是事先经过编译 并存储在数据库中的一段SQL语句的集合。</p>
<p>优势：</p>
<ul>
<li>提高了sql语句的重用性，减少了开发人员的压力</li>
<li>提高了数据处理的效率</li>
<li>减少数据在数据库和应用服务器之间的传输次数</li>
</ul>
<h2 id="1、存储过程"><a href="#1、存储过程" class="headerlink" title="1、存储过程"></a>1、存储过程</h2><p><strong>创建存储过程</strong></p>
<p>语法：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-function"><span class="hljs-keyword">procedure</span> 存储过程名<span class="hljs-params">(参数模式 参数名 参数类型,...)</span><span class="hljs-title">begin</span>	存储过程体<span class="hljs-params">(一条或多条合法的SQL语句)</span>;</span><span class="hljs-keyword">end</span> 结束符<br></code></pre></td></tr></table></figure>

<p>参数可以有0个（比如只有插入语句）或多个。参数模式包括三种：</p>
<ul>
<li><code>IN</code>：表示该参数可以作为输入，即该参数需要调用方传入值</li>
<li><code>OUT</code>：表示该参数可以作为输出，即该参数可以作为返回值</li>
<li><code>INOUT</code>：表示该参数既可以作为输入又可以作为输出，即该参数既需要传入值，又可以返回值</li>
</ul>
<p>存储过程体如果只有一个SQL语句，可以省略<code>begin</code>和<code>end</code>，如果有多个SQL语句，<strong>每条SQL语句必须需要使用<code>;</code>结尾</strong>。</p>
<p>MySQL默认将<code>;</code>作为结束符，所以如果存储过程中有多个语句，但又希望将多个语句都执行，因此创建存储过程之前需要将修改默认的结束符。使用 <code>delimiter</code>重新设置结束符，保证过程体中的<code>;</code>被直接传递到服务器，而不会被客户端解释。例如，将<code>//</code>设置结束符的语句为：<code>delimiter //</code></p>
<p>SQLyog 10.0，定义存储过程前必须要设置结束符，生成的存储过程会自动将结束符设置为<code>$$</code>，如果没有手动将结束符改为<code>;</code>，系统会自动添加<code>delimiter ;</code>语句，因此每次创建存储过程都要重新设置结束符。</p>
<p>手写存储过程，建议在开头设置结束符，在末尾将结束符重新设置为<code>;</code></p>
<p><strong>调用存储过程</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">call 存储结构名(实参);<br># 如果是<span class="hljs-keyword">in</span>模式的参数，可以直接传入值<br># 如果是<span class="hljs-keyword">out</span>或<span class="hljs-keyword">inout</span>模式的参数，必须预先定义变量，然后作为参数传入。<br></code></pre></td></tr></table></figure>

<p><strong>删除存储过程</strong></p>
<p>存储过程不能修改，一般做法是将原来的删除，然后新建。</p>
<figure class="highlight cal"><table><tr><td class="code"><pre><code class="hljs cal"># 每次只能删除一个，不能删除多个<br>DROP <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> [<span class="hljs-title">IF</span> <span class="hljs-title">EXISTS</span>] 存储过程名;</span><br></code></pre></td></tr></table></figure>

<p><strong>查看存储过程</strong></p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene">SHOW <span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> 存储过程名;</span><br></code></pre></td></tr></table></figure>

<p>例：创建存储过程，输入员工id，输出其管理者的id和名字</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-comment">/* 声明存储结构</span><br><span class="hljs-comment">*/</span><br>DELIMITER @@  # 设置结束符为@@<br># 确保存储过程能正确创建，如果已经存在，删除原有的<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-symbol">`myp`</span>@@<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> myp(<span class="hljs-keyword">IN</span> id INT,<br>                     OUT managerId INT,<br>                     OUT managerName VARCHAR(<span class="hljs-number">20</span>))<br><span class="hljs-keyword">BEGIN</span><br>	# 将查询的结果值赋给输出变量，这里参数为局部变量<br>	<span class="hljs-keyword">SELECT</span> m.<span class="hljs-symbol">`employee_id`</span>,m.<span class="hljs-symbol">`last_name`</span> <span class="hljs-keyword">INTO</span> managerId,managerName<br>	<span class="hljs-keyword">FROM</span> employees m <br>	<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> employees <span class="hljs-built_in">e</span><br>	<span class="hljs-keyword">ON</span> m.<span class="hljs-symbol">`employee_id`</span>=<span class="hljs-built_in">e</span>.<span class="hljs-symbol">`manager_id`</span><br>	<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`employee_id`</span>=id;<br>END @@  # end后面要加设置的结束符<br>DELIMITER ;  # 将结束符改回分号<br><br><span class="hljs-comment">/*调用存储结构</span><br><span class="hljs-comment">in模式参数直接传入值，</span><br><span class="hljs-comment">out模式的参数要先声明，或者传入的时候指定名字</span><br><span class="hljs-comment">*/</span><br>CALL myp (110,@mid,@mname);  # 调用存储结构，传入参数<br><span class="hljs-keyword">SELECT</span> @mid,@mname;  # 查看结果值<br></code></pre></td></tr></table></figure>

<h2 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数</h2><p>函数和存储过程相似，唯一的区别是，<strong>存储过程可以有0个返回值</strong>，也可以有多个返回，适合做批量插入、批量更新；而<strong>函数有且仅有1个返回值</strong>，适合做处理数据后返回一个结果的情况。</p>
<p><strong>创建函数</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">CREATE <span class="hljs-keyword">FUNCTION</span> <span class="hljs-title">函数名</span>(参数名 参数类型,...) RETURNS 返回类型BEGIN	函数体;	<span class="hljs-keyword">RETURN</span> <span class="hljs-type">xx</span>;  #必须有返回值<span class="hljs-keyword">END</span> 结束符<br></code></pre></td></tr></table></figure>

<p>和存储过程相同，函数的参数也可是是0个或多个；结束符和存储过程的用法也相同；如果函数体只有一句，同样可以省略<code>begin end</code>语句。</p>
<p><strong>调用函数</strong></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">SELECT</span> 函数名(参数列表);  # 存储过程用的是<span class="hljs-keyword">CALL</span><br></code></pre></td></tr></table></figure>

<p><strong>删除函数</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"># 同样每次只能删除一个<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span>] 函数名; <br></code></pre></td></tr></table></figure>

<p><strong>查看函数</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> 函数名;<br></code></pre></td></tr></table></figure>

<p>函数使用案例：根据部门名，返回该部门的平均工资</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*创建函数*/</span><span class="hljs-keyword">DELIMITER</span> @@   # 先将分隔符设置为@@<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> `myf`@@<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf(deptName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)) <span class="hljs-keyword">RETURNS</span> DOUBLEBEGIN	#声明一个局部变量，用于接收查询结果，并返回	<span class="hljs-keyword">DECLARE</span> sal <span class="hljs-type">DOUBLE</span> ;	<span class="hljs-keyword">SELECT</span> AVG(salary) <span class="hljs-keyword">INTO</span> sal	<span class="hljs-keyword">FROM</span> employees e	<span class="hljs-keyword">JOIN</span> departments d <span class="hljs-keyword">ON</span> e.department_id = d.department_id	<span class="hljs-keyword">WHERE</span> d.department_name=deptName;	<span class="hljs-keyword">RETURN</span> sal;  # 返回结果值<span class="hljs-keyword">END</span> @@<span class="hljs-keyword">DELIMITER</span> ;  # 将分隔符重新设置为分号<span class="hljs-comment">/*调用函数*/</span><span class="hljs-keyword">SELECT</span> myf(<span class="hljs-string">&#x27;IT&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h1 id="十三、流程控制结构"><a href="#十三、流程控制结构" class="headerlink" title="十三、流程控制结构"></a>十三、流程控制结构</h1><p>流程控制结构包括以下三种：</p>
<ul>
<li>顺序结构：程序从上到下依次执行</li>
<li>分支结构：程序从两条或多条路径中选择一条去执行，比如<code>if</code>、<code>case</code>结构</li>
<li>循环结构：程序在满足一定条件的基础上，重复执行一段代码，比如<code>while</code>、<code>loop</code>、<code>repeat</code></li>
</ul>
<h2 id="1、分支结构"><a href="#1、分支结构" class="headerlink" title="1、分支结构"></a>1、分支结构</h2><p>分支结构包括<code>if结构</code>和<code>case结构</code>，只能用于<code>begin end</code>中，要和<code>if函数</code>、<code>case函数</code>区分开，<a href="https://kangshitao.github.io/2021/04/26/mysql-basis/#refer2">流程控制函数</a>既可以用在<code>begin end</code>里面，也可以用在外面。<code>if函数</code>适用于简单双分支，而<code>if结构</code>适用于区间判断的多分支，<code>case</code>适用于等值判断。</p>
<p><strong>if结构</strong></p>
<p>语法：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">if 条件<span class="hljs-number">1</span> then 语句<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>elseif 条件<span class="hljs-number">1</span> then 语句<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>...<br>else 语句n<span class="hljs-comment">;</span><br>end if<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>case结构</strong></p>
<p>语法：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 方式一：类似于switch</span><br><span class="hljs-keyword">case</span> 表达式<br><span class="hljs-keyword">when</span> 值<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">when</span> 值<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 语句<span class="hljs-number">2</span>;<br>...<br><span class="hljs-keyword">else</span> 语句n;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br><br><span class="hljs-comment"># 方式二：类似于多重if</span><br><span class="hljs-keyword">case</span> <br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 语句<span class="hljs-number">2</span>;<br>...<br><span class="hljs-keyword">else</span> 语句n;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br></code></pre></td></tr></table></figure>

<p><strong>分支结构使用案例</strong></p>
<p>创建函数，实现传入成绩返回等级的功能。如果成绩&gt;90，返回A，如果成绩&gt;80，返回B，如果成绩&gt;60，返回C，否则返回D。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 方式一：使用<span class="hljs-keyword">if</span>结构<br><span class="hljs-keyword">DELIMITER</span> @@   # 先将分隔符设置为@@<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> `myf_if`@@<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf_if(score <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">CHAR</span><br><span class="hljs-keyword">BEGIN</span><br>	# 设置局部变量保存结果<br>	<span class="hljs-keyword">DECLARE</span> ch <span class="hljs-type">CHAR</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>	<span class="hljs-keyword">IF</span> score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;A&#x27;</span>;<br>	ELSEIF score&gt;<span class="hljs-number">80</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;B&#x27;</span>;<br>	ELSEIF score&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;C&#x27;</span>;<br>	<span class="hljs-keyword">ELSE</span> ch=<span class="hljs-string">&#x27;D&#x27;</span>;<br>	<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>	<span class="hljs-keyword">RETURN</span> ch;<br><span class="hljs-keyword">END</span> @@<br><span class="hljs-keyword">DELIMITER</span> ;<br>#调用函数<br><span class="hljs-keyword">SELECT</span> myf_if(<span class="hljs-number">87</span>);<br><br># 方式二：使用<span class="hljs-keyword">case</span>结构<br><span class="hljs-keyword">DELIMITER</span> @@   # 先将分隔符设置为@@<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> `myf_case`@@<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf_case(score <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">CHAR</span><br><span class="hljs-keyword">BEGIN</span> <br>	#设置局部变量保存结果<br>	<span class="hljs-keyword">DECLARE</span> ch <span class="hljs-type">CHAR</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>	<span class="hljs-keyword">CASE</span> <br>	<span class="hljs-keyword">WHEN</span> score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;A&#x27;</span>;<br>	<span class="hljs-keyword">WHEN</span> score&gt;<span class="hljs-number">80</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;B&#x27;</span>;<br>	<span class="hljs-keyword">WHEN</span> score&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;C&#x27;</span>;<br>	<span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">SET</span> ch=<span class="hljs-string">&#x27;D&#x27;</span>;<br>	<span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br>	<span class="hljs-keyword">RETURN</span> ch;<br><span class="hljs-keyword">END</span> @@<br><span class="hljs-keyword">DELIMITER</span> ;<br>#调用函数<br><span class="hljs-keyword">SELECT</span> myf_case(<span class="hljs-number">56</span>);<br></code></pre></td></tr></table></figure>

<h2 id="2、循环结构"><a href="#2、循环结构" class="headerlink" title="2、循环结构"></a>2、循环结构</h2><p>循环结构包括<code>while</code>，<code>loop</code>，<code>repeat</code>三种。</p>
<p>同样，循环结构只能在<code>begin end</code>中使用。</p>
<p>循环结构中，包括两个循环控制语句：</p>
<ul>
<li><code>iterate</code>：类似于java中的continue，结束本次循环，进入下一次循环。</li>
<li><code>leave</code>：类似于java中的breek，跳出当前循环体。</li>
</ul>
<p><strong>循环控制语句后面必须有循环结构的标签名</strong>，也就是说，如果循环结构中使用了循环控制语句，此循环结构必须添加标签。</p>
<p><strong>while结构</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">[标签:] <span class="hljs-keyword">WHILE</span> 循环条件 <span class="hljs-keyword">DO</span><br>	循环体<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span> [标签];<br></code></pre></td></tr></table></figure>

<p><strong>loop结构</strong></p>
<p><code>loop</code>结构没有循环条件，想要结束循环必须使用<code>leave</code>语句，<code>loop</code>结构可以用于模拟简单的死循环。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">[标签:] <span class="hljs-keyword">loop</span><br>	循环体;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span> [标签];<br></code></pre></td></tr></table></figure>

<p><strong>repeat结构</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">[标签:] <span class="hljs-keyword">repeat</span><br>	循环体;<br><span class="hljs-keyword">until</span> 结束循环条件<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">repeat</span> [标签];<br></code></pre></td></tr></table></figure>

<p>使用循环结构的案例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 使用存储结构和循环结构，实现批量插入，要求只插入偶数次的记录<br><span class="hljs-keyword">DELIMITER</span> @@   # 先将分隔符设置为@@<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> test_while@@<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> test_while(<span class="hljs-keyword">IN</span> insertCount <span class="hljs-type">INT</span>)<br><span class="hljs-keyword">BEGIN</span><br>	<span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>	a: <span class="hljs-keyword">WHILE</span> i&lt;=insertCount <span class="hljs-keyword">DO</span><br>		<span class="hljs-keyword">SET</span> i=i+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">IF</span> MOD(i,<span class="hljs-number">2</span>)!=<span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> ITERATE a;<br>		<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>		<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">admin</span>(username,`<span class="hljs-keyword">password</span>`) <br>		<span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;xiaohua&#x27;</span>,i),<span class="hljs-string">&#x27;0000&#x27;</span>);<br>	<span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span> a;<br><span class="hljs-keyword">END</span> @@<br><span class="hljs-keyword">DELIMITER</span> ;<br><br># 传入<span class="hljs-number">100</span>，只会插入偶数时的记录<br><span class="hljs-keyword">CALL</span> test_while1(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列中间件：Kafka</title>
    <url>/2021/11/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9AKafka/</url>
    <content><![CDATA[<p>Kafka是一个分布式的基于发布、订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。</p>
<span id="more"></span>

<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>中间件。常用于做消息队列，处理==实时==问题。例如：</p>
<ul>
<li>实时支付和金融交易。</li>
<li>实时跟踪和监控汽车。</li>
<li>监测住院病人并预测病情变化。</li>
<li>收集客户互动信息和订单信息并作出反应。</li>
</ul>
<p>中间件，解耦。</p>
<h2 id="第一章-Kafka概述"><a href="#第一章-Kafka概述" class="headerlink" title="第一章 Kafka概述"></a>第一章 Kafka概述</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>Kafka是一个分布式的基于发布、订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。</p>
<h3 id="1-2消息队列"><a href="#1-2消息队列" class="headerlink" title="1.2消息队列"></a>1.2消息队列</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211019113739829.png" alt="image-20211019113739829"></p>
<h4 id="使用消息队列的好处："><a href="#使用消息队列的好处：" class="headerlink" title="使用消息队列的好处："></a>使用消息队列的好处：</h4><p>（1）解耦</p>
<p>（2）可恢复性：系统中的一部分失效，不会影响到整个系统。</p>
<p>（3）缓冲：有助于控制和雨花数据流经过系统的速度，解决生产消息和消费消息处理速度不一致的情况。</p>
<p>（4）灵活性 &amp; 峰值处理能力。</p>
<p>（5）异步通信。</p>
<h4 id="消息队列的两种模式："><a href="#消息队列的两种模式：" class="headerlink" title="消息队列的两种模式："></a>消息队列的两种模式：</h4><p>（1）点对点模式（==一对一==，消费者主动拉取数据，消息收到后消息清除）</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211019114857362.png" alt="image-20211019114857362"></p>
<p>缺点：不可复用。</p>
<p>（2）发布订阅模式（==一对多==，消费者消费数据之后不会清除消息）</p>
<p>消息发布者将消息发布到topic（主题）中，同时多个消费者（订阅）消费该消息。但是topic中的消息是有一个过期时间的。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211019114948760.png" alt="image-20211019114948760"></p>
<p>有两种方式：</p>
<ol>
<li>消息队列主动推送消息（消费者是被动接收的）</li>
<li>消费者主动拉取消息。</li>
</ol>
<h3 id="1-3-Kafka架构"><a href="#1-3-Kafka架构" class="headerlink" title="1.3 Kafka架构"></a>1.3 Kafka架构</h3><p><img src="https://img-blog.csdn.net/2018080718402749?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dWRlbnRfX3NvZnR3YXJl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>1）Producer ：消息生产者，就是向Kafka broker发消息的客户端；</p>
<p>2）Consumer ：消息消费者，向Kafka broker取消息的客户端；</p>
<p>3）Topic ：可以理解为一个队列；</p>
<p>4） Consumer Group （CG）：这是Kafka 用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个partion只会把消息发给该CG中的一个consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic；</p>
<p>5）Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic；</p>
<p>6）Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序；</p>
<p>7）Offset：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka。</p>
<h2 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h2><p><a href="https://zhuanlan.zhihu.com/p/68052232">https://zhuanlan.zhihu.com/p/68052232</a></p>
]]></content>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列中间件：RabbitMQ</title>
    <url>/2021/11/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9ARabbitMQ/</url>
    <content><![CDATA[<p>消息队列（MQ，Message Queue）本质是一个队列，队列中存放的内容是message，是一种跨进程的通信机制，用于上下游传递消息。RabbitMQ是一个消息中间件，它接受、存储、转发消息数据。</p>
<span id="more"></span> 

<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="==RabbitMQ=="></a>==RabbitMQ==</h1><h1 id="一、消息队列"><a href="#一、消息队列" class="headerlink" title="一、消息队列"></a>一、消息队列</h1><h2 id="1-1-MQ相关概念"><a href="#1-1-MQ相关概念" class="headerlink" title="1.1 MQ相关概念"></a>1.1 MQ相关概念</h2><h3 id="1-1-1-什么是MQ"><a href="#1-1-1-什么是MQ" class="headerlink" title="1.1.1 什么是MQ"></a>1.1.1 什么是MQ</h3><p>消息队列（MQ，Message Queue）本质是一个队列，队列中存放的内容是message，是一种跨进程的通信机制，用于上下游传递消息。</p>
<p>使用MQ以后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>
<h3 id="1-1-2-MQ的作用"><a href="#1-1-2-MQ的作用" class="headerlink" title="1.1.2 MQ的作用"></a>1.1.2 MQ的作用</h3><ul>
<li><p>流量削峰</p>
</li>
<li><p>应用解耦</p>
</li>
<li><p>异步处理</p>
</li>
</ul>
<h3 id="1-1-3-MQ分类"><a href="#1-1-3-MQ分类" class="headerlink" title="1.1.3 MQ分类"></a>1.1.3 MQ分类</h3><p>常见的MQ有以下几种：</p>
<ul>
<li>ActiveMQ：高吞吐量场景较少使用。</li>
<li>Kafka：为大数据而生，百万级TPS，吞吐量高，在日志领域比较成熟。适合有日志采集需求的大型企业。</li>
<li>RocketMQ：出自阿里巴巴，单机吞吐量十万级，消息0丢失，支持10亿级别的消息堆积。适合金融互联网。</li>
<li>RabbitMQ：由Erlang语言开发，在AMQP（高级消息队列协议）基础上完成，当前最流行的MQ。吞吐量万级，支持多种语言。适合数据量不是特别大的中小型公司。</li>
</ul>
<h2 id="1-2-RabbitMQ"><a href="#1-2-RabbitMQ" class="headerlink" title="1.2 RabbitMQ"></a>1.2 RabbitMQ</h2><h3 id="1-2-1-核心概念"><a href="#1-2-1-核心概念" class="headerlink" title="1.2.1 核心概念"></a>1.2.1 核心概念</h3><p><strong>RabbitMQ</strong></p>
<p>RabbitMQ是一个消息中间件，它接受、存储、转发消息数据。</p>
<p><strong>生产者（Producer）</strong></p>
<p>产生数据、发送消息的程序是生产者。</p>
<p><strong>交换机（Exchange）</strong></p>
<p>交换机是RabbitMQ的一个重要组件。它一方面接收来自生产者的消息，另一方面将消息推送到队列中。交换机决定了将消息推送到特定队列还是推送到多个队列。</p>
<p><strong>队列（Queue）</strong></p>
<p>队列是RabbitMQ内部使用的一种数据结构。消息只能存储在队列中，队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者也可以尝试从一个队列接收数据。</p>
<p><strong>消费者（Consumer）</strong></p>
<p>消费者指的是等待接受消息的程序。同一个应用程序既可以是生产者也可以是消费者。</p>
<h3 id="1-2-2-安装"><a href="#1-2-2-安装" class="headerlink" title="1.2.2 安装"></a>1.2.2 安装</h3><p>RabbitMQ官方文档：<a href="https://www.rabbitmq.com/documentation.html">Docs</a></p>
<p>RabbitMQ基于Erlang环境，因此需要先安装Erlang。</p>
<p>安装之前需要确保RabbitMQ和Erlang的版本要对应：<a href="https://www.rabbitmq.com/which-erlang.html">RabbitMQ Erlang Version Requirements</a></p>
<p>本机环境：</p>
<ul>
<li>CentOS-7.9</li>
<li>Erlang-23.2.3</li>
<li>RabbitMQ-3.8.15</li>
</ul>
<p>使用<code>rpm</code>方式，在packagecloud网站下载安装包。</p>
<p><strong>1、安装Erlang</strong></p>
<p>下载对应版本的安装包，<a href="https://packagecloud.io/rabbitmq/erlang?page=1">packagecloud</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget --content-disposition https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-23.2.3-1.el7.x86_64.rpm/download.rpm<br></code></pre></td></tr></table></figure>

<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rpm -ivh erlang-23.2.3-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure>



<p><strong>2、安装socat</strong></p>
<p>除了Erlang环境，还需要安装socat：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum install socat logrotate -y<br></code></pre></td></tr></table></figure>



<p><strong>3、安装RabbitMQ</strong></p>
<p>下载对应版本的安装包，<a href="https://packagecloud.io/rabbitmq/rabbitmq-server?page=1">packagecloud</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget --content-disposition https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/8/rabbitmq-server-3.8.15-1.el8.noarch.rpm/download.rpm<br></code></pre></td></tr></table></figure>

<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rpm -ivh rabbitmq-server-3.8.15-1.el8.noarch.rpm<br></code></pre></td></tr></table></figure>

<p>安装完成后，启动rabbit服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl start rabbitmq-server.service<br></code></pre></td></tr></table></figure>

<p><strong>4、安装插件</strong></p>
<p>可以通过以下命令开启web管理插件，需要先停止rabbitmq服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure>

<p>插件开启成功后就可以在浏览器中访问，默认端口号为<code>15672</code>（记得关闭防火墙或者开放端口）。</p>
<p>管理界面需要账号密码登陆，默认的账号和密码都是<code>guest</code>。</p>
<p>查看当前所有用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmqctl list_users<br></code></pre></td></tr></table></figure>



<p>添加新用户<code>admin</code>，密码也为<code>admin</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmqctl add_user admin admin<br></code></pre></td></tr></table></figure>



<p>设置用户角色（标签），将<code>admin</code>设置为<code>administrator</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmqctl set_user_tags admin administrator<br></code></pre></td></tr></table></figure>



<p>设置用户权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rabbitmqctl set_permissions -p <span class="hljs-string">&quot;/&quot;</span> admin <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span><br></code></pre></td></tr></table></figure>





<h3 id="1-2-3-原理和工作模式"><a href="#1-2-3-原理和工作模式" class="headerlink" title="1.2.3 原理和工作模式"></a>1.2.3 原理和工作模式</h3><p><strong>工作原理</strong></p>
<p>RabbitMQ的工作原理如图所示：</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211015214425680.png" alt="image-20211015214425680"></p>
<p>生产者将消息通过Channel发送到Exchange，Exchange决定将消息分发到哪个队列，然后由消费者从队列中接收消息。</p>
<p>其中的核心概念：</p>
<ul>
<li><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是Message Broker</li>
<li><strong>Virtual host</strong>：虚拟的分组，当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange/queue等。</li>
<li><strong>Connection</strong>：publisher/consumer和broker之间的TCP连接。</li>
<li><strong>Channel</strong>：Channel是在connection内部建立的逻辑连接，多线程情况下通常每个线程创建单独的channel进行通讯。AMQP method包含了channel id帮助客户端和broker识别channel，<strong>channel是完全隔离的</strong>。<strong>Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。</strong></li>
<li><strong>Exchange</strong>：交换机。消息到达broker中会首先到达Exchange，Exchange根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct（point-to-point）、topic（publish-subscribe）、fanout（multicast）。</li>
<li><strong>Queue</strong>：消息被送到Queue中，然后被消费者取走。</li>
<li><strong>Binding</strong>：<strong>exchange</strong>和<strong>queue</strong>之间的虚拟连接。binding中可以包含Routing key，binding信息被保存到exchange中的查询表中，用于message的分发依据。声明binding关系的时候，可以声明RoutingKey参数</li>
</ul>
<p><strong>工作模式</strong></p>
<p>RabbitMQ一共有7种工作模式，参考<a href="https://www.rabbitmq.com/getstarted.html">Get Started</a>：</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211015222337420.png" alt="image-20211015222337420"></p>
<h1 id="二、Hello-World"><a href="#二、Hello-World" class="headerlink" title="二、Hello World"></a>二、Hello World</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html">Hello World</a>模式是RabbitMQ最简单的一个模式。下图中的P表示生产者，C是消费者，中间框是一个队列，是RabbitMQ代表消费者保存的消息缓冲区。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211015222548402.png" alt="Hello World模式"></p>
<h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h2><p><strong>1、在IDEA中创建Maven项目，然后引入依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>2、编写生产者的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;    <span class="hljs-comment">// 队列名称    public static final String QUEUE_NAME = &quot;hello&quot;;    //发消息    public static void main(String[] args) throws IOException, TimeoutException &#123;        //创建一个连接工厂        ConnectionFactory factory = new ConnectionFactory();        //设置工厂的ip，连接队列        factory.setHost(&quot;192.168.198.198&quot;); //RabbitMQ服务主机的ip        //设置用户名和密码        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;admin&quot;);        //创建连接，每个连接有多个channel，channel是用来发消息的。        Connection connection = factory.newConnection();        //获取channel        Channel channel = connection.createChannel();        //生成一个队列用于通信，简单起见，使用默认的交换机        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //发消息        String message = &quot;hello, world&quot;;        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());        System.out.println(&quot;消息发送完毕！&quot;);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>其中关键方法的说明：</p>
<ul>
<li><code>queueDeclare()</code>，用于声明一个队列，其中的各个参数依次解释如下：<ul>
<li>队列名。</li>
<li>队列的消息是否持久化，默认情况下消息存储在内存中(不持久化）。</li>
<li>该队列是否进行消费共享，true表示允许多个消费者消费。</li>
<li>是否自动删除 最后一个消费者端开连接以后，该队列是否自动删除。</li>
<li>其他参数。</li>
</ul>
</li>
<li><code>basicPublish()</code>，用于发布消息：<ul>
<li>交换机名称，用于指定发送到哪个交换机。</li>
<li>routingKey，路由的key值。这里使用的是channel名字作为routingKey</li>
<li>其他参数信息。</li>
<li>发送消息的消息体。</li>
</ul>
</li>
</ul>
<p><strong>3、编写消费者的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-comment">// 队列名称    public static final String QUEUE_NAME = &quot;hello&quot;;        //接收消息    public static void main(String[] args) throws IOException, TimeoutException &#123;        //创建连接工厂        ConnectionFactory factory = new ConnectionFactory();        //设置ip        factory.setHost(&quot;192.168.198.198&quot;);        //设置用户名和密码        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;admin&quot;);        //创建连接        Connection connection = factory.newConnection();        //创建信道        Channel channel = connection.createChannel();        //消费者接收消息（消费消息）        //接收消息的回调函数        DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123;            System.out.println(new String(message.getBody()));        &#125;;        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;            System.out.println(&quot;消息消费被中断&quot;);        &#125;;        channel.basicConsume(QUEUE_NAME,true, deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<p><code>basicConsume()</code>的参数说明：</p>
<ul>
<li>指定消费的队列名，即从哪个队列中取消息。</li>
<li>消费成功之后是否自动应答。</li>
<li>消费者接收的回调函数。</li>
<li>消费者取消消费的回调函数。</li>
</ul>
<blockquote>
<p>如果需要修改现有的exchange和queue，需要删除现有的队列，重新创建。</p>
</blockquote>
<p><strong>4、运行</strong></p>
<p>启动生产者程序，会创建Channel并发送消息，然后启动消费者程序，会收到来自生产者的消息。</p>
<h1 id="三、Work-Queues"><a href="#三、Work-Queues" class="headerlink" title="三、Work Queues"></a>三、Work Queues</h1><p><a href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html">Work Queues</a>模式的主要思想是避免因立即执行资源密集型任务而不得不等待它完成。在这个模式中，我们将任务封装为消息，并将其发送到队列。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211016200456597.png" alt="Work Queues"></p>
<h2 id="3-1-轮询分发消息"><a href="#3-1-轮询分发消息" class="headerlink" title="3.1 轮询分发消息"></a>3.1 轮询分发消息</h2><p>Work Queues模式下使用的轮询分发的机制，对于多个消费者线程，会轮流分发任务。</p>
<p>下面我们以一个生产者，两个消费者线程来模拟。</p>
<p><strong>抽取工具类</strong></p>
<p>创建channel之前的代码是相同的，因此可以单独抽取出来，作为工具类：</p>
<p><code>RabbitMqUtils.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqUtils</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title">getChannel</span><span class="hljs-params">()</span></span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">&quot;192.168.198.198&quot;</span>);        factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);        factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);        Connection connection = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = factory.newConnection();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;            e.printStackTrace();        &#125;        Channel channel = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            channel = connection.createChannel();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> channel;    &#125;&#125;<br></code></pre></td></tr></table></figure>

<p><strong>生产者</strong></p>
<p>启动发送线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task01</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        channel.queueDeclare(QUEUE_NAME,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);        <span class="hljs-comment">//从控制台接收信息发送到消费者        Scanner scanner = new Scanner(System.in);        while(scanner.hasNext())&#123;            String message = scanner.next();            channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());            System.out.println(message+&quot;发送完成！&quot;);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>启动两个工作线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker01</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">//消息的接收        DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123;            System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody()));        &#125;;        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;            System.out.println(consumerTag+&quot;消息被取消接受&quot;);        &#125;;        System.out.println(&quot;Consumer 1------&quot;);        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>使用IDEA设置并行运行，<code>Edit Configurations</code>-&gt;<code>Allow multiple instances</code>，这样可以同时启动两个消费者线程。</p>
<p><strong>运行</strong></p>
<p>生产者发送消息，消费者1和消费者2会轮流处理消息。</p>
<p>比如生产者发送1、2、3、4、5、6，消费者1接收到1、3、5，消费者2接收到2、4、6。</p>
<h2 id="3-2-消息应答"><a href="#3-2-消息应答" class="headerlink" title="3.2 消息应答"></a>3.2 消息应答</h2><p><strong>概念</strong></p>
<p>消费者完成一个任务需要耗费一定的时间，RabbitMQ一旦向消费者发送消息后，会将此消息标记为删除，这种情况下，如果消费者处理任务的过程中出现故障，会导致任务丢失。<strong>为了保证消息不会丢失，RabbitMQ引入了消息应答机制</strong>。</p>
<p><strong>消息应答（Message acknowledgment）</strong>：消费者在接收到消息并且处理完该消息之后，告诉RabbitMQ此消息已经被处理，RabbitMQ可以将该消息删除。这样就保证当某一个消费者线程故障后，消息会被重新发送给其他消费者，确保消息不会丢失（前提是RabbitMQ无故障）。</p>
<p>消息应答包括<strong>自动应答</strong>和<strong>手动应答</strong>两种方式：</p>
<ul>
<li><strong>自动应答</strong>：消息发送后立即被认为已经传送成功。这种方式没有对传递的消息数量做限制，会导致消费者端消息积压，线程被系统杀死。这种模式仅适用于消费者可以高效并以某种速率能够处理这些消息的情况下使用。</li>
<li><strong>手动应答</strong>：默认是手动应答模式。如果一个消费者线程宕机，其消息可以被其他消费者线程消费，而不会出现消息丢失的情况。</li>
</ul>
<p>手动应答示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** * 消息在手动应答时不丢失、放回队列中重新消费 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker03</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TASK_QUEUE_NAME = <span class="hljs-string">&quot;ack_queue&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel(); <span class="hljs-comment">//获取channel        System.out.println(&quot;消费者1等待接收消息，处理时间较短------&quot;);        //手动应答        boolean autoAck = false;        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            //沉睡1s，模拟处理信息场景。            SleepUtils.sleep(1); //工具类SleepUtils用来睡眠线程。            System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));            //手动应答。参数1为消息的标记tag，参数2表示是否批量应答            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);        &#125;;        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;            System.out.println(consumerTag+&quot;消息被取消接受&quot;);        &#125;;        //设置为手动应答        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>手动应答主要是在接收消息的回调方法中调用<code>basicAck()</code>方法，已经在<code>basicConsume()</code>方法中设置自动应答方式为false。</p>
<p>其中<code>basicAck()</code>方法的第二个参数表示是否批量化应答。如果是**批量化应答(Multiple)**，则每次会应答一个批次的消息。</p>
<p><strong>手动应答的好处就是可以批量应答并且减少网络拥堵</strong>。</p>
<p><strong>消息重新入队</strong>：如果某个消费者由于某些原因失去连接（或发生故障），导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将其重新排队发送给其他消费者。这样，即使某个消费者偶尔死亡，也可以确保不丢失消息。</p>
<h2 id="3-3-RabbitMQ持久化"><a href="#3-3-RabbitMQ持久化" class="headerlink" title="3.3 RabbitMQ持久化"></a>3.3 RabbitMQ持久化</h2><p><strong>消息应答</strong>能够确保消费者线程故障后，消息不会丢失，如何保障当RabbitMQ服务停掉以后消息也不丢失？</p>
<p>这就<strong>需要将队列和消息都标记为持久化。</strong></p>
<p><strong>队列持久化</strong></p>
<p>在声明队列时将是否持久化的参数置为<code>true</code>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.queueDeclare(TASK_QUEUE_NAME,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure>

<p>第二个参数就表示是否持久化队列。</p>
<p>如果已经存在的队列需要持久化，需要将队列删除，重新创建。</p>
<p><strong>消息持久化</strong></p>
<p>仅将队列持久化不能保证消息不丢失，因为如果消费者线程宕机断开连接，仍然有可能出现消息丢失的情况。</p>
<p>设置消息持久化，需要在<code>channel</code>发布消息时设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>这种方式只是尽量保证持久化，如果绝对保证持久化，需要使用发布确认机制。</p>
<p><strong>预取值</strong></p>
<p><code>basicQos()</code>方法可以设置消费者线程的预取值。</p>
<p>预取值表示一个消费者线程对应的信道最大可以堆积的消息个数，即<strong>通道上允许的未确认消息的最大数量</strong>。</p>
<blockquote>
<p>类似于缓冲池，预取值最大值就是缓存池的最大值。最多只能存放预取值个数的未确认消息。</p>
</blockquote>
<p>如果不设置预取值，可能会有大量已传递但尚未处理的消息的数量堆积，导致消费者RAM消耗。</p>
<p><strong>不公平分发</strong></p>
<p>轮询方式是不管每个消费者的处理速度，给每个消费者线程轮流分发任务。</p>
<p>不公平分发是指<strong>根据每个消费者线程的处理能力，为每个消费者线程分配不同个数的消息</strong>。——能者多劳。</p>
<p>在<strong>消费者</strong>的信道上，设置Qos的值为1，就可以表示按处理能力分发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将Qos设置为1，就是不公平分发；默认为0，表示轮询分发channel.basicQos(1); </span><br></code></pre></td></tr></table></figure>

<p>Qos的值为1时，表示根据消费者线程的处理能力分发，最多堆积一个任务。</p>
<h1 id="四、发布确认"><a href="#四、发布确认" class="headerlink" title="四、发布确认"></a>四、发布确认</h1><p>如果想要确保消息一定不会丢失，除了上面提到的<strong>队列持久化</strong>和<strong>消息持久化</strong>，还需要使用<strong>发布确认（Publisher confirm）</strong>。这三种设置保证了消息不会丢失。</p>
<p>官方文档：<a href="https://www.rabbitmq.com/tutorials/tutorial-seven-java.html">Publisher Confirms</a></p>
<h2 id="4-1-发布确认原理"><a href="#4-1-发布确认原理" class="headerlink" title="4.1 发布确认原理"></a>4.1 发布确认原理</h2><p>生产者将channel设置为confirm模式，一旦channel进入<strong>confirm模式</strong>，<strong>所有在该channel上面发布的消息都会被指派一个唯一的ID（从1开始）</strong>。一旦消息被投递到所有匹配的队列之后，broker会发送一个确认给生产者。</p>
<p>生产者得知消息已经正确到达目的队列后，如果消息和队列是可持久化的，确认消息会在消息写入磁盘后发出。</p>
<blockquote>
<p>broker回传给生产者的确认消息中delivery-tag域中包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>发布确认（Publisher confirm）是broker给生产者发送的确认消息。</p>
<p>消息应答（Message acknowledgment）是消费者处理完消息发送给broker的ack确认。</p>
</blockquote>
<p><strong>confirm模式</strong>的好处在于它是异步的，发布一条消息后，生产者可以边等确认消息边发送下一条消息。消息得到确认或者丢失，生产者都会通过相应的回调方法进行处理。</p>
<h2 id="4-2-发布确认策略"><a href="#4-2-发布确认策略" class="headerlink" title="4.2 发布确认策略"></a>4.2 发布确认策略</h2><h3 id="4-2-1-开启发布确认"><a href="#4-2-1-开启发布确认" class="headerlink" title="4.2.1 开启发布确认"></a>4.2.1 开启发布确认</h3><p>生产者创建信道后，调用<code>confirmSelect()</code>方法即可开启发布确认模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.confirmSelect();<br></code></pre></td></tr></table></figure>

<p>发布确认可以有单个确认、批量确认、异步确认三种方式。</p>
<h3 id="4-2-2-单个确认发布"><a href="#4-2-2-单个确认发布" class="headerlink" title="4.2.2 单个确认发布"></a>4.2.2 单个确认发布</h3><p>单个确认发布，即对每一条消息进行同步确认，生产者发布一条消息后只有它被确认发布后，后续的消息才能继续发布。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishMessageIndividually</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    Channel channel = RabbitMqUtils.getChannel();    <span class="hljs-comment">//信道名字使用随机的UUID    String queueName = UUID.randomUUID().toString();    channel.queueDeclare(queueName,true,false,false,null);    //开启发布确认    channel.confirmSelect();    long start = System.currentTimeMillis();    //批量发消息    for(int i=0;i&lt;1000;i++)&#123;        String message = i+&quot;&quot;;        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes());        //单个消息马上确认        boolean flag = channel.waitForConfirms();        if(flag)&#123;            System.out.println(&quot;第&quot;+i+&quot;条消息发送成功&quot;);        &#125;    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布1000个单独确认消息，耗时&quot;+(end-start)+&quot;ms&quot;);&#125;</span><br></code></pre></td></tr></table></figure>

<p>单个确认发布的速度是最慢的，因为要每条消息都确认一次。</p>
<h3 id="4-2-3-批量确认发布"><a href="#4-2-3-批量确认发布" class="headerlink" title="4.2.3 批量确认发布"></a>4.2.3 批量确认发布</h3><p>批量确认发布是指根据批次大小确认发布，这种方式的缺点是当发生故障导致发布出现问题时，不知道哪个消息出问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//批量发布确认public static void publishMessageBatch() throws Exception&#123;    Channel channel = RabbitMqUtils.getChannel();    //信道名字使用随机的UUID    String queueName = UUID.randomUUID().toString();    channel.queueDeclare(queueName,true,false,false,null);    //开启发布确认    channel.confirmSelect();    long start = System.currentTimeMillis();    //批量发消息，并批量确认消息    int batchSize = 100; //每100条确认一次    for(int i=0;i&lt;1000;i++)&#123;        String message = i+&quot;&quot;;        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes());        if((i+1)%batchSize==0)&#123; //每100条消息确认一次            boolean flag = channel.waitForConfirms();            if(flag)&#123;                System.out.println(&quot;确认前&quot;+i+&quot;条数据&quot;);            &#125;        &#125;    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布1000个批量确认消息，耗时&quot;+(end-start)+&quot;ms&quot;);&#125;</span><br></code></pre></td></tr></table></figure>



<h3 id="4-2-4-异步确认发布"><a href="#4-2-4-异步确认发布" class="headerlink" title="4.2.4 异步确认发布"></a>4.2.4 异步确认发布</h3><p>异步确认发布是效率和可靠性最高的。对于已确认消息和未确认消息，异步确认方式都能够处理。</p>
<p>异步确认发布主要是通过<code>addConfirmListener</code>方法监听确认和未确认的消息，使用哈希表记录所有发布的消息，对于成功确认的消息从哈希表中删除，剩下的是未确认的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//异步批量确认public static void publishMessageAsync() throws Exception&#123;    Channel channel = RabbitMqUtils.getChannel();    //信道名字使用随机的UUID    String queueName = UUID.randomUUID().toString();    channel.queueDeclare(queueName,true,false,false,null);    //开启发布确认    channel.confirmSelect();    //使用哈希表记录所有消息，便于多个线程进行消息的添加和删除    /*线程安全的哈希表，适用于高并发的情况。    1.哈希表能够轻松的将序号和消息进行关联。    2.可以轻松地批量删除条目，只需要知道序号    3.支持高并发（多线程）    */    ConcurrentSkipListMap&lt;Long,String&gt; map = new ConcurrentSkipListMap&lt;&gt;();        long start = System.currentTimeMillis();    //创建消息的监听器，监听哪些消息成功了，哪些消息失败了。    //消息确认成功 回调函数    /*参数：1. 消息的标记（序号）2.是否为批量确认*/    ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt;&#123;        //2.删除掉已经确认的消息，剩下的就是未确认的消息        if(multiple)&#123; //默认multiple是true，即批量确认的            //如果是批量确认的，则找到所有小于当前序号的值，并清除。这样剩下的就是未确认的消息            //headMap方法就是返回所有小于指定序号的值的map，第二个参数表示是否找出等于序号的。            ConcurrentNavigableMap&lt;Long, String&gt; navigableMap = map.headMap(deliveryTag, true);            navigableMap.clear();        &#125;else&#123;//如果不是批量确认，则只删除当前已经确认的消息即可。            map.remove(deliveryTag);        &#125;        System.out.println(&quot;确认的消息：&quot;+deliveryTag);    &#125;;    //监听确认失败的消息    ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt;&#123;        //3.打印未确认的消息        System.out.println(&quot;未确认的消息：&quot;+deliveryTag);    &#125;;    /*参数：1.监听确认成功的消息 2. 监听确认失败的消息*/    channel.addConfirmListener(ackCallback,nackCallback);    //批量发消息，异步确认消息    int batchSize = 100; //每100条确认一次    for (int i = 0; i &lt; 1000; i++) &#123;        String message = &quot;消息&quot; + i;        //1.记录下所有要发送的消息        map.put(channel.getNextPublishSeqNo(),message);        //发布消息        channel.basicPublish(&quot;&quot;,queueName,null,message.getBytes());    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布&quot;+MESSAGE_COUNT+&quot;个异步确认消息，耗时&quot;+(end-start)+&quot;ms&quot;);&#125;</span><br></code></pre></td></tr></table></figure>



<h1 id="五、交换机"><a href="#五、交换机" class="headerlink" title="五、交换机"></a>五、交换机</h1><h2 id="5-1-相关概念"><a href="#5-1-相关概念" class="headerlink" title="5.1 相关概念"></a>5.1 相关概念</h2><p>生产者生产的消息不会直接发送到队列，只能将消息发送到<strong>交换机（exchange）</strong>，然后由交换机发送到队列。</p>
<p><strong>交换机</strong>的功能：①接收来自生产者的消息。②将消息推入队列。</p>
<p>交换机主要的三个类型：</p>
<ul>
<li><strong>fanout</strong>：这种类型的交换机不分析Routing Key，将消息转发到所有和该交换机绑定的队列中。用于<a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html">Publish/Subscribe模式</a>。</li>
<li><strong>direct</strong>：这类交换机需要精准匹配Routing Key，只将消息转发到指定Routing Key的队列中。用于<a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html">Routing模式</a>。</li>
<li><strong>topic</strong>：这类交换机按照一定规则匹配Routing Key，将消息转发到匹配到的队列中，通常是一组相同主题的队列。用于<a href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html">Topics模式</a></li>
</ul>
<p><strong>临时队列</strong></p>
<p>创建一个随机名称的临时队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String queueName = channel.queueDeclare().getQueue();<br></code></pre></td></tr></table></figure>

<p><strong>绑定（bindings）</strong></p>
<p>binding是指exchange和queue之间的关系，将exchange和queue进行绑定。</p>
<p>其中一个交换机和一个队列之间可以有多个binding key</p>
<h2 id="5-2-Publish-Subscribe"><a href="#5-2-Publish-Subscribe" class="headerlink" title="5.2 Publish/Subscribe"></a>5.2 Publish/Subscribe</h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html">发布订阅模式</a>是使用的扇出（fanout）类型的交换机。</p>
<p>交换机会<strong>将消息推送至所有和他绑定的队列，不会匹配Routing Key</strong>。无论绑定的Routing Key是什么值，都会发送到所有和其绑定的队列中。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211019201626154.png" alt="Publish/Subscribe"></p>
<p><strong>实例</strong></p>
<p>如上图所示，一个交换机，两个队列。</p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmitLog</span> </span>&#123;    <span class="hljs-comment">//交换机名字为logs    public static final String EXCHANGE_NAME = &quot;logs&quot;;    public static void main(String[] args) throws IOException &#123;        Channel channel = RabbitMqUtils.getChannel();        //声明为fanout类型，可以用枚举类型或者字符串。        //channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;);        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);        Scanner scanner = new Scanner(System.in);        while(scanner.hasNext())&#123;            String message = scanner.next();            //绑定信息为空            channel.basicPublish(EXCHANGE_NAME,&quot;&quot;,null,message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产者发出消息：&quot;+message);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>消费者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReceiveLogs01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">/*声明临时队列        临时队列的队列名称是随机的        当消费者断开与队列的连接后，队列会被自动删除。         */</span>        String queueName = channel.queueDeclare().getQueue();        <span class="hljs-comment">/*        将队列和交换机绑定 binding，routingKey为空         */</span>        channel.queueBind(queueName,EXCHANGE_NAME,<span class="hljs-string">&quot;&quot;</span>);        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;消费者1控制台打印接收到的消息：&quot;</span>+<span class="hljs-keyword">new</span> String(message.getBody(),<span class="hljs-string">&quot;UTF-8&quot;</span>));        &#125;;        CancelCallback cancelCallback = consumerTag-&gt;&#123;&#125;;        channel.basicConsume(queueName,deliverCallback,cancelCallback);    &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>消费者2的代码和消费者1相同，会生成另一个随机名称的临时队列。</p>
<p>这样，当生产者每次发送一条消息，消费者1和消费者2都能接收到。</p>
<h2 id="5-3-Routing"><a href="#5-3-Routing" class="headerlink" title="5.3 Routing"></a>5.3 Routing</h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html">Routing模式</a>使用的是direct类型交换机，这种模式下，交换机需要精准匹配Routing Key，只将消息转发到指定Routing Key的队列中。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211019204129471.png" alt="Routing"></p>
<p>如图，交换机X绑定了Q1和Q2两个队列，其中和Q1之间的Binding Key为<code>orange</code>，和Q2的Binding Key包括<code>black</code>和<code>green</code>两个。</p>
<p>Routing Key为<code>orange</code>的消息会被推送到Q1队列。Routing Key为<code>black</code>和<code>green</code>的消息会被推送到Q2队列。</p>
<blockquote>
<p>多重绑定：允许不同队列和交换机之间的Binding Key是相同的，这种情况下效果和Publish/Subscribe模式相同。</p>
</blockquote>
<p><strong>实现</strong></p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectProducer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">&quot;X&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">//声明交换机,类型为direct        channel.exchangeDeclare(EXCHANGE_NAME,&quot;direct&quot;);                Scanner scanner = new Scanner(System.in);        while(scanner.hasNext())&#123;            String message = scanner.next();            //当Bingding Key取不同值时，会根据情况发送的相应的队列。            channel.basicPublish(EXCHANGE_NAME,&quot;orange&quot;,null,message.getBytes(&quot;UTF-8&quot;));//            channel.basicPublish(EXCHANGE_NAME,&quot;black&quot;,null,message.getBytes(&quot;UTF-8&quot;));//            channel.basicPublish(EXCHANGE_NAME,&quot;green&quot;,null,message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;Direct类型，生产者发出消息：&quot;+message);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<p>消费者1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectConsumer01</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">&quot;X&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;Q1&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BINGDING_NAME = <span class="hljs-string">&quot;orange&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">//声明交换机,类型为direct        channel.exchangeDeclare(EXCHANGE_NAME,&quot;direct&quot;);        //声明名为Q1的队列        channel.queueDeclare(QUEUE_NAME,false,false,false,null);        //将队列和交换机绑定        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,BINGDING_NAME);        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            System.out.println(&quot;C1接收到消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));        &#125;;        CancelCallback cancelCallback = consumerTag-&gt;&#123;&#125;;        channel.basicConsume(QUEUE_NAME,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>消费者2和消费者1类似，不同的是有两个Bingding：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多重绑定，一个channel和交换机有两个绑定,两个不同的routing keychannel.queueBind(&quot;Q2&quot;,&quot;X&quot;,&quot;black&quot;);channel.queueBind(&quot;Q2&quot;,&quot;X&quot;,&quot;green&quot;);</span><br></code></pre></td></tr></table></figure>

<p>这样，当发送消息的Routing Key为<code>orange</code>时，消息会被推送到Q1，Routing Key为<code>black</code>或<code>green</code>时，消息被推送到Q2。</p>
<h2 id="5-4-Topics"><a href="#5-4-Topics" class="headerlink" title="5.4 Topics"></a>5.4 Topics</h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html">Topics</a>模式使用的是Topic类型的交换机，队列可以匹配一定规则的多个Routing Key。</p>
<p>Topic模式的Routing Key必须符合一定的要求：<strong>必须是一个单词列表，以<code>.</code>号分开</strong>，单词可以是任意的，比如<code>stock.usd.nyse</code>, <code>nyse.vmw</code>, <code>quick.orange.rabbit</code>等。单词列表最多为255个字节。</p>
<p><code>*</code>号可以代替一个单词。</p>
<p><code>#</code>号可以代替0个或多个单词。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211019213420569.png" alt="Topics"></p>
<p>如上图所示，交换机X和Q1的Binding Key为<code>*.orange.*</code>，X和Q2的Binding Key为<code>*.*.rabbit</code>和<code>lazy.#</code>。</p>
<p>一些案例：</p>
<p>①<code>quick.orange.rabbit</code>：Q1、Q2接收到消息。</p>
<p>②<code>quick.orange.rabbit</code> ： Q1、Q2接收到消息。</p>
<p>③<code>lazy.orange.elephant</code>：Q1、Q2 接收到消息。</p>
<p>④<code>quick.orange.fox</code>：Q1 接收到消息。</p>
<p>⑤<code>lazy.brown.fox</code>：Q2 接收到消息。</p>
<p>⑥<code>lazy.pink.rabbit</code> ：Q2 接收一次消息，虽然两种绑定都匹配，但只接收一次。</p>
<p>⑦<code>quick.brown.fox</code> ：不匹配任何绑定，被丢弃。</p>
<p>⑧<code>quick.orange.male.rabbit</code> ：是四个单词，不匹配任何绑定，被丢弃。</p>
<p>⑨<code>lazy.orange.male.rabbit</code> ：是四个单词，Q2接收到消息。</p>
<p><strong>实现</strong></p>
<p>声明交换机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>队列Q1绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.queueBind(<span class="hljs-string">&quot;Q1&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;*.orange.*&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>队列Q2绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.queueBind(<span class="hljs-string">&quot;Q1&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;*.*.rabbit&quot;</span>);channel.queueBind(<span class="hljs-string">&quot;Q1&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;lazy.#&quot;</span>);<br></code></pre></td></tr></table></figure>





<h1 id="六、死信队列"><a href="#六、死信队列" class="headerlink" title="六、死信队列"></a>六、死信队列</h1><p>关于死信队列的官方文档：<a href="https://www.rabbitmq.com/dlx.html">死信队列</a></p>
<p>队列中的消息如果发生以下情况就会变成<strong>死信（Dead Letter）</strong>：</p>
<ul>
<li>消息被拒绝（<code>basic.reject</code>或<code>basic.nack</code>），并且<code>requeue</code>参数为<code>false</code></li>
<li>消息TTL超时，即消息过期。</li>
<li>队列长度超过最大限制。</li>
</ul>
<blockquote>
<p>队列过期不会导致消息变为死信。</p>
</blockquote>
<p>死信交换机（Dead Letter eXchanges，DLXs）是正常的交换机，它可以将Dead Letter转发给死信队列，进一步处理。</p>
<p>如图，正常情况下，消息通过<code>normal_exchange</code>推送到<code>normal_queue</code>，然后被<code>C1</code>消费；如果消息变为死信，<code>normal_queue</code>会将死信转发给死信交换机<code>DLX</code>，<code>DLX</code>将死信推送给死信队列<code>dead_letter_queue</code>，然后被<code>C2</code>消费。</p>
<p><img src="C:\Users\Kangshitao\AppData\Roaming\Typora\typora-user-images\image-20211019222750171.png" alt="死信队列"></p>
<p><strong>实现</strong></p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span>  </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_EXCHANGE=<span class="hljs-string">&quot;normal_exchange&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_ROUTING_KEY=<span class="hljs-string">&quot;normal_routing_key&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(NORMAL_EXCHANGE,<span class="hljs-string">&quot;direct&quot;</span>);        <span class="hljs-comment">//设置过期时间为10s        //AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();        //模拟发10条消息        for (int i = 0; i &lt; 10; i++) &#123;            String message = String.valueOf(i);            //超过ttl变为死信            //channel.basicPublish(NORMAL_EXCHANGE,NORMAL_BINDING,properties,message.getBytes(&quot;UTF-8&quot;));             //超过最大长度变为死信            //channel.basicPublish(NORMAL_EXCHANGE,NORMAL_BINDING,null,message.getBytes(&quot;UTF-8&quot;));             channel.basicPublish(NORMAL_EXCHANGE,NORMAL_ROUTING_KEY,null,message.getBytes(&quot;UTF-8&quot;)); //消息被拒绝变为死信            System.out.println(&quot;生产者发出消息：&quot;+message);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<p>消费者C1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer01</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_EXCHANGE=<span class="hljs-string">&quot;normal_exchange&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_EXCHANGE=<span class="hljs-string">&quot;dead_exchange&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_QUEUE=<span class="hljs-string">&quot;normal_queue&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_QUEUE=<span class="hljs-string">&quot;dead_queue&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NORMAL_ROUTING_KEY=<span class="hljs-string">&quot;normal_routing_key&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEAD_ROUTING_KEY=<span class="hljs-string">&quot;dead_routing_key&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Channel channel = RabbitMqUtils.getChannel();        <span class="hljs-comment">//声明普通交换机和死信交换机，类型均为direct        channel.exchangeDeclare(NORMAL_EXCHANGE,&quot;direct&quot;);        channel.exchangeDeclare(DEAD_EXCHANGE,&quot;direct&quot;);        //声明正常队列。正常队列需要将死信消息转发到死信交换机，需要用到map参数        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();        //过期时间,比如为10s；也可以在生产者发送消息的时候设置过期时间        //arguments.put(&quot;x-message-ttl&quot;,10000);        //指定队列的最大长度，一旦消息个数超出这个长度，就会成为死信        //arguments.put(&quot;x-max-length&quot;,6);        //设置死信交换机，即死信消息将要转发到的交换机        arguments.put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE);        //设置死信routingkey,死信消息通过此路由键发送到死信队列。        arguments.put(&quot;x-dead-letter-routing-key&quot;,DEAD_ROUTING_KEY);        channel.queueDeclare(NORMAL_QUEUE,false,false,false,arguments);        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,NORMAL_ROUTING_KEY); //绑定        //声明死信队列        channel.queueDeclare(DEAD_QUEUE,false,false,false,null);        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,DEAD_ROUTING_KEY); //绑定        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            //模拟拒绝消息            String msg = new String(message.getBody(),&quot;UTF-8&quot;);            if(Integer.parseInt(msg)%2==0)&#123;                System.out.println(msg+&quot;被拒绝&quot;);                //拒绝消息                channel.basicReject(message.getEnvelope().getDeliveryTag(),false);            &#125;else&#123;                System.out.println(&quot;C1打印接收到的消息：&quot;+msg);                //手动应答消息                channel.basicAck(message.getEnvelope().getDeliveryTag(),false);            &#125;        &#125;;        CancelCallback cancelCallback = consumerTag-&gt;&#123;&#125;;        //模拟拒绝消息时，要关闭自动应答。        channel.basicConsume(NORMAL_QUEUE,false,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>疑问：为什么要在正常队列中设置<code>x-dead-letter-routing-key</code>? 不设置会导致死信队列收不到消息，但是下文中也设置了死信队列和DLX和Routing Key，二者如果不一致也会导致死信队列收不到死信消息。</p>
</blockquote>
<p>消费者C2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//C2只需要从死信队列中接收消息即可public class Consumer02 &#123;    public static final String DEAD_QUEUE=&quot;dead_queue&quot;;    public static void main(String[] args) throws IOException &#123;        Channel channel = RabbitMqUtils.getChannel();        DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123;            System.out.println(&quot;C2打印接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));        &#125;;        CancelCallback cancelCallback = consumerTag-&gt;&#123;&#125;;        channel.basicConsume(DEAD_QUEUE,true,deliverCallback,cancelCallback);    &#125;&#125;</span><br></code></pre></td></tr></table></figure>



<h1 id="七、延迟队列"><a href="#七、延迟队列" class="headerlink" title="七、延迟队列"></a>七、延迟队列</h1>]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
</search>

<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试总结 | JavaLearning</title><meta name="keywords" content="面试"><meta name="author" content="wenk207"><meta name="copyright" content="wenk207"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础 基本数据类型 Java 中有 8 种基本数据类型，分别为：  6 种数字类型 ：byte、short、int、long、float、double 1 种字符类型：char 1 种布尔型：boolean。  所占用的字节数：    基本类型 位数 字节 默认值     int 32 4 0   short 16 2 0   long 64 8 0L   byte 8 1 0   cha">
<meta property="og:type" content="article">
<meta property="og:title" content="面试总结">
<meta property="og:url" content="http://example.com/2021/06/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="JavaLearning">
<meta property="og:description" content="Java基础 基本数据类型 Java 中有 8 种基本数据类型，分别为：  6 种数字类型 ：byte、short、int、long、float、double 1 种字符类型：char 1 种布尔型：boolean。  所占用的字节数：    基本类型 位数 字节 默认值     int 32 4 0   short 16 2 0   long 64 8 0L   byte 8 1 0   cha">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/10.png">
<meta property="article:published_time" content="2021-06-15T13:43:41.000Z">
<meta property="article:modified_time" content="2022-02-17T02:29:19.817Z">
<meta property="article:author" content="wenk207">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/10.png"><link rel="shortcut icon" href="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/kai.png"><link rel="canonical" href="http://example.com/2021/06/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-17 10:29:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/李文凯证件照（白底）.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">JavaLearning</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">面试总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-15T13:43:41.000Z" title="发表于 2021-06-15 21:43:41">2021-06-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-17T02:29:19.817Z" title="更新于 2022-02-17 10:29:19">2022-02-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1>Java基础</h1>
<h2 id="基本数据类型">基本数据类型</h2>
<p>Java 中有 8 种基本数据类型，分别为：</p>
<ol>
<li>6 种数字类型 ：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code></li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ol>
<p><strong>所占用的字节数：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">基本类型</th>
<th style="text-align:left">位数</th>
<th style="text-align:left">字节</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left">32</td>
<td style="text-align:left">4</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"><code>short</code></td>
<td style="text-align:left">16</td>
<td style="text-align:left">2</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"><code>long</code></td>
<td style="text-align:left">64</td>
<td style="text-align:left">8</td>
<td style="text-align:left">0L</td>
</tr>
<tr>
<td style="text-align:left"><code>byte</code></td>
<td style="text-align:left">8</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"><code>char</code></td>
<td style="text-align:left">16</td>
<td style="text-align:left">2</td>
<td style="text-align:left">‘u0000’</td>
</tr>
<tr>
<td style="text-align:left"><code>float</code></td>
<td style="text-align:left">32</td>
<td style="text-align:left">4</td>
<td style="text-align:left">0f</td>
</tr>
<tr>
<td style="text-align:left"><code>double</code></td>
<td style="text-align:left">64</td>
<td style="text-align:left">8</td>
<td style="text-align:left">0d</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean</code></td>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<p>封装类：</p>
<p>有常量值技术：Byte、Short、Integer[-128,127]、Long</p>
<p>Boolean、Character</p>
<p>Float、Double</p>
<h2 id="泛型">泛型</h2>
<p>泛型提供了编译时<strong>类型安全检测机制</strong>，该机制允许程序员在编译阶段检测到非法的类型，也就是说<strong>把操作的数据类型被指定为一个参数</strong>。</p>
<p>Java 的泛型是伪泛型，这是因为 Java 在<strong>运行期间，所有的泛型信息都会被擦掉</strong>，这也就是通常所说类型擦除 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java中的泛型的作用就是为程序员的编程提供方便。在编译期间，可以把要操作类实例中的数据指定为某得数据类型。</span><br><span class="line">在运行期间，泛型不起作用。</span><br><span class="line"></span><br><span class="line">常见的泛型有：</span><br><span class="line">HashMap&lt;String,String&gt;、List&lt;Integer&gt;</span><br><span class="line"></span><br><span class="line">泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。</span><br></pre></td></tr></table></figure>
<h2 id="和equals的区别">==和equals的区别</h2>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都</span><br><span class="line">是值，只是引用类型变量存的值是对象的地址。</span><br></pre></td></tr></table></figure>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<p><strong>equals()方法存在两种使用情况：</strong></p>
<ul>
<li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><strong>String实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">System.out.println(aa == bb);<span class="comment">// true</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">42</span> == <span class="number">42.0</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<h2 id="HashCode和equals">HashCode和equals</h2>
<p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p>HashCode是Object类中的方法，所以所有的方法中都有HashCode方法。HashCode是本地方法（用navicat修饰），就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<p>HashCode和equals需要搭配使用，通过HashCode找到key所在的位置，然后通过equals比较value是否相等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</span><br><span class="line"></span><br><span class="line">如果两个对象的hashCode 值相等并且equals()方法返回 true，我们才认为这两个对象相等。</span><br><span class="line"></span><br><span class="line">如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。</span><br></pre></td></tr></table></figure>
<p><strong>为什么重写 equals() 时必须重写 hashCode() 方法？</strong></p>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p><strong>重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</strong></p>
<p>可能会两个相同的key，hashcode为其分配的位置是不同的，从而查找到的数据也是不同的。</p>
<h2 id="重载与重写">重载与重写</h2>
<p>相同点：都是多态的体现。</p>
<p>不同点：重载是同一个类中，方法名相同，但是参数列表不同。重写出现在子类继承父类时，重写父类中的方法。</p>
<h2 id="面向对象的三个特征">面向对象的三个特征</h2>
<p><strong>封装：</strong></p>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<p><strong>继承：</strong></p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。</span><br><span class="line"></span><br><span class="line">子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</span><br><span class="line"></span><br><span class="line">子类可以用自己的方式实现父类的方法。（以后介绍）</span><br></pre></td></tr></table></figure>
<p><strong>多态：</strong></p>
<p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<h2 id="String、StringBuffer-和-StringBuilder">String、StringBuffer 和 StringBuilder</h2>
<p><strong>可变性</strong>：</p>
<p>String是不可变的，StringBuffer和StringBuilder是可变的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">为什么String是不可变的：</span><br><span class="line">String 类中使用 final 关键字修饰字符数组来保存字符串。因此这个字符数组就是String私有的，不能被继承，并</span><br><span class="line">且String没有提供修改或者删除该字符串的方法。</span><br><span class="line"></span><br><span class="line">StringBuilder和StringBuffer的可变性：</span><br><span class="line">StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder </span><br><span class="line">中也是使用字符数组保存字符串，AbstractStringBuilder中有append方法可以对字符串进行修改。</span><br></pre></td></tr></table></figure>
<p><strong>线程安全性</strong>：</p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</p>
<p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<strong><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</strong></p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h2 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h2>
<p>浅拷贝：在堆上创建一个对象，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。Object中的clone方法。</p>
<p>深拷贝：完全复制整个对象</p>
<p>引用拷贝： 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/shallow&amp;deep-copy.64ee0760.png" alt="img"></p>
<h2 id="异常">异常</h2>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216150741705.png" alt="image-20220216150741705"></p>
<p>异常可以分为：</p>
<p>受检查的异常：编译阶段，没有被try/catch/throw包裹的话会报错。例如IO异常等。</p>
<p>不受检查的异常：编译阶段不会报错，运行阶段会出现错误。，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h2 id="IO流">IO流</h2>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>java中的流都是通过这四个基类实现的：</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/zzz.png" alt="zzz"></p>
<h2 id="值传递和引用传递">值传递和引用传递</h2>
<ul>
<li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实参和形参：</span><br><span class="line">实参（实际参数） ：用于传递给函数/方法的参数，必须有确定的值。</span><br><span class="line">形参（形式参数） ：用于定义函数/方法，接收实参，不需要有确定的值。</span><br></pre></td></tr></table></figure>
<p><strong>java中只有值传递</strong></p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是<strong>实参所引用的对象在堆中地址值的拷贝</strong>，同样也会创建副本。</li>
</ul>
<h2 id="反射">反射</h2>
<p>通过反射，可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。反射是框架底层实现的基础。</p>
<p>框架的四种实现方式：</p>
<p>1.知道具体类的情况下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;</span><br></pre></td></tr></table></figure>
<p>2.通过 <code>Class.forName()</code>传入类的路径获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">&quot;cn.kai.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>3.通过对象实例<code>instance.getClass()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TargetObject o = <span class="keyword">new</span> TargetObject();</span><br><span class="line">Class alunbarClass2 = o.getClass();</span><br></pre></td></tr></table></figure>
<p>4.通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = ClassLoader.loadClass(<span class="string">&quot;cn.kai.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>反射的优缺点：</p>
<p>优点：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p>缺点：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<h2 id="BigDecimal解决浮点数运算精度丢失问题">BigDecimal解决浮点数运算精度丢失问题</h2>
<p>《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 <code>BigDecimal</code> 来进行浮点数的运算”。</p>
<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<p>浮点数据类型会造成数据丢失：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">2.0f</span> - <span class="number">1.9f</span>;<span class="keyword">float</span> b = <span class="number">1.8f</span> - <span class="number">1.7f</span>;System.out.println(a);<span class="comment">// 0.100000024System.out.println(b);// 0.099999905System.out.println(a == b);// false</span></span><br></pre></td></tr></table></figure>
<p>原因：计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p>
<h3 id="comparable-和-Comparator-的区别">comparable 和 Comparator 的区别</h3>
<ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>实现Comparable进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Comparator 定制排序服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1>集合</h1>
<h2 id="集合概述">集合概述</h2>
<p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <strong><code>Collection</code>接口，主要用于存放单一元素</strong>；另一个是 <strong><code>Map</code> 接口，主要用于存放键值对</strong>。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/java-collection-hierarchy.9d3304ed.png" alt="img"></p>
<h3 id="List-Set-Queue-Map-四者的区别？">List, Set, Queue, Map 四者的区别？</h3>
<ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x” 代表 key，“y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h3 id="底层实现">底层实现</h3>
<p>List：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList                --Object[]数组</span><br><span class="line">Vector                   --Object[]数组，加synchronize锁，所以是线程安全的</span><br><span class="line">LinkedList               --双向链表</span><br></pre></td></tr></table></figure>
<p>Set：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素</span><br><span class="line">LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的</span><br><span class="line">TreeSet：红黑树实现</span><br></pre></td></tr></table></figure>
<p>Queue：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue: Object[] 数组来实现二叉堆</span><br><span class="line">ArrayQueue: Object[] 数组 + 双指针</span><br></pre></td></tr></table></figure>
<p>Map:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap: Object[]数组+链表+红黑树</span><br><span class="line">HashTable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的</span><br><span class="line">TreeMap：红黑树（自平衡的排序二叉树）</span><br></pre></td></tr></table></figure>
<h2 id="Collection之List接口">Collection之List接口</h2>
<p>List接口的特点：数据可重复，有序</p>
<h3 id="ArrayList和Vector的区别：">ArrayList和Vector的区别：</h3>
<ul>
<li>ArrayList的底层实现是Object[]数组，适用于频繁的查找工作线程不安全。</li>
<li>Vector的底层底层也是Object[]数组，但是是线程安全的。</li>
</ul>
<h3 id="Arraylist-与-LinkedList-区别"><strong>Arraylist 与 LinkedList 区别?</strong></h3>
<ul>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</li>
<li>插入和删除是否受元素位置的影响：ArrayList插入删除受位置影响，LinkedList底层是双向链表，所以不受位置影响。</li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h2 id="Collection-之-Set接口">Collection 之 Set接口</h2>
<p><strong>无序性和不可重复性的含义是什么</strong></p>
<p>1、什么是<strong>无序性</strong>？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是<strong>不可重复性</strong>？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<p><strong>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</strong></p>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="Collection之Queue接口">Collection之Queue接口</h2>
<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<h2 id="Map接口">Map接口</h2>
<h3 id="HashMap-和-Hashtable-的区别">HashMap 和 Hashtable 的区别</h3>
<p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p>
<p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p>
<p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p>
<p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
<p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制，底层实现是数组加链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">扩容每次是2次幂的原因：减少hash碰撞</span><br><span class="line">取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;</span><br><span class="line">(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这</span><br><span class="line">就解释了 HashMap 的长度为什么是 2 的幂次方</span><br></pre></td></tr></table></figure>
<h3 id="HashMap底层实现原理">HashMap底层实现原理</h3>
<p>JDK1.8 之后 <code>HashMap</code> 底层是 <strong>数组、链表和红黑树</strong> 。</p>
<p>HashMap 通过 key 的 hashCode 经过hash函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖；不相同就通过链表法解决冲突（链表法插入时是尾部插入），当链表长度到达一定程度时，链表会变为红黑树。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220113103039649.png" alt="image-20220113103039649"></p>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别</h3>
<p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>实现线程安全的方式（重要）：ConcurrentHashMap通过Synchronize加CAS的方式进行操作。HashTable只加了一把Synchronize锁，效率十分低下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁）对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。② Hashtable(同一把锁):使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216153346780.png" alt="image-20220216153346780"></p>
<p>ConcurrentHashMap(1.8):</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/java8_concurrenthashmap.772ed191.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）"></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code>TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h3 id="ConcurrentHashMap-线程安全的具体实现方式">ConcurrentHashMap 线程安全的具体实现方式</h3>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍</p>
<h1>并发</h1>
<h2 id="什么是线程和进程">什么是线程和进程</h2>
<p><strong>进程</strong>：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行就是进程从创建、运行、销毁的过程。</p>
<p><strong>线程</strong>：线程是比进程更小的资源。一个进程中可能会包含多个线程，多个线程共享进程的堆和方法区中的资源，但是每个线程都有自己的程序计数器，本地方法栈和虚拟机栈。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216153648466.png" alt="image-20220216153648466"></p>
<p><strong>总结：</strong> 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h2 id="线程间通信">线程间通信</h2>
<p>线程通信主要可以分为三种方式，分别为<strong>共享内存</strong>、<strong>消息传递</strong>和<strong>管道流</strong>。每种方式有不同的方法来实现。</p>
<ol>
<li><strong>共享内存</strong>：线程之间共享程序的<strong>公共状态</strong>，线程之间通过读-写内存中的公共状态来隐式通信。</li>
</ol>
<blockquote>
<p>volatile共享内存</p>
</blockquote>
<ol start="2">
<li><strong>消息传递</strong>：线程之间没有公共的状态，线程之间必须通过明确的发送信息来显示的进行通信。</li>
</ol>
<blockquote>
<p>wait/notify等待通知方式</p>
<p>join方式</p>
</blockquote>
<ol start="3">
<li><strong>管道流</strong>：管道输入/输出流的形式</li>
</ol>
<h2 id="进程间的通信方式">进程间的通信方式</h2>
<ol>
<li><strong>管道pipe</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li><strong>命名管道FIFO</strong>：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li><strong>消息队列MessageQueue</strong>：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li><strong>共享存储SharedMemory</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li><strong>信号量Semaphore</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>套接字Socket</strong></li>
<li><strong>信号 ( sinal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ol>
<h2 id="并发与并行">并发与并行</h2>
<ul>
<li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li>
</ul>
<h2 id="多线程可能存在的问题">多线程可能存在的问题</h2>
<p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p>
<h2 id="线程的生命周期和状态">线程的生命周期和状态?</h2>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216154311065.png" alt="image-20220216154311065"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220206172846942.png" alt="image-20220206172846942"></p>
<p>WAITING：等待状态，调用了wait（）方法</p>
<p>TIMED_WAITING：超时等待状态，调用thread.sleep（）方法。</p>
<p>BLOCKED：在线程同步中，没有获得锁的线程会进入到此状态。</p>
<h2 id="线程死锁">线程死锁</h2>
<p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>死锁的四个条件：</p>
<ul>
<li>互斥性</li>
<li>不可剥夺性</li>
<li>请求与保持</li>
<li>循环等待条件</li>
</ul>
<p>如何预防死锁：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
<li>安全模式，按照某种顺序来为每个进行分配资源，直到满足每个线程的最大所需资源，从而找到一条安全运行序列。</li>
</ol>
<h2 id="sleep-方法和-wait-方法区别和共同点">sleep() 方法和 wait() 方法区别和共同点?</h2>
<p>两者都可以暂停线程的执行。</p>
<p>两者最主要的区别在于：<strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</p>
<p><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</p>
<p><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</p>
<h2 id="调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？">调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2>
<p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，<strong>直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</strong></p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h2 id="synchronized-关键字的了解">synchronized 关键字的了解</h2>
<p><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<h3 id="怎么使用-synchronized-关键字">怎么使用 synchronized 关键字</h3>
<p><strong>1.修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<p><strong>2.修饰静态方法:</strong> 访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁</p>
<p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong> 。</p>
<h3 id="synchronized的原理">synchronized的原理</h3>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<h3 id="JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗">JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h3>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h3 id="synchronized-和-ReentrantLock-的区别">synchronized 和 ReentrantLock 的区别</h3>
<ol>
<li>两者都是可重入锁。可重入锁指的是自己可以再次获取自己中的内部锁。</li>
<li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。</li>
<li>ReentrantLock 比 synchronized 增加了一些高级功能
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong></li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
</li>
</ol>
<h2 id="volatile-关键字">volatile 关键字</h2>
<p>作用：</p>
<ol>
<li>防止JVM指令重排。</li>
<li>保证变量的可见性。可以实现共享内存。</li>
</ol>
<p>新建一个对象时的顺序如下：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向分配的内存空间</li>
</ol>
<h3 id="并发编程的三个重要特点">并发编程的三个重要特点</h3>
<p><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</p>
<p><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</p>
<p><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化</p>
<h3 id="synchronized-关键字和-volatile-关键字的区别">synchronized 关键字和 volatile 关键字的区别</h3>
<p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性</strong></li>
</ul>
<h2 id="线程池">线程池</h2>
<h3 id="为什么要用线程池？">为什么要用线程池？</h3>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p><strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h3 id="创建线程的三种方式">创建线程的三种方式</h3>
<ol>
<li>继承Thread接口类。</li>
<li>实现Runnable接口。</li>
<li>实现Callable接口。</li>
</ol>
<h3 id="实现-Runnable-接口和-Callable-接口的区别">实现 Runnable 接口和 Callable 接口的区别</h3>
<p>Runable接口调用的是run方法，Callable接口调用的是call方法。其中Runnable方法是有返回值的。</p>
<p>在底层中，Runnable可以Executors方法，将Runnable对象转换为Callable对象。</p>
<h3 id="执行-execute-方法和-submit-方法的区别是什么呢？">执行 execute()方法和 submit()方法的区别是什么呢？</h3>
<p><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p>
<p><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="创建线程池的方法">创建线程池的方法</h3>
<p>方式一：通过构造方法实现。最好使用ThreadPoolExecutor 。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220209153610235.png" alt="image-20220209153610235"></p>
<p>方式二：通过 Executor 框架的工具类 Executors 来实现。</p>
<h3 id="创建线程池的七大参数">创建线程池的七大参数</h3>
<p>重要参数</p>
<ol>
<li><strong><code>corePoolSize</code> ：核心线程池数。</strong></li>
<li><strong><code>maximumPoolSize</code> ：线程池的最大容量。</strong></li>
<li><strong><code>workQueue</code>：工作队列/任务队列。</strong></li>
</ol>
<p>其他参数</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>：超时等待时间，线程的最长等待时间。</li>
<li><strong><code>unit</code></strong> ：时间的单位。</li>
<li><strong><code>handler</code></strong> ：拒绝策略。当线程池满了时，需要执行那种策略。默认是抛出异常。</li>
<li><strong><code>threadFactory</code></strong> ：创建线程的工厂。通过工厂模式创建线程。</li>
</ol>
<h3 id="常见的拒绝策略">常见的拒绝策略</h3>
<p>拒绝策略：如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<p><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</p>
<p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 使用传递任务的线程来执行次任务。</p>
<p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</p>
<p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</p>
<h3 id="线程池的运行原理">线程池的运行原理</h3>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220209155822709.png" alt="image-20220209155822709"></p>
<h3 id="Thread类和线程池的区别">Thread类和线程池的区别</h3>
<p>Thread类的弊端：</p>
<ul>
<li>每次new Thread新建对象性能差。</li>
<li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</li>
<li>缺乏更多功能，如定时执行、定期执行、线程中断。</li>
</ul>
<p>使用线程池的好处：</p>
<ul>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ul>
<h2 id="抽象队列同步器AQS">抽象队列同步器AQS</h2>
<p>AQS 的全称为（<code>AbstractQueuedSynchronizer</code>），这个类在<code>java.util.concurrent.locks</code>包下面。</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器 <code>ReentrantLock</code>，<code>Semaphore</code>是基于 AQS 的。</p>
<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216160218745.png" alt="image-20220216160218745"></p>
<p>aqs中定义共享资源的两种方式：</p>
<ol>
<li>独占。</li>
<li>共享。</li>
</ol>
<h3 id="AQS组件">AQS组件</h3>
<p><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</p>
<p><strong><code>CountDownLatch</code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p>
<p><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p>
<p>循环栅栏的使用场景：</p>
<p>比如写入多个文件时，设置循环栅栏，可以在所有文件都写入完成之后在返回。</p>
<h1>JVM</h1>
<h2 id="Java内存区域">Java内存区域</h2>
<h3 id="运行时数据区">运行时数据区</h3>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216160523936.png" alt="image-20220216160523936"></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>
<p>程序计数器：最小的一块内存，但是运行的效率最快，相当于字节码运行的行号解释器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**程序计数器是Java内存中唯一一个不会出现OutOfMemory的区域，因为它随着线程的创建而创建，随着线程的结束而死亡。</p>
</li>
<li>
<p>虚拟机栈：描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java内存可以粗略的分为堆内存和栈内存，其中栈内存指的就是虚拟机栈。Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 </span><br><span class="line">Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</span><br><span class="line">Java 方法有两种返回方式： return 语句; 抛出异常。 不管哪种返回方式都会导致栈帧被弹出。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。</p>
</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>
<p>堆：Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么说“几乎”？</span><br><span class="line">从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸</span><br><span class="line">出去），那么对象可以直接在栈上分配内存。</span><br></pre></td></tr></table></figure>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在JDK7之前，堆内存通常分为：新生代，老生代和永生代。永生代是永远不会被垃圾回收的，这就可能会导致堆内存发生溢出。所以在JDK8彻底移除了永生代，取而代之的是元空间，元空间使用的是直接内存。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220213132859916.png" alt="image-20220213132859916"></p>
<p>**上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。**对象在Eden空间中分配内存，经历过一次垃圾回收之后进入survivor区，当经历过n次垃圾回收之后，就会变成老生代。老生代是一个设置好的阈值。</p>
</li>
<li>
<p>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为什么使用元空间代替永生代？</span><br><span class="line">1.整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存</span><br><span class="line">的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</span><br><span class="line">2.元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用</span><br><span class="line">空间来控制，这样能加载的类就更多了</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>直接内存 (非运行时数据区的一部分)：<strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
</li>
</ul>
<h3 id="运行时的常量池">运行时的常量池</h3>
<p>JDK1.7之前，运行时常量池是方法区的一部分。1.8之后，运行时常量池存放在堆内存中。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<h2 id="Java对象的相关探讨">Java对象的相关探讨</h2>
<h3 id="对象的创建">对象的创建</h3>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220213134107121.png" alt="image-20220213134107121"></p>
<ol>
<li>类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
<li>分配内存：有空闲列表和指针碰撞两种方式。</li>
<li>初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>设置对象头：初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 ----- 著作权归Guide哥所有。</li>
<li>执行init方法：此时，从虚拟机的角度看，对象已经创建好了。但是只有执行init方法，从Java对象的角度看，此对象才算是创建成功。</li>
</ol>
<h3 id="对象的内存布局">对象的内存布局</h3>
<p>对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></p>
<h3 id="对象的访问定位">对象的访问定位</h3>
<p>主要有两种方式：使用句柄和直接指针两种。</p>
<p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p>
<p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220213135256336.png" alt="image-20220213135256336"></p>
<h2 id="JVM垃圾回收机制">JVM垃圾回收机制</h2>
<h3 id="判断对象死亡的方法">判断对象死亡的方法</h3>
<ul>
<li>
<p>引用计数法</p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
</li>
<li>
<p>可达性分析法</p>
<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
</li>
</ul>
<p>GC root：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<h3 id="引用">引用</h3>
<ul>
<li>强引用：永远不会被回收</li>
<li>软引用：内存足够时，不会被回收</li>
<li>弱引用：当发生垃圾回收时，会被回收</li>
<li>虚引用：不论何时，都可能被回收</li>
</ul>
<h3 id="如何判断一个类是无用的类">如何判断一个类是无用的类</h3>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h3 id="垃圾收集算法">垃圾收集算法</h3>
<ul>
<li>标记-清除算法：产生大量的内存碎片</li>
<li>标记-复制</li>
<li>标记-整理</li>
<li>分代收集算法</li>
</ul>
<h3 id="垃圾收集器">垃圾收集器</h3>
<ul>
<li>Serial 收集器：单线程，<strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></li>
<li>ParNew 收集器：多线程版本</li>
<li>CMS 收集器：收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</li>
<li>G1 收集器：G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</li>
</ul>
<h2 id="类加载">类加载</h2>
<h1>数据库</h1>
<h2 id="基础知识">基础知识</h2>
<h3 id="数据库范式了解吗">数据库范式了解吗?</h3>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li>
</ul>
<h3 id="drop、delete-与-truncate-区别？">drop、delete 与 truncate 区别？</h3>
<ul>
<li>drop(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>
<li>truncate (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>
<li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一列的数据，如果不加 where 子句和<code>truncate table 表名</code>作用类似。</li>
</ul>
<p>执行速度：drop&gt;truncate&gt;delete</p>
<h3 id="数据库设计通常分为哪几步">数据库设计通常分为哪几步?</h3>
<ol>
<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>
<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li>
</ol>
<h2 id="MySQL数据库">MySQL数据库</h2>
<h3 id="Char和VarChar的区别">Char和VarChar的区别</h3>
<ol>
<li>
<p>最大长度：</p>
<p>char最大长度是255字符，varchar最大长度是65535个字节。</p>
</li>
<li>
<p>定长：</p>
<p>char是定长的，不足的部分用隐藏空格填充，varchar是不定长的。</p>
</li>
<li>
<p>空间使用：</p>
<p>char会浪费空间，varchar会更加节省空间。</p>
</li>
<li>
<p>查找效率：</p>
<p>char查找效率会很高，varchar查找效率会更低。</p>
</li>
<li>
<p>尾部空格：</p>
<p>char插入时可省略，vaechar插入时不会省略，查找时省略。</p>
</li>
</ol>
<h3 id="存储引擎">存储引擎</h3>
<p>5.5版本之前 ：MyISAM。</p>
<p>5.5版本之后 ： InnoDB。</p>
<h3 id="MyISAM-和-InnoDB-的区别">MyISAM 和 InnoDB 的区别</h3>
<ol>
<li>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li>MyISAM 不提供事务支持。InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</li>
<li>MyISAM 不支持外键，而 InnoDB 支持。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
</ol>
<h3 id="什么是事务">什么是事务</h3>
<p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<h3 id="事务的特性（ACID）">事务的特性（ACID）</h3>
<ul>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li></li>
</ul>
<h3 id="MySQL中InnoDB引擎是怎么保证ACID的">MySQL中InnoDB引擎是怎么保证ACID的</h3>
<ul>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>
<li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li>
<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li>
</ul>
<h3 id="MVCC实现的原理">MVCC实现的原理</h3>
<p>数据库并发的场景：</p>
<ul>
<li><code>读-读</code>：不存在任何问题，也不需要并发控制</li>
<li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<p>MVCC能解决<strong>读-写</strong>的线程安全问题，想要彻底解决就需要MVCC+锁机制</p>
<p><strong>原理：</strong></p>
<p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <code>3个隐式字段</code>，<code>undo日志</code> ，<code>Read View</code> 来实现的。</p>
<p>三个隐藏字段：</p>
<ul>
<li><code>DB_TRX_ID</code><br>
6byte，最近修改(<code>修改/插入</code>)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>
<li><code>DB_ROLL_PTR</code><br>
7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>
<li><code>DB_ROW_ID</code><br>
6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以<code>DB_ROW_ID</code>产生一个聚簇索引</li>
</ul>
<h3 id="并发事务带来哪些问题">并发事务带来哪些问题?</h3>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是<strong>修改</strong>，比如多次读取一条记录发现其中某些列的值被修改；幻读的重点在于<strong>新增或者删除</strong>，比如多次读取一条记录发现记录增多或减少了</p>
<h3 id="事务隔离级别有哪些">事务隔离级别有哪些?</h3>
<p>MySQL数据库的默认隔离级别是：可重复读</p>
<ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更</li>
<li><strong>READ-<strong>COMMITTED</strong>(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h3 id="牛客网项目中，私信功能的数据表格式">牛客网项目中，私信功能的数据表格式</h3>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220217101951936.png" alt="image-20220217101951936"></p>
<p>主要包括主键id；发送方id；接收方id；为了方便查找消息，将发送方id与接收方id做了一个拼接，以后想要找到聊天信息的话，直接查询这个字段就可以了；发送内容content；状态：已读，未读，删除；创建的时间。</p>
<h2 id="MySQL索引">MySQL索引</h2>
<p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash</strong></p>
<h3 id="索引的优缺点">索引的优缺点</h3>
<p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<h3 id="B-树索引">B+树索引</h3>
<p>InnoDB引擎中索引的底层结构是B+树。B+树时一棵<strong>多路平衡查找树</strong></p>
<p>B+树的特点：</p>
<ul>
<li>B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/20210420165409106.png" alt="img"></p>
<h3 id="索引的最左匹配">索引的最左匹配</h3>
<p>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<h3 id="查看是否使用索引">查看是否使用索引</h3>
<p>通过explain命令查看。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/v2-767c9106f588ed86ed775306784db9fe_r.jpg" alt="preview"></p>
<p>在最后一个字段extra中，会标注有没有使用索引。rows是查询结果的字段数量。filtered是过滤掉的字段数量。</p>
<h3 id="聚集索引与非聚集索引">聚集索引与非聚集索引</h3>
<ul>
<li>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</li>
<li>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。</li>
</ul>
<p>主键索引：叶子节点存放的是data。</p>
<p>二级索引/辅助索引：叶子节点存放的是主键。</p>
<h3 id="MySQL回表查询">MySQL回表查询</h3>
<p>回表：<strong>先定位主键值key，再通过主键值找到data，相当于发生了两次查询操作</strong>。非聚集索引和辅助索引都会发生回表操作。</p>
<h3 id="创建索引的注意事项">创建索引的注意事项</h3>
<ol>
<li>选择合适创建索引的字段
<ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
</li>
<li><strong>被频繁更新的字段应该慎重建立索引。</strong></li>
<li>尽可能的考虑建立联合索引而不是单列索引。
<ul>
<li>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</li>
</ul>
</li>
<li><strong>注意避免冗余索引</strong> 。</li>
<li><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></li>
</ol>
<h3 id="索引失效的情况">索引失效的情况</h3>
<ol>
<li>
<p>where语句中包含or时，可能会导致索引失效。如果or的两边是相同的索引的话，可以命中。</p>
</li>
<li>
<p>where语句中索引列使用了负向查询，可能会导致索引失效。负向查询包括：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等</p>
</li>
<li>
<p>索引字段可以为null，使用is null或is not null时，可能会导致索引失效</p>
</li>
<li>
<p><strong>在索引列上使用内置函数，一定会导致索引失效</strong></p>
</li>
<li>
<p><strong>对索引列进行运算，一定会导致索引失效</strong>。select<code> </code>* <code>from` ````user``` </code>where<code> </code>age - 1 = 10;</p>
</li>
<li>
<p><strong>like通配符可能会导致索引失效</strong>。可以使用覆盖索引来命中，覆盖索引是指select后加索引字段名。</p>
</li>
<li>
<p><strong>联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效</strong></p>
</li>
<li>
<p><strong>MySQL优化器的最终选择，不走索引</strong></p>
<p>即使完全符合索引生效的场景，考虑到实际数据量等原因，最终是否使用索引还要看MySQL优化器的判断。当然你也可以在sql语句中写明强制走某个索引。</p>
<p>索引优化的建议：</p>
<ul>
<li>禁止在更新十分频繁、区分度不高的属性上建立索引</li>
<li>建立组合索引，必须把区分度高的字段放在前面。</li>
</ul>
</li>
</ol>
<h2 id="Redis数据库">Redis数据库</h2>
<h3 id="基本数据类型-2">基本数据类型</h3>
<p>String、list、set、zset、hash（<strong>特别适合用于存储对象</strong>）</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">简介</th>
<th style="text-align:left">特性</th>
<th style="text-align:left">场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">String(字符串)</td>
<td style="text-align:left">二进制安全</td>
<td style="text-align:left">可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">Hash(字典)</td>
<td style="text-align:left">键值对集合,即编程语言中的Map类型</td>
<td style="text-align:left">适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
<td style="text-align:left">存储、读取、修改用户属性</td>
</tr>
<tr>
<td style="text-align:left">List(列表)</td>
<td style="text-align:left">链表(双向链表)</td>
<td style="text-align:left">增删快,提供了操作某一段元素的API</td>
<td style="text-align:left">1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td>
</tr>
<tr>
<td style="text-align:left">Set(集合)</td>
<td style="text-align:left">哈希表实现,元素不重复</td>
<td style="text-align:left">1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td>
<td style="text-align:left">1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td>
</tr>
<tr>
<td style="text-align:left">Sorted Set(有序集合)</td>
<td style="text-align:left">将Set中的元素增加一个权重参数score,元素按score有序排列</td>
<td style="text-align:left">数据插入集合时,已经进行天然排序</td>
<td style="text-align:left">1、排行榜 2、带权重的消息队列</td>
</tr>
</tbody>
</table>
<h3 id="过期的数据的删除策略了解么？">过期的数据的删除策略了解么？</h3>
<ul>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ul>
<h3 id="Redis-持久化机制">Redis 持久化机制</h3>
<p>RDB和AOF。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>
<h3 id="Redis-事务">Redis 事务</h3>
<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）。</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a target="_blank" rel="noopener" href="https://redis.io/commands/discard"><code>DISCARD</code>  (opens new window)</a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/watch"><code>WATCH</code> (opens new window)</a>命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p>
<h3 id="缓存穿透和缓存雪崩">缓存穿透和缓存雪崩</h3>
<p><strong>缓存穿透</strong>：缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p>
<p>解决方法：</p>
<ol>
<li>布隆过滤器</li>
<li>在前端添加判断语句，防止非法的请求传入。</li>
<li>缓存无效的key</li>
</ol>
<p><strong>缓存雪崩</strong>：</p>
<ul>
<li>场景一：硬件问题，缓存失效。缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</li>
<li>场景二：缓存在同一时间过期。有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上</li>
</ul>
<p>针对场景一：</p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p>针对场景二：</p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h3 id="Redis为什么快">Redis为什么快</h3>
<ol>
<li>
<p>Redis具有缓存功能，缓存就是直接操作内存，内存的读写速度极快。</p>
</li>
<li>
<p>Redis采用单线程,避免了不必要的上下文切换和竞争。</p>
</li>
<li>
<p>Redis使用非阻塞的I/O多路复用技术，可以处理并发的连接。redis使用非阻塞I/O；</p>
<p><code>IO</code>多路复用程序会同时监听多个<code>socket</code>，当被监听的<code>socket</code>准备好执行<code>accept</code>、<code>read</code>、<code>write</code>、<code>close</code>等操作时，与这些操作相对应的文件事件就会产生。<code>IO</code>多路复用程序会把所有产生事件的<code>socket</code>压入一个队列中，然后有序地每次仅一个<code>socket</code>的方式传送给文件事件分派器，文件事件分派器接收到<code>socket</code>之后会根据<code>socket</code>产生的事件类型调用对应的事件处理器进行处理。</p>
</li>
</ol>
<h3 id="Redis集群的三种模式">Redis集群的三种模式</h3>
<ul>
<li><strong>主从复制模式</strong>：主从模式是三种模式中最简单的，在主从复制中，数据库分为两类：主数据库(master)和从数据库(slave)。数据写入到master上，然后复制到slave中。</li>
<li><strong>哨兵模式</strong>：主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作，因此sentinel应运而生。sentinel中文含义为哨兵，顾名思义，它的作用就是监控redis集群的运行状况。当master宕机之后，会自动选举一个slave作为master</li>
<li><strong>集群模式</strong>：sentinel模式基本可以满足一般生产的需求，具备高可用性。但是当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中。cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。</li>
</ul>
<h3 id="哨兵模式下，slave的选举成master的规则">哨兵模式下，slave的选举成master的规则</h3>
<p>选点的依据依次是：网络连接正常-&gt;5秒内回复过INFO命令-&gt;10*down-after-milliseconds内与主连接过的-&gt;从服务器优先级-&gt;复制偏移量-&gt;运行id较小的。</p>
<p>选出之后通过slaveif no ont将该从服务器升为新master。</p>
<h3 id="redis集群模式下，数据是怎么知道要分配到那个集群上的">redis集群模式下，数据是怎么知道要分配到那个集群上的</h3>
<ol>
<li>
<p>节点取余</p>
<p>假设有三个节点，因为redis中的数据是key-value存放的，所以先计算hash（key），再对其根据节点数取余。</p>
<p>缺点：<strong>不支持扩展，增、删缓存服务器时，缓存失效</strong>。</p>
</li>
<li>
<p>一致性hash法</p>
<p>用Hash算法<strong>根据服务器IP</strong>或hostname得出这三台服务器的<strong>Hash值</strong>。然后把他映射到<strong>0-2的32次方减一</strong>上。</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220217094042065.png" alt="image-20220217094042065"></p>
<p>然后，计算key的hash值，通过顺指针的方式，先指向哪个节点，就存放到哪里。</p>
</li>
<li>
<p>hash槽</p>
<p>Hash槽共有**16384(2的14次方)**个槽，每台服务器分管一部分。先计算数据的hash值，然后通过取余操作，查看其放在哪个Hash槽上，就能知道分配到哪个集群上。</p>
</li>
</ol>
<h2 id="Spring-IOC-AOP">Spring IOC &amp; AOP</h2>
<p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spirng 特有，在其他语言中也有应用。 –</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/frc-365faceb5697f04f31399937c059c162.png" alt="img"></p>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/926dfc549b06d280a37397f9fd49bf9d.jpg" alt="SpringAOPProcess"></p>
<h2 id="Spring-bean">Spring bean</h2>
<p>bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>bean的作用域，默认是singleton：</p>
<ul>
<li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>
</ul>
<p>配置作用域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br></pre></td></tr></table></figure>
<h3 id="单例-bean-的线程安全问题了解吗？">单例 bean 的线程安全问题了解吗？</h3>
<ol>
<li>在 bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）</li>
</ol>
<h2 id="SpringMVC-工作原理了解吗">SpringMVC 工作原理了解吗?</h2>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/de6d2b213f112297298f3e223bf08f28.png" alt="img"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h2 id="Spring-管理事务的方式有几种？">Spring 管理事务的方式有几种？</h2>
<ul>
<li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li>
<li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>
</ul>
<h2 id="MyBatis中-和-的区别是什么？">MyBatis中#{}和${}的区别是什么？</h2>
<p><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换</p>
<p><code>#&#123;&#125;</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为? 号，可以用来解决SQL注入攻击。</p>
<h1>计算机基础</h1>
<h2 id="计算机网络">计算机网络</h2>
<h3 id="计算机网络的结构">计算机网络的结构</h3>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216171128693.png" alt="image-20220216171128693"></p>
<ol>
<li>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等等。</li>
<li>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。</li>
<li>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 IP协议</li>
<li>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</li>
<li>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</li>
</ol>
<h3 id="TCP-三次握手和四次挥手">TCP 三次握手和四次挥手</h3>
<p>三次握手：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216171427031.png" alt="image-20220216171427031"></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<p>四次挥手：</p>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216171538001.png" alt="image-20220216171538001"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<h3 id="TCP-UDP-协议的区别">TCP, UDP 协议的区别</h3>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h3 id="TCP-协议如何保证可靠传输">TCP 协议如何保证可靠传输</h3>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</li>
</ol>
<h3 id="在浏览器中输入-url-地址-显示主页的过程">在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程</h3>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216172000460.png" alt="image-20220216172000460"></p>
<p>过程：</p>
<ol>
<li>DNS 解析，根据输入的IP地址找到对应的web服务器。</li>
<li>TCP 连接，与web服务器建立连接。</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="HTTP状态码">HTTP状态码</h3>
<p><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/image-20220216172255179.png" alt="image-20220216172255179"></p>
<h3 id="HTTP-和-HTTPS-的区别？">HTTP 和 HTTPS 的区别？</h3>
<ol>
<li><strong>端口</strong> ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li><strong>安全性和资源消耗：</strong> HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ol>
<p>对称加密与非对称加密：</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</li>
</ul>
<h1>设计模式</h1>
<h2 id="适配器模式">适配器模式</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wenk207</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/06/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">http://example.com/2021/06/15/面试总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">JavaLearning</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/10.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/09/30/hello-world/"><img class="prev-cover" src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/李文凯证件照（白底）.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenk207</div><div class="author-info__description">谦逊，努力，时刻保持学习状态</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="http://wenk207.top/"><i class="fa fa-heartbeat"></i><span>JavaLearning</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/WenkAndZz" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/li17669498364@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashCode%E5%92%8Cequals"><span class="toc-number">1.4.</span> <span class="toc-text">HashCode和equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">1.5.</span> <span class="toc-text">重载与重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="toc-number">1.6.</span> <span class="toc-text">面向对象的三个特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder"><span class="toc-number">1.7.</span> <span class="toc-text">String、StringBuffer 和 StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.8.</span> <span class="toc-text">浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">1.10.</span> <span class="toc-text">IO流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">1.11.</span> <span class="toc-text">值传递和引用传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.12.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">1.13.</span> <span class="toc-text">BigDecimal解决浮点数运算精度丢失问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.1.</span> <span class="toc-text">comparable 和 Comparator 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List-Set-Queue-Map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">List, Set, Queue, Map 四者的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E4%B9%8BList%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">Collection之List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">ArrayList和Vector的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.2.</span> <span class="toc-text">Arraylist 与 LinkedList 区别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E4%B9%8B-Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">Collection 之 Set接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E4%B9%8BQueue%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">Collection之Queue接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.5.</span> <span class="toc-text">Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.1.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.2.</span> <span class="toc-text">HashMap底层实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.3.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.4.</span> <span class="toc-text">ConcurrentHashMap 线程安全的具体实现方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">什么是线程和进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">3.2.</span> <span class="toc-text">线程间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">进程间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">3.4.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">多线程可能存在的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">3.6.</span> <span class="toc-text">线程的生命周期和状态?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">3.7.</span> <span class="toc-text">线程死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">3.8.</span> <span class="toc-text">sleep() 方法和 wait() 方法区别和共同点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">3.10.</span> <span class="toc-text">synchronized 关键字的了解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.10.1.</span> <span class="toc-text">怎么使用 synchronized 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.10.2.</span> <span class="toc-text">synchronized的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-6-%E4%B9%8B%E5%90%8E%E7%9A%84-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%99%E4%BA%9B%E4%BC%98%E5%8C%96%E5%90%97"><span class="toc-number">3.10.3.</span> <span class="toc-text">JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.10.4.</span> <span class="toc-text">synchronized 和 ReentrantLock 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.11.</span> <span class="toc-text">volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">3.11.1.</span> <span class="toc-text">并发编程的三个重要特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.11.2.</span> <span class="toc-text">synchronized 关键字和 volatile 关键字的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.12.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">3.12.1.</span> <span class="toc-text">为什么要用线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.12.2.</span> <span class="toc-text">创建线程的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%E5%92%8C-Callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.12.3.</span> <span class="toc-text">实现 Runnable 接口和 Callable 接口的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-execute-%E6%96%B9%E6%B3%95%E5%92%8C-submit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">3.12.4.</span> <span class="toc-text">执行 execute()方法和 submit()方法的区别是什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.12.5.</span> <span class="toc-text">创建线程池的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="toc-number">3.12.6.</span> <span class="toc-text">创建线程池的七大参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">3.12.7.</span> <span class="toc-text">常见的拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">3.12.8.</span> <span class="toc-text">线程池的运行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.12.9.</span> <span class="toc-text">Thread类和线程池的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS"><span class="toc-number">3.13.</span> <span class="toc-text">抽象队列同步器AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E7%BB%84%E4%BB%B6"><span class="toc-number">3.13.1.</span> <span class="toc-text">AQS组件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.1.</span> <span class="toc-text">Java内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">4.1.1.</span> <span class="toc-text">运行时数据区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">4.1.2.</span> <span class="toc-text">运行时的常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8E%A2%E8%AE%A8"><span class="toc-number">4.2.</span> <span class="toc-text">Java对象的相关探讨</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.2.1.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">4.2.2.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.2.3.</span> <span class="toc-text">对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.</span> <span class="toc-text">JVM垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">判断对象死亡的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">4.3.3.</span> <span class="toc-text">如何判断一个类是无用的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.4.</span> <span class="toc-text">垃圾收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.3.5.</span> <span class="toc-text">垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.4.</span> <span class="toc-text">类加载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">5.1.1.</span> <span class="toc-text">数据库范式了解吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drop%E3%80%81delete-%E4%B8%8E-truncate-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.1.2.</span> <span class="toc-text">drop、delete 与 truncate 区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E9%80%9A%E5%B8%B8%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E6%AD%A5"><span class="toc-number">5.1.3.</span> <span class="toc-text">数据库设计通常分为哪几步?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.2.</span> <span class="toc-text">MySQL数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Char%E5%92%8CVarChar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.1.</span> <span class="toc-text">Char和VarChar的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">5.2.2.</span> <span class="toc-text">存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E5%92%8C-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.3.</span> <span class="toc-text">MyISAM 和 InnoDB 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.2.4.</span> <span class="toc-text">什么是事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="toc-number">5.2.5.</span> <span class="toc-text">事务的特性（ACID）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%ADInnoDB%E5%BC%95%E6%93%8E%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81ACID%E7%9A%84"><span class="toc-number">5.2.6.</span> <span class="toc-text">MySQL中InnoDB引擎是怎么保证ACID的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.7.</span> <span class="toc-text">MVCC实现的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.8.</span> <span class="toc-text">并发事务带来哪些问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.2.9.</span> <span class="toc-text">事务隔离级别有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2%E7%BD%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E7%A7%81%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.2.10.</span> <span class="toc-text">牛客网项目中，私信功能的数据表格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.</span> <span class="toc-text">MySQL索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.3.1.</span> <span class="toc-text">索引的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.2.</span> <span class="toc-text">B+树索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">5.3.3.</span> <span class="toc-text">索引的最左匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.4.</span> <span class="toc-text">查看是否使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.5.</span> <span class="toc-text">聚集索引与非聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.3.6.</span> <span class="toc-text">MySQL回表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.3.7.</span> <span class="toc-text">创建索引的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">5.3.8.</span> <span class="toc-text">索引失效的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.4.</span> <span class="toc-text">Redis数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">5.4.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">5.4.2.</span> <span class="toc-text">过期的数据的删除策略了解么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.3.</span> <span class="toc-text">Redis 持久化机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.4.4.</span> <span class="toc-text">Redis 事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">5.4.5.</span> <span class="toc-text">缓存穿透和缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-number">5.4.6.</span> <span class="toc-text">Redis为什么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.7.</span> <span class="toc-text">Redis集群的三种模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8Cslave%E7%9A%84%E9%80%89%E4%B8%BE%E6%88%90master%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">5.4.8.</span> <span class="toc-text">哨兵模式下，slave的选举成master的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%A6%81%E5%88%86%E9%85%8D%E5%88%B0%E9%82%A3%E4%B8%AA%E9%9B%86%E7%BE%A4%E4%B8%8A%E7%9A%84"><span class="toc-number">5.4.9.</span> <span class="toc-text">redis集群模式下，数据是怎么知道要分配到那个集群上的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-IOC-AOP"><span class="toc-number">5.5.</span> <span class="toc-text">Spring IOC &amp; AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-bean"><span class="toc-number">5.6.</span> <span class="toc-text">Spring bean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B-bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.6.1.</span> <span class="toc-text">单例 bean 的线程安全问题了解吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">5.7.</span> <span class="toc-text">SpringMVC 工作原理了解吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">Spring 管理事务的方式有几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">MyBatis中#{}和${}的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">计算机基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">6.1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.1.</span> <span class="toc-text">计算机网络的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">TCP 三次握手和四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-UDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.3.</span> <span class="toc-text">TCP, UDP 协议的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">6.1.4.</span> <span class="toc-text">TCP 协议如何保证可靠传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-url-%E5%9C%B0%E5%9D%80-%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.5.</span> <span class="toc-text">在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">6.1.6.</span> <span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.1.7.</span> <span class="toc-text">HTTP 和 HTTPS 的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">适配器模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/15/kubesphere%E5%AF%B9k8s%E5%8E%9F%E7%94%9F%E7%9A%84%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%94%B9%E8%BF%9B/" title="kubesphere对k8s原生的多租户改进"><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kubesphere对k8s原生的多租户改进"/></a><div class="content"><a class="title" href="/2022/02/15/kubesphere%E5%AF%B9k8s%E5%8E%9F%E7%94%9F%E7%9A%84%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%94%B9%E8%BF%9B/" title="kubesphere对k8s原生的多租户改进">kubesphere对k8s原生的多租户改进</a><time datetime="2022-02-15T09:22:35.000Z" title="发表于 2022-02-15 17:22:35">2022-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/27/flink-cluster-yaml%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E9%85%8D%E7%BD%AE/" title="flink-cluster.yaml中关于日志的配置"><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/13.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="flink-cluster.yaml中关于日志的配置"/></a><div class="content"><a class="title" href="/2022/01/27/flink-cluster-yaml%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E9%85%8D%E7%BD%AE/" title="flink-cluster.yaml中关于日志的配置">flink-cluster.yaml中关于日志的配置</a><time datetime="2022-01-27T03:22:10.000Z" title="发表于 2022-01-27 11:22:10">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/%E6%9F%A5%E8%AF%A2-%E5%88%A0%E9%99%A4%E7%BB%99%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/" title="查询/删除给定目录下的所有文件"><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="查询/删除给定目录下的所有文件"/></a><div class="content"><a class="title" href="/2022/01/18/%E6%9F%A5%E8%AF%A2-%E5%88%A0%E9%99%A4%E7%BB%99%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/" title="查询/删除给定目录下的所有文件">查询/删除给定目录下的所有文件</a><time datetime="2022-01-18T03:01:23.000Z" title="发表于 2022-01-18 11:01:23">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/Redis%E4%B8%BB%E5%8A%A8%E5%A4%87%E4%BB%BD/" title="Redis主动备份"><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis主动备份"/></a><div class="content"><a class="title" href="/2022/01/14/Redis%E4%B8%BB%E5%8A%A8%E5%A4%87%E4%BB%BD/" title="Redis主动备份">Redis主动备份</a><time datetime="2022-01-14T02:54:41.000Z" title="发表于 2022-01-14 10:54:41">2022-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/Kibana%E3%80%81Logstash%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE/" title="Kibana、Logstash配置设置"><img src="https://gitee.com/wenkaiLLLLL/blog-img/raw/master/img/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kibana、Logstash配置设置"/></a><div class="content"><a class="title" href="/2022/01/14/Kibana%E3%80%81Logstash%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE/" title="Kibana、Logstash配置设置">Kibana、Logstash配置设置</a><time datetime="2022-01-14T02:54:16.000Z" title="发表于 2022-01-14 10:54:16">2022-01-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By wenk207</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>